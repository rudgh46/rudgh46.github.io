---
title: "[Daily Contents] 블록체인 프로젝트의 구조 뜯어보기"
categories:
  - Daily Contents
tags:
  - Daily Contents
  # -
toc: true
toc_sticky: true
toc_label: "블록체인 프로젝트의 구조 뜯어보기"
toc_icon: "bookmark"
---

<br>

## 어떤 체인을 사용할 것인가?

- Private Chain

- Public Chain
  - 누구나 접근이 가능하며 진정한 의미의 탈중앙화라는 장점이 있음
  - 데이터를 저장하는 것이 매우 비싸고, Transaction이 발생할 때마다 비용을 지불해야 함.
  - 다소 복잡한 Smart Contract의 배포 비용(0.5ETH)
  - 이더리움
    - Middle man의 제거가 가능해짐
    - 닷컴 버블 이후 가장 성장한 비즈니스는 광고 플랫폼 등 Middle man이 필요한 산업
    - Smart Contract은 바로 이 Middle man의 개입 없이 공정한 분배가 이루어질 수 있음

## 오라클 문제

- Oracle이란 블록체인 밖의 데이터를 블록체인 안(On-chain)으로 가져오는 것을 의미함.
- 비가 오면 John에게 10$를 주겠다 >> 비가 왔다는 정보
- 주사위를 던져서 3보다 큰 수가 나오면 1$를 지불한다 >> 코드로 구현 가능
- 10월 11일이 되면 이 빌딩의 소유권을 Paul에게 양도한다 >> 10월 11일이 되었다는 정보

## 어떤 체인을 사용할 것인가

- Private Chain은 DB에 준하는 빠른 속도
- 사전에 약속된 사용자만 참가 가능
- 주로 Hyperledger fabric을 사용
- 사용자가 인지할 수 없는 사이에 블록체인 활용 가능

## 전체 구조를 이해해보자

```
[FrontEnd]
<<<>>>
[Application Binary Interface] <<<>>> [Ethereum Network]
<<<>>>
[BackEnd(Spring), Wrapper Class]
```

## 메타마스크

- 쉽게 사용할 수 있는 크롬 익스텐션.
- Key를 보관하고 서명을 안전하게 하는 역할을 한다.
- Web3를 이용해서 쉽게 서명할 수 있다.
- 개발자는 추상화된 API를 이용해서 쉽게 개발 가능.
- 아 잘 모르겠고 우선 지갑이나 만들어볼까 할 때 학습.

## 프론트엔드에서 블록체인과 통신하는 법

- Web3.js를 이용한다.
- 직접 private key를 이용해서 서명하는 것도 가능하지만 metamask와 같은 서비스를 이용하는 것이 안전.
- 다른 사람의 지갑 주소로 ETH를 전송하거나 Smart Contract과 통신해서 데이터를 받아오는 것도 가능.

## ABI?

- Application Binary Interface
- API랑 좀 닮지 않았습니까?
  - API가 프로그램과 통신하기 위한 인터페이스라면 ABI는 Binary와 통신하기 위한 인터페이스
- Binary 형태로 컴파일된 Smart Contract과 통신하기 위한 Interface

## 컴파일된 바이너리의 모습

- 문자열. 단, 0과 f로 표현된 영역이 많기에 해석하려면 해석할 수 있기는 함.

## Human Readable한 형태

- Json의 형태.

## How to build? Use solc

- solc 이외에도 truffle이라는 라이브러리를 활용

## How to deploy?

- bytecode와 ABI를 이용해서 deploy한다.
- Remix가 있지 않나요?
  - 개발 단계에서 배포할 수는 있으나 파이프라인을 구축해 놓은 뒤에 매번 수정하고 배포하는 것은 번거롭기에 Remix는 개발 때만 활용하는 것을 추천.

## Payable modifier

- 가장 핵심적인 Modifier

- 이더리움에 깔려있는 전제가 하나 있다.
- 핵심 로직은 이더리움을 이용한 결제를 통해 발생한다.
- 이더리움이 스마트 컨트랙에 입금될 때의 로직을 만들고 싶다면?
- payable modifier를 붙여준다면 구현 가능하다!
- (이더리움) 모임 통장 만들기, 경매, 안전 거래 등등
- 대부분의 핵심 로직은 payable modifier를 이용해서 구현한다.

## Q. 블록체인에 영상을 저장하고 싶어요.

- 이더리움의 블록 크기는 1~8MB 수준
- 여기에 영상을 저장할 수 있을까?
- 텍스트 형태의 데이터라도 200개 이상 저장하는 것이 어렵다
- 그렇다면 어떤 방법이 있을까?
  - 일반적으로 파일을 정합성을 확인할 때는 해시값을 이용한다.
  - 동영상의 해시값을 블록체인에 저장한다면?

## 이더리움 VS 자체 코인

**화폐의 가치는 어떻게 결정되는가?**

- 화폐의 가치는 그 화폐를 사람들이 얼마나 신용하는지에 따라서 결정된다.
- 코인의 가치 혹은 블록체인의 가치도 사람들의 신용도에 따라서 결정.
- 이더리움은 많은 사람들이 사용하기 때문에 신용도가 높고 가치도 높다.
- 우리가 만든 자체 코인은 자유도가 높지만 신용도는 매우 낮을 것.
- 하지만 사람들은 가치를 떠나서 그냥 받는 것을 좋아하기도 한다.

## Wrapper Class?

- Web3j를 이용해서 Smart Contract와 통신하기 위해서는 Wrapper Class를 생성해야 한다!
- Compile된 Binary로부터 Wrapper Class를 생성함.
- Compile된 Binary가 조금이라도 변경된다면 Wrapper Class를 다시 만들어야 한다.
- 주석, 공백을 포함해서 어떤 것이 바뀌어도 Wrapper Class는 다시 만들어야 한다.
  - Jenkins 같은 자동화된 빌드 도구를 사용하는 것이 좋은 방법

## 유저가 블록체인을 불편해 할 때?

- 서비스 제공자가 사용자 별로 키를 보관하고 관리해 줄 수 있다.
- 신규 유저가 생기면 지갑을 생성하고 보관한다.
- 로그인 인증을 통해서 유저를 확인하고 대신 서명을 해 준다.
- 일반적인 거래소들이 많이 활용하는 방법!
- 대부분의 유저들에게 블록체인을 이해시키기 어렵기 때문에 사용한다.

## FE VS BE 어디서 처리할까?

- 완전한 탈중앙화를 추구한다면 FE에서 유저에게 서명하는 것이 옳다.
- 그러나 유저 입장에서는 블록체인에 익숙하지 않기 때문에 우리 서비스의 BE에서 대신 관리해주는 것도 가능하다.
- 구조를 설계할 때에 반드시 미리 결정해야 하는 부분이 이곳이다.

## 어떤 네트워크를 사용할 것인가?

- SUB PJT1에 했던 것들이 무엇이었을까?
- 우리만 사용할 수 있는 Private Network를 구성한 것!
- Infura와 같은 public하게 구성된 테스트넷들이 많이 있다.
- 실제로 이더리움 메인넷과 동일한 환경인 테스트넷을 사용하는 것이 가능하다.
- 실 서비스를 운영한다면 이더리움 메인넷에 배포해야 할 것.

## Public network를 쓸 때의 장점

- 익스플로러를 지원. 디버깅이 편하다.

```
Q. BE에서 서명할 때 DB에서 개인키를 저장하는 것인가?
A. 개인키는 DB에 저장, 한 번 더 암호화를 할 수는 있으나 DB가 털렸는데 암호화 키가 안전할 거라는 보장은 없음. 설계가 중요.
```

```
Q. BE에서 트랜잭션을 발생시키면 대리서명의 이슈는 어떻게 해결해야 하나요?
A. 대리서명을 해 줄 수밖에 없음.
```
