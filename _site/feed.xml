<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-07T01:07:52+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">경호의 블로그</title><subtitle>느리더라도 천천히 성장하는 블로그입니다.</subtitle><author><name>김경호</name></author><entry><title type="html">[Daily Contents] IT Trends</title><link href="http://localhost:4000/daily%20contents/IT-Trends/" rel="alternate" type="text/html" title="[Daily Contents] IT Trends" /><published>2022-11-23T00:00:00+09:00</published><updated>2022-11-23T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/IT%20Trends</id><content type="html" xml:base="http://localhost:4000/daily%20contents/IT-Trends/"><![CDATA[<p><br /></p>

<h2 id="it-trends">IT Trends</h2>

<h3 id="gartner">Gartner</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>미국의 정보 및 기술 자문 회사
보고서와 자문 서비스를 판매
Hype Cycle(솔루션)을 제공하여 시장의 기대 값 예측
</code></pre></div></div>

<h3 id="삼성-sds">삼성 SDS</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>삼성 그룹의 ICT 기업
솔루션 &amp; 플랫폼 &amp; IT 서비스 제공
매년 IT 기술 트랜드를 제공하여, 현재 삼성에서 주목하고 있는 기술을 소개
</code></pre></div></div>

<h2 id="quiz">Quiz</h2>

<ul>
  <li>코끼리를 냉장고에 넣는 법?</li>
  <li>무소불위의 권력으로 넣도록 한다.</li>
</ul>

<h2 id="strategic-technology-trends">Strategic Technology Trends</h2>

<ul>
  <li>Gartner Top 10 Strategic Technology Trends(2012)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Media tablets and beyond
2. Mobile-centric application and interfaces
3. Contextual and social user experience
4. Internet of Things
5. App stores and markerplaces
6. Next-generation analythics
7. Big data
8. In-memory computing
9. Extreme low-energy severs
10. Cloud computing
</code></pre></div></div>

<ul>
  <li>Gartner Top 10 Strategic Technology Trends(2015)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Computing Everywhere
2. The Internet of Things
3. 3D Printing
4. Advanced, Pervasive and Invisible Analytics
5. Context-Rich Systems
6. Smart Machines
7. Cloud/Client Computing
8. Software-Defined Applications and Infrastructure
9. Web-Scale IT
10. Risk-Based Security and Self-protection
</code></pre></div></div>

<h2 id="quiz-1">Quiz</h2>

<ul>
  <li>기린을 냉장고에 넣는 법?</li>
  <li>코끼리가 있건 말건 그냥 넣는다.</li>
</ul>

<h2 id="strategic-technology-trends-1">Strategic Technology Trends</h2>

<ul>
  <li>Gartner Top 10 Strategic Technology Trends(2019)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Intelligent
- Autonomous Things, Augmented Analytics, AI-Driven Development
Digital
- Digital Twin, Empowered Edge, Immersive Experience
Mesh
- Blockchain, Smart Spaces
(Privacy and Ethics, Quantum Computing)
</code></pre></div></div>

<h2 id="quiz-2">Quiz</h2>

<ul>
  <li>사자가 동물 회의를 개최했습니다. 감히 불참한 동물은?</li>
  <li>호랑이</li>
</ul>

<h2 id="strategic-technology-trends-2">Strategic Technology Trends</h2>

<ul>
  <li>Gartner Top 10 Strategic Technology Trends(2021)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>사람 중심
- 행동인터넷 IoB, 통합 경험 Total Experience, 개인정보보호 강화 컴퓨팅
위치 독립성
- 분산 클라우드, 어디서나 운영, 사이버 보안망
회복 탄력성
- 지능적 결합가능 비즈니스, 인공지능 공학, 초 자동화
</code></pre></div></div>

<ul>
  <li>Gartner Top 10 Strategic Technology Trends(2023)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Optimize
- Digital Immune System, Applied Observability, AI TRiSM
Scale
- Industry Cloud Platforms, Platform Engineering, Wireless Value Realization
Pioneer
- Superapps, Adaptive AI, Metaverse
</code></pre></div></div>

<h2 id="metaverse">Metaverse</h2>

<ul>
  <li>지금은 좀 안 풀리는데 아모른직다.</li>
</ul>

<h2 id="quiz-3">Quiz</h2>

<ul>
  <li>7기 여러분, 라이브 방송 몇 회나 했을까요?</li>
  <li>106회</li>
</ul>

<h2 id="live-방송">Live 방송</h2>

<ul>
  <li>공통 프로젝트
    <ul>
      <li>IT 프로젝트를 하기 위해서 알아야 할 기초적인 지식들</li>
      <li>Web의 중요성(현업에서 많은 프로젝트들이 웹 프로젝트)</li>
      <li>Git/아키텍쳐/Cloud/프로젝트 배포 등</li>
    </ul>
  </li>
  <li>특화 프로젝트
    <ul>
      <li>프로젝트 진행을 위한 특화 Domain과 관련된 기술 전달</li>
      <li>다양한 도메인 별 특강 준비</li>
      <li>AI/BigData/BlockChain/IoT 제어 등 특화 관련된 방송 위주</li>
    </ul>
  </li>
  <li>자율 프로젝트
    <ul>
      <li>IT 업계 속의 다양한 주제 및 기술에 대한 방송 진행</li>
      <li>7기 교육생들이 원하는 방송으로 준비하려고 노력</li>
      <li>SSAFY 졸업 이후 사회에 나가기 위해 &amp; 나가서 활용할 수 있는 다양한 주제를 준비</li>
    </ul>
  </li>
</ul>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Daily Contents] 주니어 개발자 성장 촉진제</title><link href="http://localhost:4000/daily%20contents/%EC%A3%BC%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%84%B1%EC%9E%A5-%EC%B4%89%EC%A7%84%EC%A0%9C/" rel="alternate" type="text/html" title="[Daily Contents] 주니어 개발자 성장 촉진제" /><published>2022-11-22T00:00:00+09:00</published><updated>2022-11-22T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EC%A3%BC%EB%8B%88%EC%96%B4%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EC%84%B1%EC%9E%A5%20%EC%B4%89%EC%A7%84%EC%A0%9C</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EC%A3%BC%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%84%B1%EC%9E%A5-%EC%B4%89%EC%A7%84%EC%A0%9C/"><![CDATA[<p><br /></p>

<h2 id="책-읽기의-필요성">책 읽기의 필요성</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>책에는 낡은 지식만 있다?
인터넷에 다 있다?
직접 해 보며 배우면 된다?
지루하다.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Classic(변하지 않는 원칙과 지식들)
점과 선, 그리고 면
경험의 한계, 연역적 지식
개발 능력자들이 읽고 쓴 바로 그 책!!
</code></pre></div></div>

<h2 id="코드-컴플릿-저자">코드 컴플릿 저자</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>좋은 프로그래밍 책을 두 달에 한 권, 즉 일주일에 35페이지 정도만 읽어도, 당신은 이내 이 분야에 대한 확실한 감을 갖게 될 것이며 주변의 거의 모든 이들과 구별되는 수준으로 올라설 것이다. -스티브 맥코넬-
</code></pre></div></div>

<h2 id="주니어-개발자의-책-읽기">주니어 개발자의 책 읽기</h2>

<ul>
  <li>성장 최소량의 법칙
    <ul>
      <li>베테랑 개발자의 내공과 통찰</li>
      <li>개발을 더 잘 하려면 어떻게 해야 할까</li>
      <li>SW 개발의 생태</li>
    </ul>
  </li>
  <li>무엇을 읽을까</li>
  <li>언제 읽을까</li>
  <li>어떻게 읽을까
    <ul>
      <li>주도적으로 읽기</li>
      <li>함께 읽기</li>
      <li>싸피 도서관 등 회사의 지원 제도 활용</li>
      <li>적용하고 실천하기</li>
    </ul>
  </li>
</ul>

<h2 id="언제-읽어도-좋은-책">언제 읽어도 좋은 책</h2>

<ul>
  <li>바비의 컴퓨터 프로그래머가 될래요
    <ul>
      <li>절판</li>
    </ul>
  </li>
  <li>실용주의 프로그래머, 2022(2005)
    <ul>
      <li>꼭 봐라, 멘토 추천</li>
    </ul>
  </li>
  <li>소프트웨어 장인, 2015
    <ul>
      <li>KHI 코치 추천</li>
    </ul>
  </li>
  <li>테스트 주도 개발, 2014
    <ul>
      <li>꼭 봐라, 멘토 추천</li>
    </ul>
  </li>
</ul>

<h2 id="프로젝트-전-읽으면-좋을-책">프로젝트 전 읽으면 좋을 책</h2>

<ul>
  <li>훌륭한 프로그래머 되는 법, 2015
    <ul>
      <li>Good First</li>
    </ul>
  </li>
  <li>클린 코드, 2013
    <ul>
      <li>꼭 봐라, 멘토 추천</li>
    </ul>
  </li>
  <li>디자인 패턴, 2015
    <ul>
      <li>어렵다면…</li>
    </ul>
  </li>
  <li>헤드퍼스트 디자인 패턴, 2022</li>
</ul>

<h2 id="자매품-클린-시리즈">(자매품) 클린 시리즈</h2>

<ul>
  <li>클린 아키텍쳐, 2019</li>
  <li>클린 코더, 2016
    <ul>
      <li>멘토 추천</li>
    </ul>
  </li>
  <li>클린 소프트웨어, 2017
    <ul>
      <li>멘토 추천</li>
    </ul>
  </li>
</ul>

<h2 id="프로젝트를-하며-읽으면-좋을-책">프로젝트를 하며 읽으면 좋을 책</h2>

<ul>
  <li>리픽터링 2판, 2020
    <ul>
      <li>멘토 추천</li>
    </ul>
  </li>
  <li>코드 컴플릿 2판, 2017
    <ul>
      <li>모니터 받침</li>
    </ul>
  </li>
  <li>이펙티브 자바 3판, 2018
    <ul>
      <li>자바 필수</li>
    </ul>
  </li>
</ul>

<h2 id="프로젝트를-마치고-읽으면-좋을-책">프로젝트를 마치고 읽으면 좋을 책</h2>

<ul>
  <li>맨먼스 미신, 2015(1975)
    <ul>
      <li>은총알 그 책</li>
    </ul>
  </li>
  <li>피플웨어 3판, 2014</li>
  <li>죽음의 행진, 문제 프로젝트에서 살아남는 법, 2005
    <ul>
      <li>비수 주의, 절판…</li>
    </ul>
  </li>
  <li>프로그래밍 심리학, 2013(1971)
    <ul>
      <li>DHA 코치 추천</li>
    </ul>
  </li>
</ul>

<h2 id="휴가-가서-읽으면-좋을-책">휴가 가서 읽으면 좋을 책</h2>

<ul>
  <li>해커와 화가, 2015(2004)
    <ul>
      <li>멘토 추천, VC 대부</li>
    </ul>
  </li>
  <li>조엘 온 소프트웨어, 2005
    <ul>
      <li>그냥 재미있음</li>
    </ul>
  </li>
  <li>코딩 호러, 2014
    <ul>
      <li>stackoverflow</li>
    </ul>
  </li>
</ul>

<h2 id="취업하고-읽으면-좋을-책">취업하고 읽으면 좋을 책</h2>

<ul>
  <li>프로젝트 헤일메리, 2021
    <ul>
      <li>개발자 출신 소설가(마션 작가)</li>
    </ul>
  </li>
  <li>커리어 스킬, 2019</li>
  <li>개발자로 살아남기, 2022
    <ul>
      <li>30년 내공</li>
    </ul>
  </li>
</ul>

<h2 id="이직-준비할-때-읽으면-좋을-책">이직 준비할 때 읽으면 좋을 책</h2>

<ul>
  <li>CS 전공지식 노트, 2022
    <ul>
      <li>CS 동아줄?</li>
    </ul>
  </li>
  <li>코딩 인터뷰 완전 분석, 2017</li>
  <li>프로그래밍 면접 이렇게 준비한다, 2019
    <ul>
      <li>시작하기 좋음</li>
    </ul>
  </li>
</ul>

<h2 id="and-more">And More…</h2>

<ul>
  <li>데드라인, 2004
    <ul>
      <li>S3 컨설턴트 추천</li>
      <li>무려 소설!</li>
    </ul>
  </li>
  <li>개발자의 글쓰기, 2019
    <ul>
      <li>SYS 코치 추천</li>
    </ul>
  </li>
  <li>1일 1로그 100일 완성 IT 지식, 2022</li>
</ul>

<h2 id="more-and-more">More and more…</h2>

<ul>
  <li>객체지향의 사실과 오해, 2015
    <ul>
      <li>GHJ 코치 추천</li>
    </ul>
  </li>
  <li>잘 그리기 금지, 2021
    <ul>
      <li>1K 코치 추천</li>
    </ul>
  </li>
</ul>

<h2 id="마치며">마치며</h2>

<p>좋은 책을 읽는 것은 과거의 <strong>가장 뛰어난 사람들과 대화</strong>를 나누는 것과 같다. <strong>- 르네 데카르트</strong></p>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Daily Contents] 정규 표현식</title><link href="http://localhost:4000/daily%20contents/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/" rel="alternate" type="text/html" title="[Daily Contents] 정규 표현식" /><published>2022-11-15T00:00:00+09:00</published><updated>2022-11-15T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EC%A0%95%EA%B7%9C%20%ED%91%9C%ED%98%84%EC%8B%9D</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/"><![CDATA[<p><br /></p>

<h2 id="정규-표현식regular-expressions">정규 표현식(Regular expressions)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>전화번호, 이메일 유효성 체크할 때나 복/붙해서 쓰는 것 아닌가?
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 개발에는 편집을 포함한 텍스트 관련 작업이 필수
- 선배들의 노하우가 담긴 파워풀한 도구
- 익숙해진다면 손 빠른 개발에 큰 도움을 줄 수 있다
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 온전한 프로그래밍 언어는 아님
- 다른 프로그래밍 언어나 제품에 포함된 '작은 언어'
- 제품마다 조금씩 다른 문법
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 텍스트를 찾고 조작하는데 쓰는 문자열
- 텍스트 검색, 치환에 사용
- 수십 라인의 프로그래밍 없이 정규식 1~2줄로 대부분의 문자열 작업 가능
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- email, 주민번호, 생년월일 등의 형식 검증(validation)
- 데이터 전처리 작업
- 프로젝트 리팩토링 작업
- Database 검색, 치환 작업
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- IDE, editor, 심지어 MS Word도 지원
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- SW 엔지니어에게 '외국어'같은 존재
- 다양한 문제 해결법
- 친숙해진다면 파워풀한 도구
</code></pre></div></div>

<h3 id="정규-표현식-온라인-테스트-도구">정규 표현식 온라인 테스트 도구</h3>

<p>https://regexr.com</p>

<h3 id="문자-하나-찾기">문자 하나 찾기</h3>

<ul>
  <li>일반적인 문자 그대로 기재</li>
  <li>’.’와 같은 메타 문자를 검색하려면 ‘'로 이스케이프</li>
</ul>

<h3 id="문자-집합으로-찾기">문자 집합으로 찾기</h3>

<ul>
  <li>대괄호 ([])를 사용하여 문자 집합 표현</li>
  <li>[] 집합에 속한 문자 가운데 하나가 일치</li>
  <li>[] 내에 ‘-‘은 연속 요소를 표현 [1-5] -&gt; [12345]</li>
  <li>캐럿(‘^’) 문자는 집합 안에 있는 문자나 범위를 모두 제외</li>
</ul>

<h3 id="반복-찾기">반복 찾기</h3>

<ul>
  <li>파워풀한 정규 표현 패턴의 능력</li>
  <li>’+’: 하나 이상 일치</li>
  <li>’*’: 없거나 하나 이상 일치</li>
  <li>’?’: 없거나 하나 일치</li>
  <li>중괄호 ‘{}’ 내에 반복 횟수 기재 {3} : 3번</li>
  <li>게으른 수량자로 문자를 최소로 일치</li>
</ul>

<h3 id="위치-찾기">위치 찾기</h3>

<ul>
  <li>텍스트 영역 내 특정 위치에서 검색 희망</li>
  <li>‘\b’: 단어 경계</li>
  <li>’^’: 문자열 경계의 시작</li>
  <li>’$’: 문자열 경계의 끝</li>
</ul>

<h3 id="하위-표현식">하위 표현식</h3>

<ul>
  <li>큰 표현식 안에 속한 일부 표현식을 한 항목으로 다루도록 묶음</li>
  <li>’()’: 괄호로 묶음 가능</li>
  <li>&gt;{2,} vs (&gt;){2,}</li>
  <li>파워풀한 중첩된 하위 표현식</li>
</ul>

<h3 id="하위-표현식---역참조">하위 표현식 - 역참조</h3>

<ul>
  <li>하위 표현식으로 매칭된 타겟을 참조</li>
  <li>일치한 부분을 반복해 찾거나 치환에 사용</li>
  <li>텍스트를 검색하고 치환하는데 매우 유용</li>
  <li>‘There is a ball on on the table.’ - 실수로 중복된 전치사?</li>
</ul>

<h3 id="전방-탐색">전방 탐색</h3>

<ul>
  <li>일치 영역을 발견해도 그 값을 반환하지 않는 패턴</li>
  <li>실제로는 하위 표현식이며 같은 형식으로 작성</li>
  <li>(?=일치할 텍스트)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://project.ssafy.com
ftp://pds.ssafy.com
https://lab.ssafy.com
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/.+(?=:)/g
/(?&lt;=\/\/).+/g
</code></pre></div></div>

<h3 id="전후방-탐색-동시-사용">전후방 탐색 동시 사용</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;head&gt;
  &lt;title&gt;SSAFY GIT&lt;/title&gt;
&lt;/head&gt;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/(?&lt;=&lt;title&gt;).*(?=&lt;\/title&gt;)/g
</code></pre></div></div>

<h3 id="역참조-조건-사용">역참조 조건 사용</h3>

<ul>
  <li>정규 표현식 조건은 물음표(?)를 사용해 정의</li>
  <li>역참조 조건은 이전 하위 표현식이 검색에 성공했을 경우에 한하여 다시 해당 표현식을 검사</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>(?(역참조)true</td>
          <td>false)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(02)2256-3112
(032)-789-3256
010-2679-9318
010 4321 1987
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/(\()?\d{2,3}(?(1)\)|-)\d{3,4}-\d{4}/g
</code></pre></div></div>

<h2 id="문제">문제</h2>

<ul>
  <li>전치사 2개가 각각 역순으로 반복 –&gt; 정상으로</li>
  <li>There is a ball on the the on table</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/(\w+)\*(\w+)\*\2*\1/g
</code></pre></div></div>

<h2 id="정규-표현식-책-추천">정규 표현식 책 추천</h2>

<p><strong>손에 잡히는 정규 표현식</strong></p>

<ul>
  <li>AP 개발자에게 필요한 내용을 빠르게 습득 가능</li>
  <li>마스터 레벨까지 커버하지는 못함</li>
</ul>

<h2 id="마지막으로">마지막으로</h2>

<ul>
  <li>비 개발자도 알아두면 유용한 도구</li>
  <li>텍스트를 다루는 모든 작업에 파워풀한 도구</li>
  <li>이해가 아닌 체득의 영역</li>
</ul>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Daily Contents] 테스트주도개발 TDD</title><link href="http://localhost:4000/daily%20contents/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C-TDD/" rel="alternate" type="text/html" title="[Daily Contents] 테스트주도개발 TDD" /><published>2022-11-11T00:00:00+09:00</published><updated>2022-11-11T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%20TDD</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C-TDD/"><![CDATA[<p><br /></p>

<h2 id="코딩은-결정-피드백의-연속">코딩은 결정, 피드백의 연속</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>이 함수는 이런 기능을 짜야겠군 -&gt; 결정(Decision)
그런데 내가 이 함수를 잘 만든 걸까? -&gt; 피드백(Feedback)
그럼 함수를 완성하고 여기에 피드백을 받을 테스트 케이스를 만들어야겠다!
</code></pre></div></div>

<h2 id="코드---테스트케이스">코드 -&gt; 테스트케이스</h2>

<ul>
  <li>현재 시간이 AM, PM인지 판단하여 리턴하는 함수</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string GetAMorPM() {
  var now = DateTime.Now;
  if(now.Hour &lt; 12) {
    return "AM";
  } else {
    return "PM";
  }
}
</code></pre></div></div>

<ul>
  <li>문제점은? 테스트를 하려면 오전, 오후가 될 때까지 기다려야 하나?</li>
  <li>코드부터 작성하면 테스트 코드를 작성하기가 쉽지 않다!</li>
</ul>

<h2 id="테스트를-어렵게-만드는-것은">테스트를 어렵게 만드는 것은…?</h2>

<p><strong>불확실성 : 임의의 값, 임의의 시간 필요</strong></p>

<ul>
  <li>전역변수, 외부 API서버로부터 받는 값 등</li>
</ul>

<p><strong>부수작업들…</strong></p>

<ul>
  <li>DB에 기록</li>
  <li>메일 발송</li>
  <li>
    <p>외부에 뭔가를 전달하지만 리턴값이 없는…</p>
  </li>
  <li>결정과 피드백 사이의 간격이 커져버린다.(코드 작성 싱에는 왜 몰랐을까?) 좁히려면 너무 많은 비용이 든다. - Kent Back</li>
</ul>

<h2 id="테스트케이스---코드">테스트케이스 -&gt; 코드</h2>

<p><strong>테스트케이스</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>assertThat(getAMorPM(10:00), equalTo("AM"));
assertThat(getAMorPM(14:00), equalTo("PM"));
</code></pre></div></div>

<p><strong>코드</strong> - 여기에 맞춰 코드를 작성하면 외부 라이브러리 Datetime는 개입이 되지 않는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string GetAMorPM(time) {
  if(time.Hour &lt; 12) {
    return "AM";
  } else {
    return "AM";
  }
}
</code></pre></div></div>

<ul>
  <li>TDD는 단위 테스트다? 테스트를 많이 해 보는 것이다? (X)</li>
  <li>TDD는 테스트부터 짜고 코드를 작성하는 것 (O)</li>
</ul>

<h2 id="실습-로그인-기능-개발">실습: 로그인 기능 개발</h2>

<ul>
  <li>로그인 기능에 몇 개의, 어떤 케이스가 필요할까?</li>
</ul>

<table>
  <thead>
    <tr>
      <th>NO</th>
      <th>When</th>
      <th>Given</th>
      <th>Then</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>로그인 버튼 클릭</td>
      <td>ID: 정상 + PW: 일치</td>
      <td>정상 로그인</td>
    </tr>
    <tr>
      <td>2</td>
      <td>로그인 버튼 클릭</td>
      <td>ID 미입력</td>
      <td>ID 입력 메세지 팝업</td>
    </tr>
    <tr>
      <td>3</td>
      <td>로그인 버튼 클릭</td>
      <td>PW 미입력</td>
      <td>PW 입력 메세지 팝업</td>
    </tr>
    <tr>
      <td>4</td>
      <td>로그인 버튼 클릭</td>
      <td>ID 입력 + PW: 불일치</td>
      <td>PW 확인 요청 메세지</td>
    </tr>
    <tr>
      <td>5</td>
      <td>로그인 버튼 클릭</td>
      <td>ID: 없는 ID 입력 + PW: 아무 값</td>
      <td>없는 ID 메세지 팝업</td>
    </tr>
  </tbody>
</table>

<h2 id="파일--별도-제공">파일 : 별도 제공</h2>

<h2 id="정리">정리</h2>

<ul>
  <li>TDD는 원하는 코드를 먼저 하는 게 아니라 테스트 케이스를 먼저 만들고 이를 만족시켜 가며 목적 함수를 만든다.</li>
  <li>테스트부터 짜면 다음과 같은 이점이 있음
    <ul>
      <li>테스트 수행 커버리지를 100%로 맞추기 쉽다.</li>
      <li>테스트 가능한 코드가 저절로 만들어진다. -&gt; Clean Code의 기초</li>
    </ul>
  </li>
  <li>수행 케이스는 “함수” 관점에서… 관통 케이스를 TDD로 하기는 어렵다.</li>
</ul>

<p><strong>그럼 단점은?</strong></p>

<ul>
  <li>테스트에 걸리는 시간만큼 개발 시간이 필요하다.</li>
  <li>진입장벽이 있어 습관화하기 어렵다.</li>
  <li>생각지 못한 테스트의 경우수가 있을 수 있다.</li>
</ul>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Daily Contents] 코드리뷰</title><link href="http://localhost:4000/daily%20contents/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/" rel="alternate" type="text/html" title="[Daily Contents] 코드리뷰" /><published>2022-11-09T00:00:00+09:00</published><updated>2022-11-09T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/"><![CDATA[<p><br /></p>

<ul>
  <li>정적분석 툴 : SonaQube
    <ul>
      <li>https://www.sonarqube.org</li>
      <li>버그, 취약점, 보안이슈 등 볼 수 있음</li>
      <li>버그 등급
        <ul>
          <li>Blocker - 서버 다운될 정도</li>
          <li>Critical - 서버 다운 X, 기능 다운 X</li>
          <li>Major - 서버 다운 X, 기능 다운 되지는 않으나 기능이 안됨
            <ul>
              <li>배포가 안됨</li>
              <li>현업에서는 Major까지 처리를 해야 올림</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>NullPointerException</p>

    <ul>
      <li>버그의 70~80% : <code class="language-plaintext highlighter-rouge">NullPointerException</code></li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//전
if(image != null){
  if(image.getContentType().startWith("image")){
  }
}

//후
if(image != null &amp;&amp; !image.getContentType()){
  if(image.getContentType().startWith("image")){
  }
}
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//전
Member follow = memberRepository.findById(followId).get();

//후
Optional&lt;&gt; aaa = memberRepository.findById(followId).get();
if(aaa.isPresent()){
}
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@Transactional</code>은 private에서 쓸 수 없고 public에서만 쓸 수 있음</li>
  <li>엔티티로 받으면 안됨
    <ul>
      <li>DB에 들어가는 값이 그대로 들어가기 때문에 외부에서 들어오는 값은 바로 set해주면 injection에 취약하기 때문에 vaildation 체크가 필요함</li>
      <li>-&gt; HashMap 사용 / Dto or Vo 사용</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//전
public ReponseEntity&lt;Void&gt; 뭐시기(@PathVariable(value="뭐시기") 뭐시기 뭐시기, Member member){}

//후
public ReponseEntity&lt;Void&gt; 뭐시기(@PathVariable(value="뭐시기") 뭐시기 뭐시기,HashMap member){
String aaa = member.get("name").toString();
//꺼내와서 하나씩 set해주기
//or Dto나 VO로 담아와서 넣어주기
}
</code></pre></div></div>

<ul>
  <li>보안이슈
    <ul>
      <li>CSRF : 사이트간 요청 위조 Cross-Site request forgery
        <ul>
          <li><code class="language-plaintext highlighter-rouge">http.csrf().disable()</code> - 위험</li>
          <li>ex. 악용하는 링크</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>세번 이상 쓰이면 상수 선언하여 사용하기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.out.println("SSAFY" + "I");
System.out.println("SSAFY" + "I LOVE");
System.out.println("SSAFY" + "I LOVE YOU");

////

String aa = "SSAFY";
System.out.println(aa + "I");
System.out.println(aa + "I LOVE");
System.out.println(aa + "I LOVE YOU");

// 최적화 되어있는 것은 아래
// 세번 이상 쓰이면 상수 선언하여 사용하기
// aa라는 메모리에 쓰임
// 위에는 같은 값에도 불구하고 메모리가 세번 쓰임
</code></pre></div></div>

<ul>
  <li>System.out.println 대신 slf4j나 log4j로 테스트하기
    <ul>
      <li>System으로 시작하는게 제일 느려서 시스템 자체가 굉장히 느려지기 때문에 지양하기</li>
    </ul>
  </li>
  <li>객체선언을 하고 또 하는게 문제인 코드</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 전
Snow snow = new Snow.builder().maker(maker)...build();
snow.save(snow);

// 후
repo.save(Snow.builder().maker(maker)…build());
</code></pre></div></div>

<ul>
  <li>builder랑 new로 생성하는 것의 차이점</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Snow snow = new Snow();
snow.setA(a);
snow.setB(b);

// 빌더랑 생성자로 선언하는 것과 차이는 복잡한 객체를 생성할 때, 개발자가 실수하지 않게 하는 역할과 가독성적인 부분에서 쓰는걸로 알고 있습니다.!
// new로 하면 순서도 그대로 해야하는데 혹시 실수하면 문제가 생김
//-&gt; 빌더 지향
</code></pre></div></div>

<ul>
  <li>java8의 stream() 함수는 잘 알고 써야함
    <ul>
      <li>초기값, 중간계산값, 결과값</li>
      <li>맨 마지막은 stream에는 결과에 해당하는 api가 꼭 있어야함
        <ul>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>forEach</td>
                  <td>Collect</td>
                </tr>
              </tbody>
            </table>
          </li>
          <li>결과 없으면 중간값을 lazy함?</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Transactional(readOnly = true)</code></p>

    <ul>
      <li>jpa에서는 find로 시작하는 것만 있는 경우 사용하기
        <ul>
          <li>save나 update가 필요하면 @modify를 써도 됨</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>&lt;?&gt; 와일드카드 사용 지양
    <ul>
      <li>어떤 객체 타입이 들어가는지 제대로 명시해주는 것이 좋음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//전
public ResponseEntity&lt;?&gt; 뭐시기메소드(){}

//후
public ResponseEntity&lt;뭐어시기&gt; 뭐시기메소드(){}
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Daily Contents] 캐싱의 개념과 적용</title><link href="http://localhost:4000/daily%20contents/%EC%BA%90%EC%8B%B1%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A0%81%EC%9A%A9/" rel="alternate" type="text/html" title="[Daily Contents] 캐싱의 개념과 적용" /><published>2022-11-08T00:00:00+09:00</published><updated>2022-11-08T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EC%BA%90%EC%8B%B1%EC%9D%98%20%EA%B0%9C%EB%85%90%EA%B3%BC%20%EC%A0%81%EC%9A%A9</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EC%BA%90%EC%8B%B1%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A0%81%EC%9A%A9/"><![CDATA[<p><br /></p>

<h2 id="고-품질의-ap를-추구한다면">고 품질의 AP를 추구한다면</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 안정성
- 보안
- 처리 속도 / 성능
- 편리한 UX
</code></pre></div></div>

<h2 id="캐시---가까운-곳에서-쉽게-볼-수">캐시 - 가까운 곳에서 쉽게 볼 수…</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 이미지, CSS, 스크립트 등의 정적 리소스가 대상
- 서버의 리소스 변경(write)이 실시간성으로 클라이언트에 반영되지는 못함
- 얻는 게 있으면 잃는 게 생기는 법
</code></pre></div></div>

<h2 id="캐시">캐시</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 데이터나 값을 복사해 놓는 임시 장소
- 복잡한 수식을 재연산하는 시간을 절약하고 싶은 경우
- 접근 시간이 느린 곳의 데이터를 상대적으로 빠른 장소에 보관
- 캐시 영역에 데이터를 저장해 놓으면 계산, 접근 시간을 대폭 줄일 수 있음
</code></pre></div></div>

<h2 id="고전은-중요하다">고전은 중요하다</h2>

<ul>
  <li>입력 » 중앙처리장치(CPU) - 제어장치, 산술연산장치 » 출력</li>
  <li>메모리(Memory Unit) - 프로그램 영역, 데이터 영역</li>
</ul>

<h2 id="캐시---cpu">캐시 - CPU</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IPC가 개선된 새로운 프로세서 아키텍쳐
성능 하이브리드 아키텍쳐
최대 16개(P 코어 8개 + E 코어 8개) 코어, 최대 24개의 스레드
증가한 인텔 스마트 캐시(L2와 L3캐시 공유)
</code></pre></div></div>

<h2 id="응답-지연-값">응답 지연 값</h2>

<ul>
  <li>메모리에서 1MB 순차적으로 읽기 -&gt; 250us</li>
  <li>디스크에서 1MB 순차적으로 읽기 -&gt; 30ms</li>
  <li>한 패킷의 CA로부터 네덜란드까지의 왕복 지연 -&gt; 150ms</li>
</ul>

<h2 id="온라인-갤러리-구현">온라인 갤러리 구현</h2>

<ul>
  <li>디스크에 저장된 10개 이미지 파일을 클라이언트가 요청하면 전송해주는 서버 구현 미션</li>
  <li>이미지 파일의 크기는 1MB 이하</li>
  <li>
    <p>파일 변경은 허용하지 않음</p>
  </li>
  <li>개발자는 자주 변하는 것과 변하지 않는 것을 구분할 수 있어야 한다.</li>
  <li>변하지 않는다면 굳이 반복해서 읽어들일 필요가 있을까?</li>
</ul>

<h2 id="웹-서버---이미지-리소스">웹 서버 - 이미지 리소스</h2>

<ul>
  <li>웹 서버는 빈번한 사용이 예상되고 변경이 거의 없을 거라 예상되는 이미지 리소스를 http 요청마다 새롭게 읽어들일까?</li>
  <li>메모리에 띄워놓고 요청하면 바로 주는 형식</li>
</ul>

<h2 id="생활-캐싱">생활 캐싱</h2>

<ul>
  <li>김싸피가 날씨 정보에 대한 콜센터를 열었다. 김싸피는 날씨 정보를 한 번 기록해 두고 요청이 올 때마다 기록해 둔 날씨 정보를 제공한다.</li>
  <li>결정적인 단점은?</li>
  <li>내가 가지고 있는 정보가 맞는 정보인지 아닌지 확신할 수 없다.</li>
  <li>서버로부터 최초로 기록한 정보가 업데이트 될 경우 새로 받아 재기록 하도록 요청.</li>
</ul>

<h2 id="실시간-지하철-현황-서비스-구현">실시간 지하철 현황 서비스 구현</h2>

<ul>
  <li>특정 지하철역의 0호선의 실시간 열차 현황 정보를 제공</li>
  <li>정보의 출처는 ‘서울 열린 데이터 광장 Open API’</li>
  <li>출퇴근 시간 기준 각 역마다 대략 100건/초의 요청을 가정</li>
  <li>클라이언트 요청마다 Open API 호출 수행되는 구조?</li>
  <li>역 기준의 대략적인 지하철 도착 현황 정보만으로도 고객의 니즈는 충적</li>
  <li>10초 간격으로 WAS 내에 지하철 정보를 임시 저장(캐싱)하도록 구현</li>
</ul>

<h3 id="캐싱에-적합한-대상은">캐싱에 적합한 대상은?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Write가 빈번하고 Read는 거의 없는 경우
2. Read가 빈번하고 Write는 거의 없는 경우(적합!!)
</code></pre></div></div>

<h3 id="바람직한-철학은">바람직한 철학은?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 가능한 많은 데이터를 캐싱하면 성능 향상을 기대할 수 있다
2. 메모리는 매우 중요한 자원, 신중, 선별적 캐싱 정책이 중요(적합!!)
</code></pre></div></div>

<h2 id="캐싱--메모리-io">캐싱 == 메모리 I/O</h2>

<p><strong>Out of Memory</strong> : 정말 이것만큼은 피할 수 있도록 조심 또 조심</p>

<h2 id="ttl">TTL</h2>

<ul>
  <li>보통 캐싱된 데이터에는 만료시간 및 갱신 주기가 존재</li>
  <li>데이터 sync. 는 너무나도 중요</li>
</ul>

<h2 id="캐싱-적용기">캐싱 적용기</h2>

<ul>
  <li>메뉴 목록을 하드코딩하지는 않을 듯</li>
  <li>메뉴 데이터는 DB에 존재한다고 가정</li>
  <li>사용자 요청이 많아질수록 DB 조회 많아짐</li>
</ul>

<h2 id="직접-구현">직접 구현</h2>

<ul>
  <li>메모리에 특정 객체를 생성한 후 캐싱하고자 하는 데이터를 저장</li>
  <li>단 해당 프로세스에서 유일한 저장 장소가 되도록 잘 선언해서 사용(싱글톤 패턴)</li>
  <li>List menuList = new ArrayList();</li>
  <li>menuList = selectMenuListFromDB();</li>
  <li>Cluster를 구현해야 함</li>
</ul>

<h2 id="로컬-캐시---ehcache">로컬 캐시 - Ehcache</h2>

<ul>
  <li>로컬 캐시 라이브러리</li>
  <li>WAS n대 클러스터링 되어있다면 동기화 이슈 발생</li>
  <li>WAS간 내부 통신을 통해 동기화 작업 선행</li>
  <li>Ehcache가 지원하는 RMI 활용한 클러스터링 설정 가능</li>
</ul>

<h2 id="로컬-캐시---단점">로컬 캐시 - 단점</h2>

<ul>
  <li>타겟 AP이 여러 대의 머신으로 실행 중이라면 데이터 동기화 이슈가 발생</li>
  <li>캐시를 활용하려는 프로세스와 동일 머신의 리소스를 사용한다는 점은 매우 큰 단점</li>
</ul>

<h2 id="redis">Redis</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- NoSQL &amp; Cache 솔루션, 메모리 기반으로 구성
- in-memory DB
- 데이터베이스로 사용될 수 있으며 Cache로도 사용될 수 있는 기술
</code></pre></div></div>

<h2 id="캐싱-실전-적용">캐싱 실전 적용</h2>

<ul>
  <li>Cache의 기본적인 개념 파악 및 캐싱에 적합한 데이터 선택</li>
  <li>웹 AP 작성 코드에 상대적으로 느린 I/O(DB 연동) 데이터를 직접 특정 객체에 저장</li>
  <li>로컬 캐시 적용해보기</li>
  <li>In-memory DB 솔루션 Redis 경험해보기</li>
</ul>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Daily Contents] 알아두면 쓸모있는 데이터베이스 객체(기능편3)</title><link href="http://localhost:4000/daily%20contents/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%93%B8%EB%AA%A8%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9D%EC%B2%B4(%EA%B8%B0%EB%8A%A5%ED%8E%B83)/" rel="alternate" type="text/html" title="[Daily Contents] 알아두면 쓸모있는 데이터베이스 객체(기능편3)" /><published>2022-11-04T00:00:00+09:00</published><updated>2022-11-04T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4%20%EC%93%B8%EB%AA%A8%EC%9E%88%EB%8A%94%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B0%9D%EC%B2%B4(%EA%B8%B0%EB%8A%A5%ED%8E%B83)</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%93%B8%EB%AA%A8%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9D%EC%B2%B4(%EA%B8%B0%EB%8A%A5%ED%8E%B83)/"><![CDATA[<p><br /></p>

<h2 id="인덱스">인덱스?</h2>

<ul>
  <li>DataBase 분야에서 Table에 대한 동작 속도를 높여주는 <strong>자료구조</strong></li>
</ul>

<h2 id="인덱스의-종류">인덱스의 종류</h2>

<ul>
  <li>Clustered Index</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cluster : 군집
Clustered : 군집화
Clustered Index : 군집화된 인덱스
</code></pre></div></div>

<ul>
  <li>NonClustered Index</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NonCluster : 비군집
NonClustered : 비군집화
NonClustered Index : 군집화되어 있지 않은 인덱스
</code></pre></div></div>

<h3 id="clustered-index">Clustered Index</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alter table TBL_CODE add primary key(CODE);
</code></pre></div></div>

<ul>
  <li>삽입 삭제를 계속하다 보면 속도가 느려진다.</li>
</ul>

<h3 id="nonclustered-index">NonClustered Index</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>create index col_index on TBL_CODE(CODE, NAME);
</code></pre></div></div>

<ul>
  <li>검색 속도는 느리지만 데이터의 입력/수정/삭제는 더 빠르다.</li>
  <li>별도의 저장공간이 필요.</li>
</ul>

<h2 id="자료구조---b-tree">자료구조 - B Tree</h2>

<ul>
  <li><strong>B- 트리</strong>
    <ul>
      <li>트리 형태로 계산함으로서 연산 횟수 감소</li>
    </ul>
  </li>
</ul>

<h2 id="query-plan">Query Plan</h2>

<ul>
  <li>사용자 » 파서 » 옵티마이저(규칙 기반, 비용 기반) » 실행계획 » SQL, 실행 엔진</li>
</ul>

<h3 id="query-plan---explain">Query Plan - Explain</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXPLAIN
SELECT count(*) FROM TBL_BOARED2
WHERE 1=1
AND USER_SEQ = '113'
</code></pre></div></div>

<h3 id="query-plan---index">Query Plan - Index</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT count(*) FROM TBL_BOARD2
WHERE 1=1
  AND USER_SEQ = '113'
;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT count(*) FROM TBL_Board3
WHERE 1=1
  AND USER_SeQ = '113'
;
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Daily Contents] 코드 리팩토링</title><link href="http://localhost:4000/daily%20contents/%EC%BD%94%EB%93%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/" rel="alternate" type="text/html" title="[Daily Contents] 코드 리팩토링" /><published>2022-11-02T00:00:00+09:00</published><updated>2022-11-02T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EC%BD%94%EB%93%9C%20%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EC%BD%94%EB%93%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/"><![CDATA[<p><br /></p>

<h2 id="학습-목표">학습 목표</h2>

<ul>
  <li>코드 리팩토링이란?</li>
  <li>언제 해야 할까?</li>
  <li>어떻게 해야 할까?</li>
  <li>필요한 이유</li>
</ul>

<h2 id="코드-리팩토링이란">코드 리팩토링이란?</h2>

<ul>
  <li>소프트웨어의 <strong>겉보기 동작은 그대로 유지한 채…</strong></li>
  <li>코드를 깨끗하고 이해하기 쉽게 <strong>구조만 변경</strong>하는 것</li>
  <li>핵심은 “이 코드를 더 좋게 만들 수 있습니까?”에 있으며…
    <ul>
      <li>이에 대한 판단 기준으로는 <strong>확장성, 가독성, 유지보수성</strong></li>
    </ul>
  </li>
</ul>

<h2 id="언제-해야-할까">언제 해야 할까?</h2>

<ul>
  <li>기능 구현이 우선이고, 정상작동되는지 확인한 후에 진행한다.</li>
  <li>한 번에 <strong>하나의 작업</strong>에만 집중하고 동시에 진행하지 않는다.
    <ul>
      <li>기능추가 단계 : 기존 코드는 건드리지 말고, <strong>신규 기능 추가</strong>에만 집중</li>
      <li>리팩토링 단계 : 기능을 추가하지 말 것, 좋은 설계로 <strong>코드를 재구성</strong></li>
    </ul>
  </li>
</ul>

<h2 id="어떻게-해야-할까">어떻게 해야 할까?</h2>

<ul>
  <li>개발 프로세스에서는 리팩토링할 <strong>시점을 결정</strong>하는 게 매우 중요하며…</li>
  <li>시점을 정하는 가장 좋은 방법은 <strong>범위를 정하는 것</strong></li>
  <li><strong>한 번에 한 가지</strong> 명확하고 구체적인 목표를 갖고 진행하는 것이 중요</li>
</ul>

<h2 id="코드-리팩토링의-유형">코드 리팩토링의 유형</h2>

<ul>
  <li>신규 기능 추가를 대비한 <strong>“준비를 위한 리팩토링”</strong></li>
  <li>높은 가독성을 고려한 <strong>“이해를 위한 리팩토링”</strong></li>
</ul>

<h3 id="준비를-위한-리팩토링">준비를 위한 리팩토링</h3>

<ul>
  <li>목적 : 신규 기능을 추가하기 전에, 코드를 <strong>쉽게 추가</strong>할 수 있도록 대비
    <ul>
      <li>현재 구조를 살펴보고, 추가되는 코드가 기존 구조에 녹여지기 어렵다면… 해당 구조를 다듬어서 새로운 기능을 쉽게 적용 가능할 수 있도록 만들어주자</li>
      <li>Good Fit? »Yes» Add New Feature</li>
      <li>Good Fit? »No» Refactoring to Good Fit » Add New Feature</li>
    </ul>
  </li>
</ul>

<h3 id="예제1-파편화된-코드">예제1) 파편화된 코드</h3>

<ul>
  <li>동일 코드가 반복적으로 작성되어 있다면…</li>
  <li><strong>별도의 Function</strong>으로 만들고, 이를 호출하는 방식으로 관심사를 분리</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function printOwing(invoice) {
  printBanner();
  let outstanding = calculateOutstanding();

  // print details
  console.log(`name: ${invoice.customer}`);
  console.log(`amount: ${outstanding}`);
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function printOwing(invoice) {
  printBanner();
  let outstanding = calculateOutstanding();
  printDetails(outstanding);

  function printDetails(outstanding) {
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
  }
}
</code></pre></div></div>

<h3 id="예제2-중복된-유사-로직">예제2) 중복된 유사 로직</h3>

<ul>
  <li>의미가 유사한 function이 2개 이상 존재하면…</li>
  <li><strong>매개변수를 이용</strong>하는 것으로 function을 통합</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function tenPercentRaise(aPerson) {
  aPerson, salary = aPerson.salary.multiply(1.1);
}
function fivePercentRaise(aPerson) {
  aPerson, salary = aPerson.salary.multiply(1.05);
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function raise(aPerson, factor) {
  aPerson, salary = aPerson.salary.multiply(1 + factor);
}
</code></pre></div></div>

<h3 id="예제3-모든-분기마다-동일-로직">예제3) 모든 분기마다 동일 로직</h3>

<ul>
  <li>조건부 모든 분기에 동일 로직을 구현했다면…</li>
  <li>분기 밖으로 <strong>해당 로직을 이동</strong>시켜서, 한 번만 작성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(isSepcialDeal()) {
  total = price * 0.95;
  send();
}
else {
  total = price * 0.98;
  send();
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(isSepcialDeal()) {
  total = price * 0.95;
}
else {
  total = price * 0.98;
}
send();
</code></pre></div></div>

<h2 id="이해를-위한-리팩토링">이해를 위한 리팩토링</h2>

<ul>
  <li>목적 : 코드의 의도를 이해할 수 있도록 <strong>가독성</strong>을 높인다.
    <ul>
      <li>코드를 수정하기 위한 전제조건은 <strong>그 코드가 무슨 일을 하는지 파악</strong>하는 것</li>
      <li>협업하는 동료와 함께 보는 코드는 의도가 명확하게 드러나야 함</li>
      <li>더 좋은 설계를 위해서는 <strong>사소한 것부터 명확하게</strong> 만드는 것이 중요</li>
    </ul>
  </li>
</ul>

<h3 id="예제1-모호한-변수명">예제1) 모호한 변수명</h3>

<ul>
  <li>a, b, c 등의 의도를 알 수 없는 모호한 변수명이라면…</li>
  <li>변수명을 <strong>직관적</strong>으로 선언</li>
  <li>좋은 프로그래머는 <strong>사람이 이해</strong>할 수 있는 코드를 작성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = height * width;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let area = height * width;
</code></pre></div></div>

<h3 id="예제2-길어지는-표현식">예제2) 길어지는 표현식</h3>

<ul>
  <li>하나의 표현식이 너무 길어지는 경우에는…</li>
  <li>표현식 또는 해당 부분의 결과를 <strong>의도 파악이 가능한 개별 변수</strong>로 선언</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return order.quantity * order.itemPrice -
  Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 * Math.min(order.quantity * order.itemPrice * 0.1, 100);
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const basePrice = order.quantity * order.itemPrice;
const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;
const shipping = Math.min(basePrice * 0.1, 100);
return basePrice - quantityDiscount * shipping;
</code></pre></div></div>

<h3 id="예제3-변수가-한-번만-변경">예제3) 변수가 한 번만 변경</h3>

<ul>
  <li>변경되는 변수가 하나뿐이라면…</li>
  <li>해당변수가 원래 표현식과 다를 바 없을 때는, 변수 선언 대신 <strong>인라인해서 리턴값</strong>으로 처리</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let basePrice = anOrder.basePrice;
return (basePrice &gt; 1000);
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return anOrder.basePrice &gt; 1000;
</code></pre></div></div>

<h2 id="비효율적인-때는">비효율적인 때는?</h2>

<ul>
  <li>코드 판독 자체가 불가하여 오히려 <strong>시간 낭비</strong>인 경우</li>
  <li>코드가 정상 작동하지 않는다면, <strong>새로 짜는 것이 낫다</strong></li>
  <li>납기가 임박했을 때는 지양</li>
</ul>

<h2 id="성능개선-vs-리팩토링">성능개선 vs 리팩토링</h2>

<ul>
  <li>성능을 높이는 작업도, 리팩토링의 작업 패턴은 유사</li>
  <li>그러나 성능 개선은 속도를 높이기 위한 목적이고…</li>
  <li>코드 리팩토링은 <strong>코드를 깨끗하게</strong> 만들기 위함</li>
</ul>

<h2 id="왜-필요해요">왜 필요해요?</h2>

<ul>
  <li>코드 리팩토링을 왜 해야 하나요?</li>
  <li>시간 낭비하는 거 아닌가요?</li>
  <li><strong>“깨끗하고 좋은 코드를 만들기 위해서”</strong></li>
  <li>설계에 대한 고민없이 작성된 코드는 <strong>초반에는 개발속도가 빠르지만…</strong></li>
  <li>코드 구조는 한 번 엉망이 되면, 시간이 갈수록 <strong>더 엉망진창</strong>이 되고…</li>
  <li><strong>새로운 기능을 추가</strong>할수록, 개발 속도가 점점 뎌뎌진다.</li>
  <li>반면, 좋은 설계의 프로그램은 <strong>시간이 갈수록 개발 생산성이 높아진다</strong></li>
</ul>

<h2 id="궁극적-목적">궁극적 목적</h2>

<ul>
  <li>Enconomics(경제성)</li>
  <li>적은 인력으로 짧은 시간에 많은 기능을 개발하기 위해…</li>
</ul>

<h2 id="퀴즈">퀴즈</h2>

<ul>
  <li>좋은 코드의 판단 기준은 대표적으로 유지보수성, 확장성, 가독성이 있습니다.</li>
  <li>코드 리팩토링을 하기에 적절한 시점은? 기능 개발이 완료된 후</li>
  <li>코드 리팩토링의 대표적 유형 두 가지는? 준비, 이해</li>
  <li>코드 리팩토링의 궁극적 목적은? Economics(경제성)</li>
</ul>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Daily Contents] OS 커널과 DB 모델</title><link href="http://localhost:4000/daily%20contents/OS-%EC%BB%A4%EB%84%90%EA%B3%BC-DB-%EB%AA%A8%EB%8D%B8/" rel="alternate" type="text/html" title="[Daily Contents] OS 커널과 DB 모델" /><published>2022-11-01T00:00:00+09:00</published><updated>2022-11-01T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/OS%20%EC%BB%A4%EB%84%90%EA%B3%BC%20DB%20%EB%AA%A8%EB%8D%B8</id><content type="html" xml:base="http://localhost:4000/daily%20contents/OS-%EC%BB%A4%EB%84%90%EA%B3%BC-DB-%EB%AA%A8%EB%8D%B8/"><![CDATA[<p><br /></p>

<h2 id="세상-모든-os와-db">세상 모든 OS와 DB</h2>

<ul>
  <li>어플리케이션을 구성하는데는 그에 따르는 인프라 필요. 요소에는 어떤 것이 있고 필수적인 OS와 DB의 구성에 대해서 알아보자.</li>
</ul>

<h2 id="learning-goals">Learning Goals</h2>

<ol>
  <li>인프라에 필요한 구성 요소와 자원들의 형태를 알 수 있다.</li>
  <li>현존하는 OS의 커널의 종류와 특징을 알 수 있다.</li>
  <li>데이터를 저장하는 방식의 종류와, 그에 대표적인 DB 제품들의 특징들을 알 수 있다.</li>
</ol>

<h2 id="os">OS?!</h2>

<ul>
  <li><strong>Operation System</strong> : 시스템 소프트웨어 관리 컴퓨터 하드웨어, 소프트웨어 자원을 공통 제공 서비스를 위한 컴퓨터 프로그램.</li>
  <li>하드웨어와 어플리케이션을 <strong>중재</strong>하는 역할</li>
</ul>

<h2 id="type-of-os-kernel">Type of OS Kernel</h2>

<p>OS 커널</p>

<ul>
  <li>Monolithic kernel(모놀리식 커널)
    <ul>
      <li>UNIX, LINUX, MS-DOS, Windows 9x 계열(95, 98, me)</li>
    </ul>
  </li>
  <li>Micro kernel(마이크로 커널)
    <ul>
      <li>Minix</li>
    </ul>
  </li>
  <li>Hybrid kernel(하이브리드 커널)
    <ul>
      <li>Windows NT 계열, MacOS X 이후 버전</li>
    </ul>
  </li>
</ul>

<h2 id="monolithic-kernel단일형-커널">Monolithic kernel(단일형 커널)</h2>

<p>IO 입출력 기능, 디바이스 장치 지원 등의 운영체제에서 일어나는 모든 일을 한 개의 커널과 동일한 메모리 공간에 적재하여 커리하는 기법</p>

<ul>
  <li>각 기능간의 커뮤니케이션이 좋고, 시스템 호출에 의한 서비스가 빠름.</li>
  <li>새로운 디바이스 추가나 기능 변경 시는 어려우며, 어느 한 기능에 불량이 생기면 전체를 새로 빌드해야 하는 단점 등이 있음.</li>
</ul>

<h3 id="unix">UNIX</h3>

<ul>
  <li>HP_UX, ORACLE(SOLARIS), IBM_AIX, FreeBSD, MAC OS X</li>
</ul>

<h3 id="linux-distro-unix-like">Linux Distro (Unix-like)</h3>

<ul>
  <li>debian, ubuntu, Linux Mint</li>
  <li>Red Hat, CentOS, fedora</li>
  <li>slackware, SUSE</li>
</ul>

<h2 id="micro-kernel마이크로-커널">Micro kernel(마이크로 커널)</h2>

<p>모놀리지 커널과 반대되는 디자인. 커널에는 핵심적인 디자인, 기본 프로세스 통신 등만을 포함하고 그 외의 것들은 외부 모듈화를 하여 커널의 사이즈가 작아지고, 임베디드 시스템이나 포터블한 디바이스에 사용이 유리</p>

<ul>
  <li>리얼타임성 시스템에 강함</li>
  <li>통신은 메세지 전달을 통해서만 발생하기 때문에 전반적인 퍼포먼스는 저하</li>
</ul>

<h2 id="hybrid-kernel하이브리드-커널">Hybrid kernel(하이브리드 커널)</h2>

<p>IPC는 커널에 두고 파일시스템은 유저모드에 디자인</p>

<h2 id="database">DATABASE?!</h2>

<ul>
  <li>여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리하는 데이터의 집합</li>
  <li>의미 있게 구조화하여 저장된 정보</li>
</ul>

<h2 id="type-of-db-model">Type of DB model</h2>

<p>DB 모델</p>

<ul>
  <li>Relational</li>
  <li>NoSQL
    <ul>
      <li>Document Store</li>
      <li>Key-Value Store</li>
      <li>Wide Column Store</li>
      <li>Graph Database</li>
    </ul>
  </li>
  <li>NewSQL</li>
</ul>

<h2 id="relational-database">Relational Database</h2>

<ul>
  <li>Atomicity, Consistency, Isolation, Durability</li>
  <li>Normalization - 1NF, 2NF, 3NF</li>
  <li>Scalability (Scale-up, not scale out)</li>
  <li>ANSI SQL 문법, JOIN 기능</li>
</ul>

<h2 id="type-of-nosql-model">Type of NoSQL model</h2>

<ul>
  <li>주로 비정형화된 데이터를 저장하기 위한 것으로 특정 스키마가 없음.</li>
  <li>어플리케이션의 도움 없이 여러 서버 간의 데이터를 자동으로 분할하고 시스템 메모리에 데이터를 캐시하여 처리량을 높이고 성능 향상.</li>
  <li>간단한 데이터 모델과 쿼리로 높은 확장성 제공.</li>
  <li>
    <p>단 일관성보다 가용성을 선호하기 때문에 표준화가 부족하고 데이터 노드 간의 동기화가 되지 않아 시스템 장애의 위험이 있어 은행권 등에서는 쓰이지 않음.</p>
  </li>
  <li>Auto Balancing</li>
  <li>Integrated Caching</li>
  <li>Lack of schema</li>
  <li>NoSQL
    <ul>
      <li>Document Store</li>
      <li>Key-Value Store</li>
      <li>Wide Column Store</li>
      <li>Graph Database</li>
    </ul>
  </li>
</ul>

<h3 id="document-type-database">Document Type Database</h3>

<ul>
  <li>XML이나 JSON을 이용하여 데이터 저장. 스키마가 유동적이어서 레코드가 각각 다른 스키마를 가질 수 있음.
    <ul>
      <li>MongoDB, Couchbase</li>
    </ul>
  </li>
</ul>

<h3 id="key-value-type-database">Key-Value Type Database</h3>

<ul>
  <li>하나의 키에 하나의 값을 갖는 형태, 여러 개의 필드를 가질 수도 있음.</li>
  <li>값을 영구히 저장하지는 않으나 휘발성을 이용하여 상태 표현이 필요한 곳에서 사용.
    <ul>
      <li>Redis, Memcached</li>
    </ul>
  </li>
</ul>

<h3 id="wide-column-type-database">Wide Column Type Database</h3>

<ul>
  <li>모든 데이터는 로우별로 저장이 되고, 주어진 로우와 컬럼이 함께 저장.</li>
  <li>대규모 확장성을 위해 사용. 수집할 수 있는 엄청난 데이터량을 다루는데 적합.
    <ul>
      <li>cassandra, HBASE</li>
    </ul>
  </li>
</ul>

<h3 id="graph-database">Graph Database</h3>

<ul>
  <li>데이터를 노드로 표현. 쿼리 관계는 데이터베이스에 영구적으로 저장하기 때문에 빠름.</li>
  <li>퍼포먼스가 좋고 유지보수에 용이한 것이 특징.
    <ul>
      <li>neo4j</li>
    </ul>
  </li>
</ul>

<h2 id="newsql">NewSQL</h2>

<ul>
  <li>RDB와 NoSQl의 장점을 합친 것. SQL 문법과 트랙잭션 지원. NoSQL처럼 스케일 아웃 지원. 분산 저장 형태의 DB 가능. 수평 분할 가능. 다른 트랜잭션에 영향을 미치지 않음으로서 빠른 성능.
    <ul>
      <li>Partitioning/Sharding</li>
      <li>Concurrency Control</li>
      <li>Replication</li>
      <li>Crash Recovery</li>
      <li>NUODB, Cockroach DB</li>
    </ul>
  </li>
</ul>

<h2 id="db-사이트">DB 사이트</h2>

<p>https://db-engines.com/en/ranking</p>

<h2 id="summary--quiz">SUMMARY &amp; QUIZ</h2>

<ol>
  <li>OS 커널의 종류에는 모놀리식 커널, 마이크로 커널, 하이브리드 커널이 있다.</li>
  <li>이것은 OS 중 한 종류로 데니스 리치가 개발하여 현존 OS의 전신이 되고 있는 이 OS의 이름은 유닉스다.</li>
  <li>DB에서 NoSQL 종류에는 Document 모델 타입, Key-Value 모델 타입, Wide Column 모델 타입, Graph 모델 타입이 있다.</li>
  <li>이 DB는 메모리 위에서 실행되는 Key-Value 타입의 DBMS로 가장 대표적으로 SDK가 제공되는 레디스가 있다.</li>
  <li>0.1 + 0.2 = 0.3000000004 (부동소수점)</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. NewSQL의 장점이 굉장히 많아보이는데, 대표적인 단점은?
A. 아직 정식화가 되어있지 않음. 전문으로 하는 회사도 많이 없기에 제품도 많이 없음.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 실시간 통계 보여줘야 하는데 어떤 DB가 가장 좋을지.
A. 저장한다면 RDB, 저장하지 않는다면 REDIS가 좋음.
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Daily Contents] 알아두면 쓸모있는 데이터베이스 객체(기능편2)</title><link href="http://localhost:4000/daily%20contents/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%93%B8%EB%AA%A8-%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9D%EC%B2%B4(%EA%B8%B0%EB%8A%A5%ED%8E%B82)/" rel="alternate" type="text/html" title="[Daily Contents] 알아두면 쓸모있는 데이터베이스 객체(기능편2)" /><published>2022-10-28T00:00:00+09:00</published><updated>2022-10-28T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4%20%EC%93%B8%EB%AA%A8%20%EC%9E%88%EB%8A%94%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B0%9D%EC%B2%B4(%EA%B8%B0%EB%8A%A5%ED%8E%B82)</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%93%B8%EB%AA%A8-%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9D%EC%B2%B4(%EA%B8%B0%EB%8A%A5%ED%8E%B82)/"><![CDATA[<p><br /></p>

<h2 id="6-stored-procedure">6. (Stored) Procedure</h2>

<ul>
  <li>하나의 요청으로 여러 SQL문을 실행(가능)</li>
  <li>네트워크 소요시간을 줄일 수 있음</li>
  <li>리턴값 없을 수도 있음</li>
  <li>리턴값 여러 개 반환 가능</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE PROCEDURE '프로시저명' (
  파라미터
)
BEGIN
  수행할 쿼리
END
</code></pre></div></div>

<h2 id="7-user--권한">7. User / 권한</h2>

<ul>
  <li>MYSQL의 사용자</li>
  <li>grant 명령어를 통해 권한 부여</li>
  <li>revoke 명령어를 사용해 권한을 제거</li>
  <li>FLUSH PRIVILEGES; 을 통해 권한 반영</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE USER {username}@{ip} identified by 'password';
DROP USER {username}@{ip};
grant {권한} privileges on {스키마}.{테이블} to {username}@{ip};
revoke {권한} privileges on {스키마}.{테이블} to {username}@{ip};
</code></pre></div></div>

<h2 id="8-trigger">8. Trigger</h2>

<ul>
  <li>어떤 상황이 발생했을 때 미리 정해진 Action이 자동으로 실행.</li>
  <li>특정 테이블에 INSERT, UPDATE, DELETE문이 수행될 때 자동으로 동작.</li>
  <li>변경 전 또는 변경 후의 행을 OLD, NEW 라는 가상 변수를 사용하여 읽음.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>이벤트</th>
      <th>OLD</th>
      <th>NEW</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>delete</td>
      <td>O</td>
      <td>X</td>
    </tr>
    <tr>
      <td>insert</td>
      <td>X</td>
      <td>O</td>
    </tr>
    <tr>
      <td>update</td>
      <td>O</td>
      <td>O</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>사용 가능 O 사용 불가능 X</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TRIGGER '트리거명' AFTER UPDATE ON '테이블명'
FOR EACH ROW
BEGIN

END
</code></pre></div></div>

<h2 id="tmi---분기문">TMI - 분기문</h2>

<ul>
  <li>필요에 따라 일반적인 쿼리문 내에서 분기문을 활용할 수 있음</li>
  <li>SELECT절 뿐 아니라 WHERE절에서도 분기문 사용 가능</li>
</ul>

<h2 id="-cursor">* CURSOR</h2>

<ul>
  <li>테이블에서 한 행씩 처리하기 위한 방식</li>
  <li>CURSOR, LOOP, FETCH 등의 구문을 사용</li>
  <li>성능상 좋지 못해 권장하지 않으며, 실시간 데이터 처리는 매우 위험</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DECLARE &gt;&gt; OPEN &gt;&gt; FETCH &gt;&gt;(&lt;&lt;no&lt;&lt;)&gt;&gt; EMPTY &gt;&gt;yes&gt;&gt; CLOSE
</code></pre></div></div>

<h2 id="qa">Q&amp;A</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 로그를 남기면 어떻게 유용하게 사용할 수 있는지 궁금함.
A. 현재 유저들이 얼마나 많은 인원이 등록, 삭제, 수정 등을 하는지 확인할 수 있는 용도 등.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 객체들을 많이 사용하게 될 때 부작용은 있을지?
A. 성능을 무시하고 개발 기능만을 위해 만든 것. 이렇게 만들었는데 테이블 구조를 변경할 경우 필요한 데이터를 찾을 때 일일히 찾아봐야 하는 부작용이 발생함.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 커서는 프로시저에서만 사용할 수 있는 것인가.
A. Function 내에서는 INSERT, DELETE만 사용할 수 있으므로 일반적으로는 커서는 프로시저에서만 사용할 수 있음.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. JPA 같은 ORM을 이용해서는 사용할 수 없고 SQL에서 직접 해야 하는 것인지.
A. JPA에서는 객체화되어있기 때문에 사용할 수 없음. 하지만 필요하다면 쿼리를 날릴 수는 있음
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. DB 객체를 사용하는 것과 코드로 같은 작업을 처리할 때를 비교해서 서로 장단점은 무엇이 있을지.
A. DB를 왔다갔다 하는 작업을 줄일 수 있음.
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry></feed>