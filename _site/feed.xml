<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-01T17:11:18+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">경호의 블로그</title><subtitle>느리지만 천천히 성장하는 블로그입니다.</subtitle><author><name>김경호</name></author><entry><title type="html">[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (값 타입)]</title><link href="http://localhost:4000/jpa/JPA_Basic-4/" rel="alternate" type="text/html" title="[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (값 타입)]" /><published>2022-06-28T00:00:00+09:00</published><updated>2022-06-28T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA_Basic%204</id><content type="html" xml:base="http://localhost:4000/jpa/JPA_Basic-4/"><![CDATA[<p><br /></p>

<h2 id="값-타입">값 타입</h2>

<h3 id="1-기본값-타입">1. 기본값 타입</h3>

<blockquote>
  <ul>
    <li><strong>JPA의 데이터 타입 분류</strong>
      <ul>
        <li><strong>엔티티 타입</strong>
          <ul>
            <li>@Entity로 정의하는 객체</li>
            <li>데이터가 변해도 식별자로 지속해서 추적 가능</li>
            <li>예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능</li>
          </ul>
        </li>
        <li><strong>값 타입</strong>
          <ul>
            <li>int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체</li>
            <li>식별자가 없고 값만 있으므로 변경시 추적 불가</li>
            <li>예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입 분류</strong>
      <ul>
        <li><strong>기본값 타입</strong>
          <ul>
            <li>자바 기본 타입(int, double)</li>
            <li>래퍼 클래스(Integer, Long)</li>
            <li>String</li>
          </ul>
        </li>
        <li><strong>임베디드 타입</strong>(embedded type, 복합 값 타입)</li>
        <li><strong>컬렉션 값 타입</strong>(collection value type)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>기본값 타입</strong>
      <ul>
        <li>예 : String name, int age</li>
        <li>생명 주기를 엔티티에 의존
          <ul>
            <li>예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제</li>
          </ul>
        </li>
        <li>값 타입은 공유하면 안됨
          <ul>
            <li>예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>참고</strong> : 자바의 기본 타입은 절대 공유되지 않는다.
      <ul>
        <li>int, double 같은 기본 타입(primitive type)은 절대 공유되지 않음</li>
        <li>기본 타입은 항상 값을 복사함</li>
        <li>Integer 같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경 자체가 불가능</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>

    <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
    <span class="c1">//기본 타입 공유 테스트</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a = "</span> <span class="o">+</span> <span class="n">a</span><span class="o">);</span> <span class="c1">// a = 10</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b = "</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span> <span class="c1">// b = 20</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-임베디드-타입">2. 임베디드 타입</h3>

<blockquote>
  <ul>
    <li><strong>임베디드 타입(복합 값 타입)</strong>
      <ul>
        <li>새로운 값 타입을 직접 정의할 수 있음</li>
        <li>JPA는 임베디드 타입(embedded type)이라 함</li>
        <li>주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함</li>
        <li>int, String과 같은 값 타입 (<strong>엔티티 아님</strong>)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>예제</strong>
      <ul>
        <li>회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다. =&gt; 너무 번잡하다.
<br /> <img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%ED%83%80%EC%9E%85%20%EB%B3%B5%EC%9E%A1.png" alt="TEXT" title="임베디드 타입 복잡" width="20%" height="30%" /></li>
        <li>회원 엔티티는 이름, 근무 기간, 집 주소를 가진다. =&gt; 이런식으로 묶어낼 수 있는게 임베디드 타입이다.
<br /> <img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%ED%83%80%EC%9E%851.png" alt="TEXT" title="임베디드 타입1" width="45%" height="60%" />
<img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%ED%83%80%EC%9E%852.png" alt="TEXT" title="임베디드 타입2" width="45%" height="60%" /></li>
        <li>쉽게 말해서 Period, Address 클래스를 새로 만들었다고 생각하면 된다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>임베디드 타입 사용법</strong>
      <ul>
        <li>@Embeddable : 값 타입을 정의하는 곳에 표시</li>
        <li>@Embedded : 값 타입을 사용하는 곳에 표시 (둘 중 하나만 넣고 생략 가능)</li>
        <li><strong>기본 생성자 필수</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>임베디드 타입의 장점</strong>
      <ul>
        <li>재사용</li>
        <li>높은 응집도</li>
        <li>Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음</li>
        <li>임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>임베디드 타입과 테이블 매핑</strong>
      <ul>
        <li>DB 입장에서는 값타입을 쓰든 안 쓰든, 임베디드 타입을 쓰든 안 쓰든 회원 테이블은 똑같다. 매핑만 해주면 된다.
<br /> <img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%20%ED%85%8C%EC%9D%B4%EB%B8%94%20%EB%A7%A4%ED%95%91.png" alt="TEXT" title="임베 테이블 매핑" width="45%" height="60%" /></li>
        <li>임베디드 타입은 엔티티의 <strong>값일 뿐</strong>이다.</li>
        <li>임베디드 타입을 사용하기 전과 후에 <strong>매핑하는 테이블은 같다.</strong></li>
        <li>객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능</li>
        <li>잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Period</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">startDate</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">endDate</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Address</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Address</span><span class="o">(</span><span class="nc">String</span> <span class="n">city</span><span class="o">,</span> <span class="nc">String</span> <span class="n">street</span><span class="o">,</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">city</span> <span class="o">=</span> <span class="n">city</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">street</span> <span class="o">=</span> <span class="n">street</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">zipcode</span> <span class="o">=</span> <span class="n">zipcode</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"USERNAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="c1">//기간 Period</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Period</span> <span class="n">workPeriod</span><span class="o">;</span>

    <span class="c1">//주소</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">homeAddress</span>
<span class="o">}</span>

<span class="nc">JpaMain의</span> <span class="k">try</span> <span class="n">내부</span>
<span class="k">try</span><span class="o">{</span>
    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setHomeAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span><span class="s">"street"</span><span class="o">,</span><span class="s">"10000"</span><span class="o">));</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setWorkPeriod</span><span class="o">(</span><span class="k">new</span> <span class="nc">Period</span><span class="o">());</span>

    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>임베디드 타입과 연관관계</strong></li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%20%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84.png" alt="TEXT" title="임베 연관관계" width="45%" height="60%" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ZIPCODE"</span><span class="o">)</span> <span class="c1">//이름 설정도 가능</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span> <span class="c1">//임베디드 안에 엔티티도 들어올 수 있다.</span>

    <span class="kd">public</span> <span class="nf">Address</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Address</span><span class="o">(</span><span class="nc">String</span> <span class="n">city</span><span class="o">,</span> <span class="nc">String</span> <span class="n">street</span><span class="o">,</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">city</span> <span class="o">=</span> <span class="n">city</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">street</span> <span class="o">=</span> <span class="n">street</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">zipcode</span> <span class="o">=</span> <span class="n">zipcode</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>@AttributeOverride : 속성 재정의</strong>
      <ul>
        <li>한 엔티티에서 같은 값 타입을 사용하면?</li>
        <li>컬럼 명이 중복됨</li>
        <li>@AttributeOverrides, @AttributeOverride 를 사용해서 컬럼 명 속성을 재정의</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"USERNAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="c1">//기간 Period</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Period</span> <span class="n">workPeriod</span><span class="o">;</span>

    <span class="c1">//주소</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">homeAddress</span><span class="o">;</span>

    <span class="c1">//주소</span>
 <span class="c1">//   @Embedded</span>
 <span class="c1">//   private Address homeAddress; // 중복 때문에 에러가 난다.</span>

    <span class="nd">@Embedded</span>
    <span class="nd">@AttributeOverrides</span><span class="o">({</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"city"</span><span class="o">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"WORK_CITY"</span><span class="o">)),</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"street"</span><span class="o">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"WORK_STREET"</span><span class="o">)),</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"zipcode"</span><span class="o">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"WORK_ZIPCODE"</span><span class="o">))</span>
    <span class="o">})</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">workaddress</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>임베디드 타입과 null</strong>
      <ul>
        <li>임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="mappedsuperclass-vs-embeddable">@MappedSuperclass vs @Embeddable</h4>

<blockquote>
  <ul>
    <li><strong>@MappedSuperclass</strong>
      <ul>
        <li><strong>Entity</strong>로 정의하는 것이고 <strong>여러 Entity에 공통적으로</strong> 적용해야 할 때 사용할 수 있다.</li>
        <li><strong>상속</strong>이다.</li>
        <li><strong>상속</strong>은 <strong>다중상속도 안되고</strong> 객체지향 설계상 <strong>유연성</strong>이 떨어진다.</li>
      </ul>
    </li>
    <li><strong>@Embeddable</strong> + <strong>@Embedded</strong>
      <ul>
        <li><strong>Value</strong> 타입으로 정의하는 것이고 <strong>비슷한 속성</strong>을 가지는 애트리뷰트를 하나의 값으로 만들어 <strong>재사용성</strong>을 높일수 있는 방법이다.</li>
        <li><strong>위임</strong>이다.</li>
        <li><strong>JPQL</strong>을 사용할 때에는 엔티티에서 embedded type까지 쿼리하기 위해서 type을 명시해야 하는 불편함이 존재한다.
          <ul>
            <li>예) <strong>위임 사용</strong>: select u from User u where u.timestamped.createdDate &gt; ?</li>
            <li>예) <strong>상속 사용</strong> : select u from User u where u.createdDate &gt; ?</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>대부분의 상황에서는 <strong>embedded type</strong>을 사용하는 것이 좋겠지만 <strong>단순한 데이터를 다룰 때</strong>에는 단순한 방식(<strong>@MappedSuperclass</strong>)을 선택하여 처리하는 것이 더 나은 경우도 있다.</li>
    <li><strong>@MappedSuperclass</strong>를 사용하는 경우
      <ul>
        <li>수정시간, 등록시간, 수정자, 등록자 처럼 <strong>대부분의 엔티티들이 공통으로 사용하는 속성</strong>들을 다룰때 사용한다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><a href="https://lob-dev.tistory.com/entry/Base-Column를-사용할-때-MappedSuperclass-와-embedded-Type-중-무엇을-사용해야-할까">참고1</a> <br />
<a href="https://www.inflearn.com/questions/18578">참고2</a></p>

<h3 id="3-값-타입과-불변-객체">3. 값 타입과 불변 객체</h3>

<blockquote>
  <ul>
    <li>값 타입은 복잡한 객체 세상은 조금이라도 <strong>단순화</strong>하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입 공유 참조</strong>
      <ul>
        <li>임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함</li>
        <li>부작용(side effect) 발생</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%EA%B0%92%ED%83%80%EC%9E%85%20%EB%B6%80%EC%9E%91%EC%9A%A9.png" alt="TEXT" title="값 타입 부작용" /></p>

<blockquote>
  <ul>
    <li>회원 1과 회원 2가 같은 주소를 볼 경우, city를 NewCity로 바꾸면 회원1과 회원2도 같이 NewCity로 바뀐다</li>
    <li>의도적으로 쓰려면 값 타입을 쓰면 안되고 엔티티를 써야한다.</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="o">{</span>
      <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>

      <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
      <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
      <span class="n">member</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
      <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

      <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
      <span class="n">member2</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member2"</span><span class="o">);</span>
      <span class="n">member2</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
      <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

      <span class="n">member</span><span class="o">.</span><span class="na">getAddress</span><span class="o">().</span><span class="na">setCity</span><span class="o">(</span><span class="s">"newCity"</span><span class="o">);</span> <span class="c1">//member만 바뀌는게 아니라 member2까지 같이 바뀐다. (이런 버그는 잡아내기 어렵다.)</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>값 타입 복사</strong>
      <ul>
        <li>값 타입의 실제 인스턴스인 값을 <strong>공유하는 것은 위험</strong></li>
        <li>대신 값(인스턴스)를 <strong>복사해서 사용</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%EA%B0%92%ED%83%80%EC%9E%85%20%EB%B3%B5%EC%82%AC.png" alt="TEXT" title="값 타입 복사" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>

            <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>

            <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
            <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

            <span class="nc">Address</span> <span class="n">copyAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="n">address</span><span class="o">.</span><span class="na">getCity</span><span class="o">(),</span> <span class="n">address</span><span class="o">.</span><span class="na">getStreet</span><span class="o">(),</span> <span class="n">address</span><span class="o">.</span><span class="na">getZipcode</span><span class="o">());</span> <span class="c1">//copy</span>
            <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
            <span class="n">member2</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member2"</span><span class="o">);</span>
            <span class="n">member2</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">copyAddress</span><span class="o">);</span>
            <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

            <span class="n">member</span><span class="o">.</span><span class="na">getAddress</span><span class="o">().</span><span class="na">setCity</span><span class="o">(</span><span class="s">"newCity"</span><span class="o">);</span> <span class="c1">//member2는 copyAddress로 저장했기 때문에 member2는 안바뀌고 member만 바뀐다.</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>객체 타입의 한계</strong>
      <ul>
        <li>항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.</li>
        <li>문제는 임베디드 타입처럼 <strong>직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입</strong>이다.</li>
        <li>자바 기본 타입에 값을 대입하면 값을 복사한다.</li>
        <li>객체 타입은 참조 값을 <strong>직접 대입하는 것을 막을 방법이 없다.</strong>
          <ul>
            <li>누군가 실수로 복사하지 않고 직접 대입하는 경우는 컴파일러 레벨에서 막을 방법이 없다.</li>
          </ul>
        </li>
        <li><strong>객체의 공유 참조는 피할 수 없다.</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">기본타입</span><span class="o">(</span><span class="n">primitive</span> <span class="n">type</span><span class="o">)</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> <span class="c1">//기본 타입은 값을 복사</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">//a 값은 10으로 유지</span>

<span class="n">객체</span> <span class="n">타입</span>
<span class="nc">Address</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"Old"</span><span class="o">);</span>
<span class="nc">Address</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> <span class="c1">//객체 타입은 참조를 전달</span>
<span class="n">b</span><span class="o">.</span><span class="na">setCity</span><span class="o">(</span><span class="s">"New"</span><span class="o">);</span> <span class="c1">//a와 b는 같은 인스턴스를 가르킨다. 따라서 a, b 둘 다 바뀐다.</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>불변 객체</strong>
      <ul>
        <li>객체 타입을 수정할 수 없게 만들면 <strong>부작용을 원천 차단</strong></li>
        <li><strong>값 타입은 불변 객체(immutable object)로 설계해야함</strong></li>
        <li><strong>불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체</strong></li>
        <li>생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨 (setter를 private로 만들어도 됨)</li>
        <li>참고 : Integer, String은 자바가 제공하는 대표적인 불변 객체</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>불변이라는 작은 제약으로 큰 재앙을 막을 수 있다.</strong></li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>값을 바꾸고 싶다면?</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Address</span> <span class="n">newAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"NewCity"</span><span class="o">,</span> <span class="n">address</span><span class="o">.</span><span class="na">getStreet</span><span class="o">(),</span> <span class="n">address</span><span class="o">.</span><span class="na">getZipcode</span><span class="o">());</span>
<span class="n">member</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">newAddress</span><span class="o">);</span>
<span class="c1">//위 코드처럼 완전히 새로 만들어서 바꿔야한다.</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li>값 타입은 side effect를 대비해서 <strong>불변으로 만드는걸 추천</strong>한다.</li>
  </ul>
</blockquote>

<h3 id="4-값-타입의-비교">4. 값 타입의 비교</h3>

<blockquote>
  <ul>
    <li><strong>값 타입</strong> : 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야함</li>
    <li><strong>동일성(identity) 비교</strong> : 인스턴스의 참조 값을 비교, == 사용</li>
    <li><strong>동등성(equivalence) 비교</strong> : 인스턴스의 값을 비교, equals() 사용</li>
    <li>값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야함</li>
    <li>값 타입의 equals() 메소드를 적절하게 재정의(주로 모든 필드 사용)</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="c1">//a == b true</span>
<span class="nc">Address</span> <span class="n">address1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>
<span class="nc">Address</span> <span class="n">address2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>
<span class="c1">//address1 == address2 false</span>
<span class="c1">//address1.equals(address2) false (equals 오버라이드 전)</span>
<span class="c1">//address1.equals(address2) true (equals 오버라이드 후)</span>
<span class="c1">//Java에서는 ==비교시 참조값을 비교하기 때문에 false가 나온다.</span>
</code></pre></div></div>

<h3 id="5-값-타입-컬렉션">5. 값 타입 컬렉션</h3>

<p><img src="../../assets/forPost/JPA_Basic/%EA%B0%92%ED%83%80%EC%9E%85%20%EC%BB%AC%EB%A0%89%EC%85%98.png" alt="TEXT" title="값타입 컬렉션" /></p>

<blockquote>
  <ul>
    <li>값 타입을 하나 이상 저장할 때 사용</li>
    <li>@ElementCollection, @CollectionTable 사용</li>
    <li>데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.</li>
    <li>컬렉션을 저장하기 위한 별도의 테이블이 필요함</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입 컬렉션 사용</strong>
      <ul>
        <li>값 타입 저장</li>
        <li>값 타입 조회
          <ul>
            <li>값 타입 컬렉션도 지연 로딩 전략 사용</li>
          </ul>
        </li>
        <li>값 타입 수정</li>
        <li>참고 : 값 타입 컬렉션은 영속성 전이(Cascade) + 고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.
          <ul>
            <li>값 타입 컬렉션도 값 타입이기 때문에 라이프사이클이 member에 의존한다</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span>

    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FAVORITE_FOOD"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">))</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FOOD_NAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">favoriteFoods</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ADDRESS"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">))</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="nc">JpaMain의</span> <span class="k">try</span> <span class="n">내부</span>

<span class="k">try</span> <span class="o">{</span>

            <span class="c1">// 저장 예제</span>
            <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setHomeAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"homeCity"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>

            <span class="n">member</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"치킨"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"족발"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"피자"</span><span class="o">);</span>

            <span class="n">member</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"old1"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>
            <span class="n">member</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"old2"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>

            <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

            <span class="c1">// 조회 예제</span>
            <span class="n">em</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="n">em</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span> <span class="c1">//깔끔한 상태에서 조회하기 위해 clear 해준다</span>

            <span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span> <span class="c1">//쿼리를 보면 Member만 가져온다. 즉, 컬렉션은 지연로딩 사용</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Address</span> <span class="n">address</span> <span class="o">:</span> <span class="n">addressHistory</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"address = "</span> <span class="o">+</span> <span class="n">address</span><span class="o">.</span><span class="na">getCity</span><span class="o">());</span> <span class="c1">//지연로딩이기 때문에 이때 쿼리가 나감</span>
            <span class="o">}</span>

            <span class="c1">//수정 예제</span>
            <span class="c1">//homeCity -&gt; newCity</span>
<span class="c1">//            findMember.getHomeAddress().setCity("newCity"); //immutable 해야하기 때문에 이런식으로 변경하면 절대 안된다.</span>

            <span class="nc">Address</span> <span class="n">a</span> <span class="o">=</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getHomeAddress</span><span class="o">();</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">setHomeAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"newCity"</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">getStreet</span><span class="o">(),</span> <span class="n">a</span><span class="o">.</span><span class="na">getZipcode</span><span class="o">()));</span> <span class="c1">//이런식으로 완전히 교체를 해줘야한다.</span>

            <span class="c1">//치킨 -&gt; 한식</span>
            <span class="c1">//단순 String이기 때문에 remove로 지우고 add로 추가해야한다.</span>
            <span class="c1">//String은 업데이트가 없다.</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="s">"치킨"</span><span class="o">);</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"한식"</span><span class="o">);</span>

            <span class="c1">//old1 -&gt; newCity1</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"old1"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>
            <span class="c1">//remove의 기본 동작은 equals로 대상을 찾는다. 즉, equals, hashcode를 안넣으면 지워지지 않고 값이 계속 들어가게 된다.</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"newCity1"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>
            <span class="c1">// 출력 결과 : MEMBER_ID를 기준으로 ADDRESS 테이블의 모든 컬럼이 delete가 되고 기존의 테이터인 old2와 새로운 데이터인 newCity1이 insert가 된다.</span>
            <span class="c1">// 결론 : 쓰면안됨</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>값 타입 컬렉션의 제약사항</strong>
      <ul>
        <li>값 타입은 엔티티와 다르게 식별자 개념이 없다.</li>
        <li>값은 변경하면 추적이 어렵다.</li>
        <li>값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 <strong>모든 데이터를 삭제</strong>하고, 값 타입 컬렉션에 있는 <strong>현재 값을 모두 다시 저장</strong>한다. (실무에서는 사용하면 안된다.)</li>
        <li>값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야함 : null 입력 X, 중복 저장 X</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입 컬렉션 대안</strong>
      <ul>
        <li>실무에서는 상황에 따라 <strong>값 타입 컬렉션 대신에 일대다 관계를 고려</strong> (실무에서 많이 쓰임)</li>
        <li>일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용</li>
        <li>영속성 전이(Cascade) + 고아 객체 제거를 사용해서 값 타입 컬렉션 처럼 사용</li>
        <li>EX) AddressEntity</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>값타입 컬렉션은 언제쓰이나?
      <ul>
        <li>엄청 단순할때 사용 (업데이트 필요 없을 때, 추적할 필요 없을 때)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">AddressEntity</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AddressEntity</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">AddressEntity</span><span class="o">(</span><span class="nc">Address</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">address</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AddressEntity</span><span class="o">(</span><span class="nc">String</span> <span class="n">city</span><span class="o">,</span> <span class="nc">String</span> <span class="n">street</span><span class="o">,</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="n">city</span><span class="o">,</span> <span class="n">street</span><span class="o">,</span> <span class="n">zipcode</span><span class="o">);</span>
    <span class="o">}</span>

<span class="nc">Member</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">ALL</span><span class="o">,</span> <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">AddressEntity</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>정리</strong>
      <ul>
        <li><strong>엔티티 타입의 특징</strong>
          <ul>
            <li>식별자 O</li>
            <li>생명 주기 관리</li>
            <li>공유</li>
          </ul>
        </li>
        <li><strong>값 타입 특징</strong>
          <ul>
            <li>식별자 X</li>
            <li>생명 주기를 엔티티에 의존</li>
            <li>공유하지 않는 것이 안전(복사해서 사용)</li>
            <li>불변 객체로 만드는 것이 안전</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입은 정말 값 타입이라 판단 될 때만 사용</strong></li>
    <li><strong>엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨</strong></li>
    <li><strong>식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것은 값 타입이 아닌 엔티티</strong></li>
  </ul>
</blockquote>

<h2 id="quiz">Quiz</h2>

<p><strong>문제 1.</strong> 다음 코드의 상황별 출력 결과를 쓰시오.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Address</span> <span class="n">address1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>
<span class="nc">Address</span> <span class="n">address2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>

<span class="n">상황</span> <span class="mi">1</span><span class="o">.</span> <span class="o">==</span> <span class="n">비교</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">address1</span> <span class="o">==</span> <span class="n">address2</span><span class="o">)</span>

<span class="n">상황</span> <span class="mi">2</span><span class="o">.</span> <span class="n">equals</span> <span class="n">비교</span><span class="o">,</span> <span class="nc">Address에</span> <span class="n">equals</span><span class="o">()</span> <span class="n">메소드</span> <span class="n">오버라이드</span> <span class="n">안함</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">address1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">address2</span><span class="o">))</span>

<span class="n">상황</span> <span class="mi">3</span><span class="o">.</span> <span class="n">equals</span> <span class="n">비교</span><span class="o">,</span> <span class="nc">Address에</span> <span class="n">equals</span><span class="o">()</span> <span class="n">메소드</span> <span class="n">오버라이드</span> <span class="n">함</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">address1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">address2</span><span class="o">))</span>
</code></pre></div></div>

<details>
<summary>정답 확인</summary>
<div>
    <p><br /></p>
    <h1>1. false</h1>
    <p><br /></p>
    <h1>2. false</h1>
    <p><br /></p>
    <h1>3. true</h1>
    <p><br /></p>
    <ol>
      <li>== 비교는 참조값을 비교하기 때문에 false가 나온다. <br /></li>
      <li>equals()의 기본은 == 비교이기 때문에 false가 나온다. <br /></li>
      <li>equals() 메소드를 재정의할 경우 내부 값이 같은지 판별하기 때문에 true가 나온다. <br /></li>
    </ol>

    <p><br /></p>
  </div>
</details>
<p><br /></p>

<p><strong>문제 2.</strong> 비슷한 기능을 가진 @MappedSuperclass와 @Embeddable의 차이점을 생각해보자.</p>

<details>
<summary>정답 확인</summary>
<div>
    <p><br /></p>

    <p>@MappedSuperclass는 상속 <br />
@Embeddable은 위임 <br /></p>

    <p><a href="#mappedsuperclass-vs-embeddable">자세한 설명</a>
<br /></p>

  </div>
</details>
<p><br /></p>]]></content><author><name>김경호</name></author><category term="JPA" /><category term="JPA" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (객체지향 쿼리 언어 - 기본 문법)]</title><link href="http://localhost:4000/jpa/JPA_Basic-5/" rel="alternate" type="text/html" title="[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (객체지향 쿼리 언어 - 기본 문법)]" /><published>2022-06-28T00:00:00+09:00</published><updated>2022-06-28T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA_Basic%205</id><content type="html" xml:base="http://localhost:4000/jpa/JPA_Basic-5/"><![CDATA[<p><br /></p>

<h2 id="객체지향-쿼리-언어---기본-문법">객체지향 쿼리 언어 - 기본 문법</h2>

<h3 id="0-객체지향-쿼리-언어-소개">0. 객체지향 쿼리 언어 소개</h3>

<blockquote>
  <ul>
    <li><strong>JPA는 다양한 쿼리 방법을 지원한다.</strong>
      <ul>
        <li><strong>JPQL</strong> : 실무에서는 대부분 JPQL로 해결 가능</li>
        <li>JPA Criteria</li>
        <li><strong>QueryDSL</strong></li>
        <li>네이티브 SQL</li>
        <li>JDBC API 직접 사용, MyBatis, SpringJdbcTemplate</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>JPQL 소개</strong>
      <ul>
        <li>가장 단순한 조회 방법
          <ul>
            <li>EntityManager.find()</li>
            <li>객체 그래프 탐색(a.getB().getC())</li>
          </ul>
        </li>
        <li><strong>ex) 나이가 18살 이상인 회원을 모두 검색하고 싶다면?</strong>
          <ul>
            <li>단순히 하나를 찍어서 가져올수 있는것이 아니다.</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>JPQL</strong>
      <ul>
        <li>JPA를 사용하면 엔티티 객체를 중심으로 개발</li>
        <li>문제는 검색 쿼리</li>
        <li>검색을 할 때도 <strong>테이블이 아닌 엔티티 객체를 대상으로 검색</strong></li>
        <li>모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능</li>
        <li>애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요</li>
        <li><strong>위에 언급된 문제들을 해결하기 위해</strong> JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공</li>
        <li>SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원</li>
        <li>JPQL은 엔티티 객체를 대상으로 쿼리</li>
        <li>SQL은 데이터베이스 테이블을 대상으로 쿼리</li>
        <li>테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리</li>
        <li>SQL을 추상화해서 특정 데이터베이스 SQL에 의존X</li>
        <li>JPQL을 한마디로 정의하면 객체지향 SQL</li>
        <li>JPQL은 단순 문자이기 때문에 동적 쿼리를 만들기 매우 어렵다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//간단한 JPQL의 예</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span>
                    <span class="s">"select m From Member m where m.age &gt; 18"</span><span class="o">,</span>
                    <span class="nc">Member</span><span class="o">.</span><span class="na">class</span>
<span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>

<span class="c1">//실행된 SQL</span>
<span class="n">select</span>
    <span class="n">m</span><span class="o">.</span><span class="na">id</span> <span class="n">as</span> <span class="n">id</span><span class="o">,</span>
    <span class="n">m</span><span class="o">.</span><span class="na">age</span> <span class="n">as</span> <span class="n">age</span><span class="o">,</span>
    <span class="n">m</span><span class="o">.</span><span class="na">USERNAME</span> <span class="n">as</span> <span class="no">USERNAME</span><span class="o">,</span>
    <span class="n">m</span><span class="o">.</span><span class="na">TEAM_ID</span> <span class="n">as</span> <span class="no">TEAM_ID</span>
<span class="n">from</span>
    <span class="nc">Member</span> <span class="n">m</span>
<span class="n">where</span>
    <span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">&gt;</span><span class="mi">18</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>Criteria 소개</strong>
      <ul>
        <li>문자가 아닌 자바코드로 JPQL을 작성할 수 있음</li>
        <li>쿼리문에서 오타를 내도 컴파일 시점에서 잡아준다</li>
        <li>JPQL 빌더 역할</li>
        <li>JPA 공식 기능</li>
        <li><strong>단점 : 너무 복잡하고 실용성이 없다.</strong>
          <ul>
            <li>유지보수가 어려움</li>
            <li>sql 같지가 않음</li>
            <li>디버깅을 못함</li>
          </ul>
        </li>
        <li>Criteria 대신에 <strong>QueryDSL</strong> 사용 권장</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Criteria 사용 준비</span>
<span class="nc">CriteriaBuilder</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getCriteriaBuilder</span><span class="o">();</span>
<span class="nc">CriteriaQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">//루트 클래스 (조회를 시작할 클래스)</span>
<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">//쿼리 생성</span>
<span class="nc">CriteriaQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">cq</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">m</span><span class="o">).</span><span class="na">where</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span> <span class="s">"kim"</span><span class="o">));</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">cq</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>QueryDSL 소개</strong>
      <ul>
        <li>문자가 아닌 자바코드로 JPQL을 작성할 수 있음</li>
        <li>JPQL 빌더 역할</li>
        <li>컴파일 시점에 문법 오류를 찾을 수 있음</li>
        <li>동적쿼리 작성 편리함</li>
        <li><strong>단순하고 쉬움</strong></li>
        <li><strong>실무 사용 권장</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//JPQL</span>
<span class="c1">//select m from Member m where m.age &gt; 18</span>
<span class="nc">JPAFactoryQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPAQueryFactory</span><span class="o">(</span><span class="n">em</span><span class="o">);</span>
<span class="nc">QMember</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">QMember</span><span class="o">.</span><span class="na">member</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span>
        <span class="n">query</span><span class="o">.</span><span class="na">selectFrom</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
                <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="mi">18</span><span class="o">))</span>
                <span class="o">.</span><span class="na">orderBy</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">desc</span><span class="o">())</span>
                <span class="o">.</span><span class="na">fetch</span><span class="o">();</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>네이티브 SQL 소개</strong>
      <ul>
        <li>JPA가 제공하는 SQL을 직접 사용하는 기능</li>
        <li>JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능</li>
        <li>예) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="s">"select MEMBER_ID, city, street, zipcode, USERNAME from MEMBER"</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>JDBC 직접 사용, SpringJdbcTemplate 등</strong>
      <ul>
        <li>JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, MyBatis 등을 함께 사용 가능</li>
        <li>단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요</li>
        <li>예) JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="quiz">Quiz</h2>

<p><strong>문제 1.</strong> 다음 예제들의 성공 여부를 쓰시오.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">예제</span> <span class="mi">1</span><span class="o">.</span> <span class="n">select</span> <span class="n">o</span><span class="o">.</span><span class="na">member</span><span class="o">.</span><span class="na">team</span>
        <span class="n">from</span> <span class="nc">Order</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="n">성공</span>

<span class="n">예제</span> <span class="mi">2</span><span class="o">.</span> <span class="n">select</span> <span class="n">t</span><span class="o">.</span><span class="na">members</span> <span class="n">from</span> <span class="nc">Team</span> <span class="o">-&gt;</span> <span class="n">성공</span>

<span class="n">예제</span> <span class="mi">3</span><span class="o">.</span> <span class="n">select</span> <span class="n">t</span><span class="o">.</span><span class="na">members</span><span class="o">.</span><span class="na">username</span> <span class="n">from</span> <span class="nc">Team</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">실패</span>

<span class="n">예제</span> <span class="mi">4</span><span class="o">.</span> <span class="n">select</span> <span class="n">m</span><span class="o">.</span><span class="na">username</span> <span class="n">from</span> <span class="nc">Team</span> <span class="n">t</span> <span class="n">join</span> <span class="n">t</span><span class="o">.</span><span class="na">members</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="n">성공</span>
</code></pre></div></div>

<details>
<summary>정답 확인</summary>
<div>
    <p><br /></p>
    <h1>1. 성공</h1>
    <p><br /></p>
    <h1>2. 성공</h1>
    <p><br /></p>
    <h1>3. 실패</h1>
    <p><br /></p>
    <h1>3. 성공</h1>
    <p><br /></p>

    <ol>
      <li>컬렉션에서는 더 들어가면 안된다. 명시적 조인을 통해 별칭을 얻어야한다. <br /></li>
    </ol>

    <p><br /></p>
  </div>
</details>
<p><br /></p>]]></content><author><name>김경호</name></author><category term="JPA" /><category term="JPA" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (고급매핑, 프록시와 연관관계 관리)]</title><link href="http://localhost:4000/jpa/JPA_Basic-3/" rel="alternate" type="text/html" title="[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (고급매핑, 프록시와 연관관계 관리)]" /><published>2022-06-24T00:00:00+09:00</published><updated>2022-06-24T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA_Basic%203</id><content type="html" xml:base="http://localhost:4000/jpa/JPA_Basic-3/"><![CDATA[<p><br /></p>

<h2 id="고급매핑">고급매핑</h2>

<h3 id="1-상속관계-매핑">1. 상속관계 매핑</h3>

<blockquote>
  <ul>
    <li>관계형 데이터베이스는 상속 관계 X (객체는 상속관계가 있음)</li>
    <li><strong>슈퍼타입 서브타입</strong> 관계라는 모델링 기법이 객체 상속과 유사</li>
    <li><strong>상속관계 매핑</strong> : 객체의 상속 구조와 DB의 슈퍼타입, 서브타입 관계를 매핑</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>슈퍼타입 논리 모델을 실제 물리 모델로 구현하는 방법</strong>
      <ul>
        <li>각각 테이블로 변환 -&gt; <strong>조인 전략</strong> <img src="../../assets/forPost/JPA_Basic/%EC%A1%B0%EC%9D%B8%20%EC%A0%84%EB%9E%B5.png" alt="TEXT" title="조인 전략" />
          <ul>
            <li>앨범 데이터를 추가하면 ITEM과 ALBUM에 insert가 된다. (즉, insert 2번)</li>
            <li>ITEM 테이블의 DTYPE를 통해 어느 테이블과 조인할지 구분 가능</li>
          </ul>
        </li>
        <li>통합 테이블로 변환 -&gt; <strong>단일 테이블 전략</strong> <img src="../../assets/forPost/JPA_Basic/%EB%8B%A8%EC%9D%BC%ED%85%8C%EC%9D%B4%EB%B8%94%20%EC%A0%84%EB%9E%B5.png" alt="TEXT" title="단인테이블 전략" />
          <ul>
            <li>DTYPE을 통해 Album, Movie, Book중 무엇인지 구분 가능</li>
          </ul>
        </li>
        <li>서브타입 테이블로 변환 -&gt; <strong>구현 클래스마다 테이블 전략</strong><img src="../../assets/forPost/JPA_Basic/%EA%B5%AC%ED%98%84%20%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A7%88%EB%8B%A4%20%ED%85%8C%EC%9D%B4%EB%B8%94%20%EC%A0%84%EB%9E%B5.png" alt="TEXT" title="구현 클래스마다 전략" /></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>주요 어노테이션</strong>
      <ul>
        <li>@Inheritance(strategy = InheritanceType.XXX)
          <ul>
            <li>JOINED : 조인전략</li>
            <li>SINGLE_TABLE : 단일 테이블 전략</li>
            <li>TABLE_PER_CLASS : 구현 클래스마다 테이블 전략</li>
          </ul>
        </li>
        <li>@DiscriminatorColumn(name=“DTYPE”)</li>
        <li>@DiscriminatorValue(“XXX”)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">JOINED</span><span class="o">)</span> <span class="c1">//JOINED를 SINGLE_TABLE로 바꾸면 단일 테이블 전략</span>
<span class="nd">@DiscriminatorColumn</span>  <span class="c1">// (name = "DIS_TYPE)을 적으면 컬럼명 바꾸기 가능</span>
<span class="c1">//단일 테이블 전략은 @DiscriminatorColumn 안써도 자동으로 DTYPE 생성됨(한 테이블에 들어가있기때문에 DTYPE이 없으면 뭔지 알수없다.)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li>JPA의 장점 : 조인 테이블 전략으로 개발하다가 단일 테이블 전략으로 바꿔야 할 경우 @Inheritance 어노테이션만 수정하면 된다</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"A"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Album</span> <span class="kd">extends</span> <span class="nc">Item</span><span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">artist</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JpaMain</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">EntityManagerFactory</span> <span class="n">emf</span> <span class="o">=</span> <span class="nc">Persistence</span><span class="o">.</span><span class="na">createEntityManagerFactory</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>

        <span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>

        <span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
        <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Movie</span> <span class="n">movie</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Movie</span><span class="o">();</span>
            <span class="n">movie</span><span class="o">.</span><span class="na">setDirector</span><span class="o">(</span><span class="s">"aaaa"</span><span class="o">);</span>
            <span class="n">movie</span><span class="o">.</span><span class="na">setActor</span><span class="o">(</span><span class="s">"bbbb"</span><span class="o">);</span>
            <span class="n">movie</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"바람"</span><span class="o">);</span>
            <span class="n">movie</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>

            <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">movie</span><span class="o">);</span><span class="c1">//(조인 전략 사용시 insert 두번, 단일테이블 전략 사용시 insert 한번)</span>

            <span class="n">em</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="n">em</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span> <span class="c1">//영속성 컨텍스트 제거, 1차 캐시 비움</span>

            <span class="nc">Movie</span> <span class="n">findMovie</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Movie</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">movie</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span> <span class="c1">//실행시 콘솔에 쿼리가 나온다. (조인 전략은 조인 사용)</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findMovie = "</span> <span class="o">+</span> <span class="n">findMovie</span><span class="o">);</span>

            <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">tx</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
        <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
            <span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">emf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>조인 전략 실행결과</strong> <br />
<img src="../../assets/forPost/JPA_Basic/%EC%A1%B0%EC%9D%B8%20%EC%A0%84%EB%9E%B5%20DB.png" alt="TEXT" title="조인 전략 DB" /> <br />
ITEM 테이블과 MOVIE 테이블의 ID는 똑같다. (ITEM의 ID는 PK, MOVIE의 ID는 PK,FK) <br />
DTYPE의 M은 Movie (@DiscriminatorValue을 사용) <br /></p>

<blockquote>
  <ul>
    <li><strong>장점</strong>
      <ul>
        <li>테이블 정규화</li>
        <li>외래 키 참조 무결성 제약조건 활용가능 (ITEM_ID 사용, 설계가 깔끔해짐)</li>
        <li>저장공간 효율화 (정규화가 되어있기 때문에)</li>
      </ul>
    </li>
    <li><strong>단점</strong>
      <ul>
        <li>조회시 조인을 많이 사용, 성능 저하 (조인을 잘 하면 성능저하 크게 발생 안함, 저장공간이 효율화 되어있기 때문에 오히려 성능이 잘 나올수도 있다)</li>
        <li>조회 쿼리가 복잡함</li>
        <li>데이터 저장시 INSERT SQL 2번 호출</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>조인전략이 <strong>정석</strong>이라고 생각하면 된다.</li>
    <li>객체와도 잘 맞고 정규화도 되고 깔끔하게 설계 가능</li>
    <li>단일 테이블에 비해서는 <strong>복잡</strong>하다</li>
  </ul>
</blockquote>

<p><strong>단일 테이블 전략 실행결과</strong> <br />
<img src="../../assets/forPost/JPA_Basic/%EB%8B%A8%EC%9D%BC%ED%85%8C%EC%9D%B4%EB%B8%94%20%EC%A0%84%EB%9E%B5%20DB.png" alt="TEXT" title="단일테이블 전략 DB" /> <br /></p>

<blockquote>
  <ul>
    <li><strong>장점</strong>
      <ul>
        <li>조인이 필요 없으므로 일반적으로 조회 성능이 빠름</li>
        <li>조회 쿼리가 단순함</li>
      </ul>
    </li>
    <li><strong>단점</strong>
      <ul>
        <li>자식 엔티티가 매핑한 컬럼은 모두 null 허용 (데이터 무결성 입장애서는 애매한게 있다)</li>
        <li>단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다. (웬만해서는 임계점을 넘을 경우가 거의 없다.)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><strong>구현 클래스마다 테이블 전략 결과</strong> <br />
<img src="../../assets/forPost/JPA_Basic/%EA%B5%AC%ED%98%84%20%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A7%88%EB%8B%A4%20%ED%85%8C%EC%9D%B4%EB%B8%94%20%EC%A0%84%EB%9E%B5%20DB.png" alt="TEXT" title="구현클래스마다" /> <br />
ITEM 테이블은 안만들어진다. <br />
구분할 필요가 없기 때문에 DTYPE도 안만들어진다. <br />
쿼리도 심플하게 들어가서 좋은것 같지만 데이터를 찾을때 큰 문제 발생. <br />
ex) ITEM_ID만 알 경우, 모든 테이블에서 찾아서(select시 union 사용) 매우 비효율적이다.<br /></p>

<blockquote>
  <ul>
    <li><strong>이 전략은 DB 설계자와 ORM 전문가 둘 다 추천 X</strong></li>
    <li>장점
      <ul>
        <li>서브 타입을 명확하게 구분해서 처리할 때 효과적</li>
        <li>not null 제약조건 사용 가능</li>
      </ul>
    </li>
    <li>단점
      <ul>
        <li>여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)</li>
        <li>자식 테이블을 통합해서 쿼리하기 어려움</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>테이블이 묶이는게 없기 때문에 전부 다 조회해야함</li>
    <li>새로운 타입을 추가할때 변경할게 굉장히 많아진다.</li>
    <li>이 전략을 사용할 경우 먼 미래에 언젠가는 큰 후회를 한다.</li>
  </ul>
</blockquote>

<h4 id="언제-뭘-사용할까">언제 뭘 사용할까?</h4>

<blockquote>
  <ul>
    <li>보통 조인 전략을 선택, 엄청 단순하고 확장할 일도 없을 경우 단일테이블 전략 선택</li>
  </ul>
</blockquote>

<h3 id="2-mapped-superclass---매핑-정보-상속">2. Mapped Superclass - 매핑 정보 상속</h3>

<blockquote>
  <ul>
    <li>공통 매핑 정보가 필요할 때 사용(id, name)</li>
  </ul>
</blockquote>

<p><strong>ex)</strong> 객체 입장에서 id, name 필드가 계속 나올 때, 클래스 만들때 마다 id, name 필드를 생성하기 귀찮으니까 부모 클래스에 두고 속성만 상속해서 사용하고 싶은경우 <br />
DB는 완전히 다른데, 객체 입장에서 속성만 상속받아서 쓰고싶은 경우 <br />
즉, 귀찮아서 귀찮음을 줄일 때 사용</p>

<p><img src="../../assets/forPost/JPA_Basic/MappedSuperclass%EC%82%AC%EC%9A%A9.png" alt="TEXT" title="MappedSuperclass 사용" /></p>

<p><strong>ex)</strong> 모든 테이블에서 누가, 언제 등록, 수정했는지에 대한 정보가 항상 있어야 할 경우</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
private String createdBy;
private LocalDateTime createdDate;
private String lastModifiedBy;
private LocalDateTime lastModifiedDate;
MappedSuperclass를 사용하지 않으면 이 코드를 모든 테이블에 작성해야한다.*/</span>
<span class="c1">//MappedSuperclass를 사용하면 상속받아서 사용할 수 있다.</span>
<span class="nd">@MappedSuperclass</span> <span class="c1">//매핑 정보만 받는 부모 클래스</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">BaseEntity</span> <span class="o">{</span>

    <span class="c1">//@Column(name = "INSERT_MEMBER") 컬럼 이름 변경시 사용</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">createdBy</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">createdDate</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">lastModifiedBy</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">lastModifiedDate</span><span class="o">;</span>

    <span class="c1">//getter setter 생략</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span><span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMEBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"USERNAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//JpaMain의 try 내부 코드</span>
<span class="k">try</span> <span class="o">{</span>

            <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"user1"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setCreatedBy</span><span class="o">(</span><span class="s">"kim"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setCreatedDate</span><span class="o">(</span><span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>

            <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

            <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
     <span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>상속관계 매핑 X</strong></li>
    <li><strong>엔티티 X, 테이블과 매핑 X</strong>(속성만 내려주는애)</li>
    <li><strong>부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공</strong></li>
    <li><strong>조회, 검색 불가</strong> (em.find(BaseEntity.class) 불가능)</li>
    <li><strong>직접 생성해서 사용할 일이 없으므로 추상 클래스 권장</strong></li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할</li>
    <li>주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용</li>
    <li><strong>참고</strong> : @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능 (JPA에서 extends를 사용할때)</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>실무에서 BaseEntity를 만들어서 활용하면 편리하다.</li>
  </ul>
</blockquote>

<h2 id="프록시와-연관관계-관리">프록시와 연관관계 관리</h2>

<h3 id="1-프록시">1. 프록시</h3>

<blockquote>
  <ul>
    <li><strong>프록시 사용 이유?</strong>
      <ul>
        <li>Memeber 테이블과 Team 테이블이 연관관계를 가질 때, 프록시를 사용하지 않아서 지연로딩을 사용할 수 없다면 Member를 JPA를 통해 조회할 때 연관관계인 Team까지 함께 조회된다. <br /> 여기서 문제가 되는 이유는 Member만 필요한데 연관관계인 Team까지 다 불러와서 메모리에 올라와있기 때문에 <strong>리소스 낭비</strong>가 생긴다. <br /> 만약 프록시를 사용하여 지연로딩이 가능해지면 Team을 지연로딩으로 처리하고(Team은 불러오지 않게 됨) Member만 불러올 수 있게된다. <br /> 이 과정에서 Team을 불러오지 않기 때문에 <strong>리소스의 낭비를 조금이라도 줄일 수 있다.</strong> 이러한 지연로딩이라는 기술을 가능케 하는게 프록시이다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>프록시의 기초</strong>
      <ul>
        <li>em.find() vs em.getReference();
          <ul>
            <li>em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회 (쿼리가 나감)</li>
            <li>em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회 (쿼리가 안나감)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/em.getReference().png" alt="TEXT" title="em.getReference" /></p>

<blockquote>
  <ul>
    <li><strong>프록시 특징 1</strong>
      <ul>
        <li>실제 클래스를 상속 받아서 만들어짐</li>
        <li>실제 클래스와 겉 모양이 같다.</li>
        <li>사용하는 입장에서는 진짜 객체인지 프롤시 객체인지 구분하지 않고 사용하면 됨 (이론상)</li>
        <li>프록시 객체는 실제 객체의 참조(target)를 보관</li>
        <li>프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%ED%94%84%EB%A1%9D%EC%8B%9C%20%ED%8A%B9%EC%A7%951.png" alt="TEXT" title="프록시 특징" width="20%" height="20%" />
<img src="../../assets/forPost/JPA_Basic/%ED%94%84%EB%A1%9D%EC%8B%9C%20%ED%8A%B9%EC%A7%952.png" alt="TEXT" title="프록시 특징" width="60%" height="80%" /></p>

<blockquote>
  <ul>
    <li><strong>프록시 객체의 초기화</strong></li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%ED%94%84%EB%A1%9D%EC%8B%9C%20%EA%B0%9D%EC%B2%B4%EC%9D%98%20%EC%B4%88%EA%B8%B0%ED%99%94.png" alt="TEXT" title="프록시 객체의 초기화" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="o">{</span>
    <span class="c1">// Member findMember = em.find(Member.class, member.getId()); //쿼리 나감</span>
    <span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span> <span class="c1">//getReference를 호출하는 시점에는 쿼리 안나감</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findMember = "</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">// 출력결과 : hellojpa.Member$HibernateProxy$odcVHpjy  (Hibernate가 강제로 만든 가짜 클래스(프록시))</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findMember.id = "</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span> <span class="c1">// 아직 쿼리 안나감, Reference를 찾을때 getId를 넣었기 때문에 즉, 이미 값이 있기 때문에 쿼리가 안나감</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findMember.username = "</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span> <span class="c1">// 쿼리 나감, findMember에 값을 채워야 하기 때문에 쿼리가 나간다.</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findMember.username = "</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span> <span class="c1">// 한번 더 호출 시, 바로 위에서 이미 초기화 되어있기 때문에 값만 출력됨</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>프록시 특징 2</strong>
      <ul>
        <li>프록시 객체는 처음 사용할 때 <strong>한 번만 초기화</strong></li>
        <li>프록시 객체를 초기화 할 때, <strong>프록시 객체가 실제 엔티티로 바뀌는 것은 아님</strong>, 초기화되면 프록시 객체를 통해서 <strong>실제 엔티티에 접근 가능</strong></li>
        <li>프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함(==비교 실패, 대신 <strong>instance of 사용</strong>)</li>
        <li>영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환</li>
        <li>영속성 컨텍스트의 도움을 받을 수 없는 준 영속 상태일 때, 프록시를 초기화하면 문제 발생 (Hibernate는 org.hibernate.LazyInitializationException 예외를 터트림)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"before findMember = "</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//출력결과 : hellojpa.Member$HibernateProxy$odcVHpjy</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findMember.username = "</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"after findMember = "</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//출력결과 : hellojpa.Member$HibernateProxy$odcVHpjy</span>
<span class="c1">// 교체되는것이 아니라 프록시는 유지가 되고 내부의 타겟에만 값이 채워지는것이다.</span>
<span class="c1">//==========================================================================================================================</span>
<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member1</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member1</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member2"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

<span class="nc">Member</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="nc">Member</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member2</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m1 == m2: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">m1</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="n">m2</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span> <span class="c1">//false가 나온다.</span>
<span class="n">logic</span><span class="o">(</span><span class="n">m1</span><span class="o">,</span><span class="n">m2</span><span class="o">);</span>
<span class="c1">//비즈니스 로직에서는 메소드로 파라미터만 넘어오기 때문에 프록시가 넘어오는지 실제로 넘어오는지 모르기 때문에 == 비교를 하면 안된다.</span>
<span class="c1">//ex</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">logic</span><span class="o">(</span><span class="nc">Member</span> <span class="n">m1</span><span class="o">,</span> <span class="nc">Member</span> <span class="n">m2</span><span class="o">){</span>
    <span class="c1">//System.out.println("m1 == m2: " + (m1.getClass() == m2.getClass()));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m1 == m2: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">m1</span> <span class="k">instanceof</span> <span class="nc">Member</span><span class="o">));</span> <span class="c1">//true</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m1 == m2: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">m2</span> <span class="k">instanceof</span> <span class="nc">Member</span><span class="o">));</span> <span class="c1">//true</span>
<span class="o">}</span>
<span class="c1">//==========================================================================================================================</span>
<span class="nc">Member</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m1 = "</span> <span class="o">+</span> <span class="n">m1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//출력결과 : hellojpa.Member</span>

<span class="nc">Member</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"reference = "</span> <span class="o">+</span> <span class="n">reference</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//출력결과 : hellojpa.Member</span>
<span class="cm">/* Reference를 했는데 프록시로 안나오는 이유
1. member를 이미 영속성 컨텍스트에 올려놨는데 굳이 프록시로 가져와봐야 이점이 없다.
2. JPA에서는 동일한 트랜잭션 내에서 엔티티의 동일성을 보장하기 때문에 타입 비교를 하면 true로 나온다.
*/</span>
<span class="c1">//==========================================================================================================================</span>
<span class="nc">Member</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m1 = "</span> <span class="o">+</span> <span class="n">m1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB</span>

<span class="nc">Member</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"reference = "</span> <span class="o">+</span> <span class="n">reference</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m1 == reference: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">m1</span> <span class="o">==</span> <span class="n">reference</span><span class="o">));</span> <span class="c1">// true</span>
<span class="cm">/* 같은 프록시가 반환된 이유?
동일한 트랜잭션 내에서 엔티티의 동일성 보장
*/</span>
<span class="c1">//==========================================================================================================================</span>
<span class="nc">Member</span> <span class="n">refMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"refMember = "</span> <span class="o">+</span> <span class="n">refMember</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB</span>

<span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span> <span class="c1">//실제 조회를 하기 때문에 쿼리 나감</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findMember = "</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"refMember == findMember: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">refMember</span> <span class="o">==</span> <span class="n">findMember</span><span class="o">));</span> <span class="c1">// true</span>
<span class="cm">/* find에서도 프록시가 반환된 이유?
동일한 트랜잭션 내에서 엔티티의 동일성 보장
*/</span>
<span class="c1">//===========================================================================================================================</span>
<span class="nc">Member</span> <span class="n">refMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"refMember = "</span> <span class="o">+</span> <span class="n">refMember</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//프록시</span>

<span class="c1">//em.close //영속성 컨텍스트 종료</span>
<span class="n">em</span><span class="o">.</span><span class="na">detach</span><span class="o">(</span><span class="n">refMember</span><span class="o">);</span> <span class="c1">//영속성 컨텍스트 관리 안함</span>
<span class="c1">//em.clear //영속성 컨텍스트가 초기화 되므로 똑같이 에러가 발생</span>

<span class="n">refMember</span><span class="o">.</span><span class="na">getUsername</span><span class="o">();</span> <span class="c1">//위의 3가지 모두 org.hibernate.LazyInitializationException 에러 발생</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"refMember = "</span> <span class="o">+</span> <span class="n">refMember</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li>프록시든 아니든 <strong>개발에 문제가 없게 개발</strong>해야 된다.</li>
    <li>실무에서 <strong>org.hibernate.LazyInitializationException</strong>이 <strong>많이 발생</strong>하므로 <strong>주의</strong>하자.</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>프록시 확인</strong>
      <ul>
        <li>프록시 인스턴스의 초기화 여부 확인
          <ul>
            <li>PersistenceUnitUtil.isLoaded(Object entity)</li>
          </ul>
        </li>
        <li>프록시 클래스 확인 방법
          <ul>
            <li>entity.getClass().getName() 출력(..javasist.. or HibernateProxy…)</li>
          </ul>
        </li>
        <li>프록시 강제 초기화
          <ul>
            <li>org.hibernate.Hibernate.initialize(entity);</li>
          </ul>
        </li>
        <li>참고 : JPA 표준은 강제 초기화 없음 <br /> 강제 호출 : member.getName();</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">refMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"refMember = "</span> <span class="o">+</span> <span class="n">refMember</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">//프록시</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"isLoaded = "</span> <span class="o">+</span> <span class="n">emf</span><span class="o">.</span><span class="na">getPersistenceUnitUtil</span><span class="o">().</span><span class="na">isLoaded</span><span class="o">(</span><span class="n">refMember</span><span class="o">));</span> <span class="c1">//출력 결과 : false</span>

<span class="n">refMember</span><span class="o">.</span><span class="na">getUsername</span><span class="o">();</span> <span class="c1">//강제 초기화</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"isLoaded = "</span> <span class="o">+</span> <span class="n">emf</span><span class="o">.</span><span class="na">getPersistenceUnitUtil</span><span class="o">().</span><span class="na">isLoaded</span><span class="o">(</span><span class="n">refMember</span><span class="o">));</span> <span class="c1">//출력 결과 : true</span>

<span class="nc">Hibernate</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="n">refMember</span><span class="o">);</span> <span class="c1">//강제 초기화</span>
</code></pre></div></div>

<h3 id="2-즉시-로딩과-지연-로딩">2. 즉시 로딩과 지연 로딩</h3>

<blockquote>
  <ul>
    <li>지연로딩 <strong>LAZY를 사용</strong>해서 프록시로 조회</li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9.png" alt="TEXT" title="지연로딩" />
<img src="../../assets/forPost/JPA_Basic/%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9%20LAZY.png" alt="TEXT" title="지연로딩 LAZY" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMEBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"USERNAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>

<span class="nc">JpaMain의</span> <span class="k">try</span> <span class="n">내부</span>
<span class="k">try</span><span class="o">{</span>
    <span class="nc">Member</span> <span class="n">m</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span><span class="c1">//Member만 가져옴</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m = "</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">getTeam</span><span class="o">().</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">// 프록시로 나옴</span>
    <span class="n">m</span><span class="o">.</span><span class="na">getTeam</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span> <span class="c1">//이때 TEAM에 대한 쿼리가 나옴, 초기화</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>Member와 Team을 자주 함께 사용한다면?</strong>
      <ul>
        <li>LAZY를 사용하면 Member 따로 Team 따로 쿼리가 각각 나가서 성능상 손해를 본다.</li>
        <li>즉시 로딩 EAGER를 사용해서 함께 조회</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%EC%A6%89%EC%8B%9C%EB%A1%9C%EB%94%A9.png" alt="TEXT" title="즉시로딩" />
<img src="../../assets/forPost/JPA_Basic/%EC%A6%89%EC%8B%9C%EB%A1%9C%EB%94%A9%20EAGER.png" alt="TEXT" title="즉시로딩 EAGER" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMEBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"USERNAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>

<span class="nc">JpaMain의</span> <span class="k">try</span> <span class="n">내부</span>
<span class="k">try</span><span class="o">{</span>
    <span class="nc">Member</span> <span class="n">m</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member1</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span> <span class="c1">//조회를 할대 join을 사용해서 한방에 쿼리를 날림</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m = "</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">getTeam</span><span class="o">().</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">// 프록시가 아닌 hellojpa.Team가 나옴</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"teamName = "</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">getTeam</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span> <span class="c1">//teamA</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>프록시와 즉시로딩 주의</strong>
      <ul>
        <li><strong>가급적 지연 로딩만 사용</strong>(실무에서는 즉시 로딩 사용하면 안됨)</li>
        <li>즉시 로딩을 적용하면 <strong>예상하지 못한 SQL이 발생</strong>
          <ul>
            <li>테이블이 여러개면 join도 여러개 나와서 <strong>성능이 저하</strong>되고 쿼리도 엄청 길게 나온다.</li>
          </ul>
        </li>
        <li>즉시 로딩은 JPQL에서 <strong>N+1 문제</strong>를 일으킨다.
          <ul>
            <li>JPQL로 Member 조회할 경우, Member에 Team이 EAGER로 설정되어 있으면 Team도 같이 가져온다</li>
            <li>최초 쿼리가 1개 나가고 추가로 N개의 쿼리가 나간다</li>
          </ul>
        </li>
        <li>@ManyToOne, @OneToOne은 기본이 즉시 로딩 -&gt; LAZY로 설정하자</li>
        <li>@OneToMany, @ManyToMany는 기본이 지연 로딩</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>실무에서는?</strong>
      <ul>
        <li>모든 연관관계에 <strong>지연 로딩으로 설정</strong></li>
        <li><strong>실무에서 즉시 로딩 사용하지 말것!</strong></li>
        <li>JPQL fetch join 사용 (데이터가 채워지기 때문에 루프를 돌려서 값을 출력해서 추가적인 쿼리가 안나간다.)</li>
        <li>엔티티 그래프 기능 사용 (추후에 배울 내용)</li>
        <li>배치사이즈 활용 (추후에 배울 내용)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="3-영속성-전이cascade와-고아-객체">3. 영속성 전이(CASCADE)와 고아 객체</h3>

<blockquote>
  <ul>
    <li><strong>영속성 전이 : CASCADE</strong>
      <ul>
        <li>특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때</li>
        <li>예 : 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>주의</strong>
      <ul>
        <li>영속성 전이는 연관관계 매핑하는 것과 아무 관련이 없다.</li>
        <li>엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐이다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>CASCADE의 종류</strong>
      <ul>
        <li>ALL : 모두 적용 (라이프사이클 전부 맞출 때)</li>
        <li>PERSIST : 영속 (저장할때만 라이프사이클 맞출 때)</li>
        <li>REMOVE : 삭제</li>
        <li>MERGE : 병합</li>
        <li>REFRESH : REFRESH</li>
        <li>DETACH : DETACH</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>쓰면 안되는 경우</strong>
      <ul>
        <li>소유자가 둘 이상일 때</li>
        <li>완전히 종속적이지 않을 때</li>
        <li>라이프사이클이 다를 때</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"parent"</span><span class="o">,</span> <span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">ALL</span><span class="o">,</span> <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;</span> <span class="n">childList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addChild</span><span class="o">(</span><span class="nc">Child</span> <span class="n">child</span><span class="o">){</span>
        <span class="n">childList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
        <span class="n">child</span><span class="o">.</span><span class="na">setParent</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"parent_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>
<span class="o">}</span>

<span class="nc">JpaMain의</span> <span class="k">try</span> <span class="n">내부</span>
<span class="k">try</span><span class="o">{</span>
    <span class="nc">Child</span> <span class="n">child1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Child</span><span class="o">();</span>
    <span class="nc">Child</span> <span class="n">child2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Child</span><span class="o">();</span>

    <span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Parent</span><span class="o">();</span>
    <span class="n">parent</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span><span class="n">child1</span><span class="o">);</span>
    <span class="n">parent</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span><span class="n">child2</span><span class="o">);</span>

    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span> <span class="c1">//Parent의 CascadeType.All 때문에 child도 같이 persist된다.</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>고아객체</strong>
      <ul>
        <li>고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제</li>
        <li><strong>orphanRemoval = true (조심히 사용할것)</strong></li>
        <li>Parent parent1 = em.find(Parent.class, id); <br /> parent1.getChildren().remove(0); <br /> 자식 엔티티를 컬렉션에서 제거</li>
        <li>DELETE FROM CHILD WHERE ID=? 쿼리가 나간다</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>주의</strong>
      <ul>
        <li>참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능</li>
        <li><strong>참조하는 곳이 하나</strong>일 때 사용해야함</li>
        <li><strong>특정 엔티티가 개인 소유</strong>할 때 사용</li>
        <li>@OneToOne, @OneToMany만 가능</li>
        <li>참고 : 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께 제거된다. 이것은 CascadeType.REMOVE처럼 동작한다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>영속성 전이 + 고아객체, 생명주기</strong>
      <ul>
        <li>CascadeType.All + orphanRemoval=true</li>
        <li>스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거</li>
        <li>두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음</li>
        <li>도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="etc-에러">etc. 에러</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cannot drop "ITEM" because "FKF1UERPNMN49VL1SPBBPLGXAUN, FKABGE9EQALSPCEJIJ53RAT7PJH" depends on it; SQL statement:
drop table item [90107-200]
테이블을 드랍할 때 이런 오류가 발생 할 경우
pom.xml에서 hibernate 버전을 5.4.13.Final로 바꾸기
H2 데이터베이스 버전을 1.4.200로 바꾸기(재설치)
</code></pre></div></div>

<h2 id="quiz">Quiz</h2>

<p><strong>문제 1.</strong> 조인 전략, 단일 테이블 전략보다 구현 클래스마다 테이블 전략을 사용하는게 더 편하고 좋다?</p>

<details>
<summary>정답 확인</summary>
<div>
    <p><br /></p>
    <h1>X</h1>
    <p><br /> 구현 클래스마다 테이블 전략은 DB 설계자와 ORM 전문가 둘 다 추천하지 않는 방법이다.
여러 테이블을 함께 조회할 경우 UNION을 사용하기 때문에 성능이 느리다.
<br /></p>
  </div>
</details>
<p><br /></p>

<p><strong>문제 2.</strong> @MappedSuperclass 사용한 BaseEntity는 DB테이블로 만들어진다?</p>

<details>
<summary>정답 확인</summary>
<div>
    <p><br /></p>
    <h1>X</h1>
    <p><br />
부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공해주는 역할만 하기 때문에 테이블이 만들어지지 않는다.
<br /></p>
  </div>
</details>
<p><br /></p>

<p><strong>문제 3.</strong> 아래 코드의 출력결과는? <br /> 1. em.find(Member.class, m.getId()) <br /> em.flush(); em.clear(); <br /> 2. em.getReference(Member.class, m.getId()) <br /> System.out.println(“1==2 : “ + 1==2);</p>

<details>
<summary>정답 확인</summary>
<div>
    <p><br /></p>
    <h1>false</h1>
    <p><br />
em.find() 이후 member 객체는 영속성 컨텍스트로 관리된다. 그리고 한 트랙잭션안에서 이 객체의 동일함을 보장한다. <br /> 그러나 clear는 영속성으로 관리하던 모든 객체를 다 삭제하게 된다. <br /> 그리고 난 뒤 다시 DB의 정보를 기반으로 member 를 생성하게 되면 이전에 관리하던 member와는 관계 없는 객체가 된다.
<br /></p>
  </div>
</details>
<p><br /></p>]]></content><author><name>김경호</name></author><category term="JPA" /><category term="JPA" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[CS 01. 기본이론]</title><link href="http://localhost:4000/cs/CS_Basic_1/" rel="alternate" type="text/html" title="[CS 01. 기본이론]" /><published>2022-06-21T00:00:00+09:00</published><updated>2022-06-21T00:00:00+09:00</updated><id>http://localhost:4000/cs/CS_Basic_1</id><content type="html" xml:base="http://localhost:4000/cs/CS_Basic_1/"><![CDATA[<p><br /></p>

<h2 id="0-cs기본이론을-배워야-하는-이유">0. CS기본이론을 배워야 하는 이유</h2>

<blockquote>
  <ul>
    <li><em>수년 경력을 지닌 경력자가 스택과 큐의 차이점을 설명할 수 없다면 무엇을 믿고 그 사람에게 일을 맡길 수 있을까? <br /> 모든 고급 개발 지식과 업무의 기본 근간은 알게 모르게 우리가 배웠던 CS 기본 지식으로 연결된다. <br /> 우리는 실무에서 스택과 큐를 직접 구현할 일은 거의 없지만 구현하려는 코드에 어떤 자료구조가 알맞은지, 어떤 알고리즘이나 자료구조를 선택해야 하는지에 대한 의사결정은 CS기본기에서 나온다고 해도 과언이 아니다.</em></li>
    <li><em>CS 기본이론의 필요성</em>
      <ul>
        <li>컴퓨터(시스템)에 대한 이해 (컴퓨터와 제대로 소통하기)</li>
        <li>자료구조, 알고리즘 활용법(일의 효율을 높이기)</li>
        <li>Coder에서 Developer로 성장</li>
        <li>기업목적에 따른 기본적 CS지식이 필요</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="1-소프트웨어-공학">1. 소프트웨어 공학</h2>

<blockquote>
  <ul>
    <li><strong>소프트웨어 개발 생명주기</strong>
      <ul>
        <li>계획 단계에서 유지보수 단계에 이르기까지 일어나는 일련의 절차</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>정의단계
What                     타당성 분석 -&gt; 개발 계획 -&gt; 요구사항 분석          - 사용자의 요구사항 확인 및 타당성 검토
(계획, 요구분석)                                                          - 개발에 필요한 요구사항 명세화

개발 단계
How                      설계 -&gt; 개발 -&gt; 테스트                            - 코딩을 통한 프로그램 개발
(설계, 개발, 테스트)                                                       - 단위/통합/시스템/인수/설치 테스트

유지보수 단계
Change                   유지보수 -&gt; 폐기                                  - 시스템 운영 및 운영 중 발생한 문제점들에 대한 유지보수
(적용, 예방, 폐기)                                                         - 새로운 시스템 개발로 인한 기존 시스템 폐기
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>소프트웨어 개발 프로세스 정의</strong>
      <ul>
        <li>작업(task)순서의 집합 + 제약조건(일정, 예산, 자원)을 포함하는 일련의 활동</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>좁은의미 : 사용자의 요구사항을 SW로 구현하기 위한 절차, 과정

넓은의미 : 사용자의 목적을 이루기 위한 기획, 프로젝트 관리 등을 포함한 절차, 과정, 방법

소프트웨어 개발 7단계 : 계획 - 요구분석 - 설계 - 구현 - 테스트 - 반영 - 유지보수
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>소프트웨어 프로세스 모델(1)</strong>
      <ul>
        <li>폭포수 모델</li>
        <li>프로토타입 모델</li>
        <li>나선형 모델</li>
        <li>통합프로세스 모델</li>
      </ul>
    </li>
    <li><strong>소프트웨어 프로세스 모델(2)</strong>
      <ul>
        <li>애자일 프로세스 모델
          <ul>
            <li>고객의 요구에 민첩하게 대응하고 그때그때 주어지는 문제를 풀어나가는 방법론</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>소프트웨어 아키텍처 정의</strong>
      <blockquote>
        <ul>
          <li><strong>소프트웨어 아키텍처</strong>
            <ul>
              <li>소프트웨어에 대한 전체적인 구조</li>
              <li>소프트웨어를 이루고 있는 여러 구성요소(서브시스템, 컴포넌트)</li>
              <li>구성 요소들의 인터페이스 간의 상호작용 정의</li>
              <li>시스템 설계와 개발 시 적용되는 원칙과 지침</li>
            </ul>
          </li>
          <li><strong>소프트웨어 아키텍처의 구성</strong>
            <ul>
              <li>구성 요소</li>
              <li>구성 요소들 사이의 관계</li>
              <li>구성 요소들이 외부에 드러내는 속성</li>
              <li>구성 요소들과 주변 환경 사이의 관계</li>
              <li>구성 요소들이 제공하는 인터페이스</li>
              <li>구성 요소들의 협력 및 조립방법</li>
            </ul>
          </li>
        </ul>
      </blockquote>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>아키텍처 모델(1)</strong>
      <blockquote>
        <ul>
          <li><strong>데이터 중심형 모델</strong>
            <ul>
              <li>주요 데이터가 repository에서 중앙 관리</li>
              <li>repository와 여기에 접근하는 서브시스템으로 구성</li>
              <li>데이터가 한군데에 모여 있기 때문에 데이터를 모순되지 않고 일관성 있게 관리 가능</li>
              <li>새로운 서브시스템의 추가 용이</li>
              <li>repository의 병목 현상 발생 가능</li>
              <li>서브시스템과 repository 사이의 강한 결합 - repository 변경 시 서브시스템에 영향을 줌</li>
            </ul>
          </li>
        </ul>
      </blockquote>
    </li>
    <li><strong>아키텍처 모델(2)</strong>
      <blockquote>
        <ul>
          <li><strong>Client-Server 모델</strong>
            <ul>
              <li>네트워크를 이용하는 분산 시스템 형태</li>
              <li>데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용</li>
              <li>서버 :클라이언트(서브시스템)에 서비스 제공</li>
              <li>클라이언트 : 서버가 제공하는 서비스를 요청(호출)하는 서브시스템</li>
            </ul>
          </li>
        </ul>
      </blockquote>
    </li>
    <li><strong>아키텍처 모델(3)</strong>
      <blockquote>
        <ul>
          <li><strong>Layering 모델</strong>
            <ul>
              <li>기능을 몇 개의 계층으로 나누어 배치</li>
              <li>구성 : 하위 계층은 서버, 상위 계층은 클라이언트 역할</li>
            </ul>
          </li>
        </ul>
      </blockquote>
    </li>
    <li><strong>아키텍처 모델(4)</strong>
      <blockquote>
        <ul>
          <li>Model/View/Controller 모델
            <ul>
              <li>같은 모델의 서브 시스템에 대하여 여러 뷰 서브시스템을 필요로 하는 시스템에 적합</li>
              <li>장점
                <ul>
                  <li>데이터를 화면에 표현(뷰)하는 디자인과 로직(모델)을 분리함으로써 느슨한 결합 가능</li>
                  <li>구조 변경 요청 시 수정 용이</li>
                </ul>
              </li>
              <li>단점
                <ul>
                  <li>기본 기능 설계로 인한 클래스 수의 증가로 복잡도 증가</li>
                  <li>속도가 중요한 프로젝트에 부적합</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </blockquote>
    </li>
  </ul>
</blockquote>

<h3 id="소프트웨어-공학-기출문제">소프트웨어 공학 기출문제</h3>

<blockquote>
  <ul>
    <li><strong>소프트웨어 위기에 대해서 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 소프트웨어 위기에 대한 정형화된 답보다는 실제 사례를 들어서 설명하자

예시 : 2000년대 초반 많은 사람들이 이용했던 싸이월드가 이제는 사용되지 않는 것은
서비스에 대한 다양한 수요를 예측하지 못하고 반영하지 못한 대표적인 사례로 생각합니다.
소프트웨어 위기는 소프트웨어가 더 이상 사용자들의 요구를 충족할 수 없어서 사용자들로부터 외면받는 것을 이야기합니다.

* 소프트웨어 위기란?
소프트웨어 공학 초기에 사용되던 용어로 정돈된 주제가 되기 이전에 사용되었다.
이 용어는 급격한 컴퓨터 계산 용량과 문제의 복잡성이 급격히 증가함에 따라 발생하는 것을 서술하기 위하여 사용되었다.
본질적으로, 이는 정확하고 이해할 수 있고, 검증 가능한 컴퓨터 프로그램을 작성하는 것이 얼마나 어려운가를 뜻한다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>소프트웨어 공학이 필요한 이유는 무엇인지 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 소프트웨어 공학의 적용에 대해서 예시를 들어 설명하자, 소프트웨어들을 비교하면 설명이 쉽다.

예시 : 소프트웨어 공학은 소프트웨어의 개발, 운용, 유지보수 등의 단계를 체계적으로 다루는 학문이라고 합니다.
제가 생각하는 소프트웨어 공학은 **에서 진행했던 프로젝트에서 단기간에 원하는 목적으로 이루기 위해서
소프트웨어를 기획하고, 설계하고, 구현하고, 테스트하고, 보완하는 과정을 걸쳤는데
이 과정을 체계적으로 정리하고 이를 공유하는 과정이 소프트웨어 공학이 아닌가 생각합니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>소프트웨어 개발 경험과 소프트웨어 개발 시 적용한 개발 방법론이 있다면 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 소프트웨어 개발의 경험을 생각해보면 1개 이상의 방법론이 적용된 것을 알 수 있다.
개발 시 고려한 개발방법론이 없더라도 개발했던 경험을 복기해서 가장 적절한 개발방법론을 적용하자

예시 : **에서 프로젝트를 진행하면서 린 개발 방법을 찾아서 적용했습니다.
린 개발 방법론의 가장 큰 특징인 낭비요소를 제거하고, 지속적인 개선과 수행속도의 향상과 더불어 품질을 효과적으로 개선하는 것인데 **의 프로젝트의 기간이 짧아 어려움을 겪었습니다.
초기 서비스에 대한 방향성을 자신할 수 없어서 지속적으로 서비스를 향상할 수 있는 방법론이 필요했고,
그래서 린 개발 방법론을 찾아서 적용하게 되었습니다.
경험이 많지 않아서 린 개발 방법론의 적용이 쉽지는 않았지만, 단기간에 프로젝트를 완성하는데는 도움이 되었습니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>소프트웨어 프로젝트 진행 경험에 대해서 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 소프트웨어 진행 경험은 '무엇을 개발하였다' 라기 보단 '어떻게 개발하였다'라고 말하는 것이 필요하다.
그 안에는 개발방법론이나 소프트웨어 아키텍처를 들어서 설명하는 것이 필요하다.

예시 : 대학교 졸업을 위한 프로젝트로 빅데이터를 통한 관광정보 제공 서비스를 개발하였습니다.
관광정보에 대한 빅데이터를 수집하고 분석하여 이용자의 특성(연령, 성별, 지역)에 맞추어 관광정보를 제공하는 서비스를 개발하였습니다.
린(Lean)개발 방법론이 짦은 기간 개발에 적용하기에 적절하다고 하여 적용하였습니다.
</code></pre></div></div>

<h2 id="2-프로그래밍">2. 프로그래밍</h2>

<blockquote>
  <ul>
    <li><strong>객체지향(1)</strong>
      <ul>
        <li><strong>객체지향 개요</strong>
          <ul>
            <li>소프트웨어 객체는 현실 세계의 객체를 필드와 메서드로 모델링한 것</li>
            <li>소프트웨어 객체는 상태를 필드(Field)로 정의하고, 동작을 메서드(Method)로 정의</li>
            <li>필드는 객체 내부에 ‘선언된 변수’를 의미하고, 메서드는 객체 내부에 ‘정의된 동작’을 의미함</li>
          </ul>
        </li>
        <li><strong>절차지향</strong>
          <ul>
            <li>일련의 동작을 순서에 맞추어 단계적으로 실행하도록 명령어를 나열</li>
            <li>데이터를 정의하는 방법보다는 명령어의 순서와 흐름에 중점</li>
          </ul>
        </li>
        <li><strong>객체지향</strong>
          <ul>
            <li>현실 세계를 객체 단위로 프로그래밍하여, 객체는 필드(데이터)와 메서드(코드)를 하나로 묶어 표현</li>
            <li>프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소트프웨어 개발에 많이 사용</li>
            <li>소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>객체지향(2)</strong>
      <ul>
        <li>캡슐화(정보은닉)
          <ul>
            <li>필드와 메서드를 하나의 캡슐처럼 포장해 세부 내용을 외부에서 알 수 없도록 감추는 것</li>
          </ul>
        </li>
        <li>상속
          <ul>
            <li>상위 객체를 상속받은 하위 객체가 상위 객체의 메서드와 필드를 사용하는 것</li>
          </ul>
        </li>
        <li>다형성
          <ul>
            <li>대입되는 객체에 따라서 메서드를 다르게 동작하도록 구현하는 기술</li>
            <li>실행 도중 동일한 이름의 다양한 구현체 중에서 메서드를 선택 가능</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>Jave의 목적</strong>
      <ul>
        <li>Write Once Run Anywhere</li>
        <li>Java는 platform independent하게 동작</li>
        <li>Super Computer부터 Smart Card까지 한번 작성된 코드는 코드의 수정이 없이, 코드의 재컴파일 없이 실행가능</li>
      </ul>
    </li>
    <li><strong>Java 언어의 개발 목적</strong>
      <ul>
        <li>Program 개발을 쉽게 하였다</li>
        <li>Compile환경이 아니라, Interpreted 환경이다.</li>
        <li>한 개 이상의 thread를 사용할 수 있다.</li>
        <li>동적으로 program을 변화시킬 수 있다.</li>
        <li>Code 자체적으로 security를 보장해준다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>JVM(Java Virtual Machine)
      <ul>
        <li>JVM은 System 마다, 그리고 운영체제 마다 다름</li>
      </ul>
    </li>
    <li>Garbage Collection (GC)
      <ul>
        <li>Java는 프로그래머에게 메모리를 release(최적화)하게 하는 책임을 지우지 않음</li>
        <li>GC는 Java Program의 life cycle 동안 자동적으로 동작하여 메모리의 부족을 제거</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>Process의 개념</strong>
      <ul>
        <li>프로그램 - 저장장치에 저장되어 있는 정적인 상태</li>
        <li>프로세스 - 실행을 위해 메모리에 올라온 동적인 상태</li>
        <li>프로그램이 프로세스가 된다는 것은 운영체제로 부터 프로세스 제어 블록을 얻는다는 뜻</li>
        <li>프로세스가 종료된다는 것은 해당 프로세스 제어 블록이 폐기된다는 뜻</li>
      </ul>
    </li>
    <li><strong>Thread의 개념</strong>
      <ul>
        <li>프로세스에서 실행 제어만 분리한 실행 단위(프로세스 실행부)</li>
        <li>프로세서를 사용하는 기본 단위이며, 명령어를 독립적으로 실행할 수 있는 하나의 제어 흐름</li>
        <li>같은 그룹의 스레드는 코드, 주소 공간, 운영체제의 자원(파일, 신호) 등을 공유</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법</li>
    <li>멀티 프로세싱 : CPU를 여러 개 사용하여 여러 개의 Thread를 동시에 처리하는 작업 환경</li>
    <li>CPU 멀티 Thread : 하드웨어적인 방법으로 하나의 CPU에서 여러 Thread를 동시에 처리하는 병렬 처리 기법</li>
    <li>멀티 Thread : 운영체제가 소프트웨어적으로 프로세스를 작은 단위의 Thread로 분할하여 운영하는 기법</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>병행성(concurrency) 문제</strong>
      <ul>
        <li>두 개 이상의 Thread가 어떤 객체에 있는 하나의 데이터에 접근하게 되는 경우</li>
        <li>서로 다른 두 스택에서 실행되는 메소드가 객체에 있는 동일한 객체에 대한 getter/setter 메소드를 호출하게 되는 경우</li>
        <li>Thread는 자신이 잠시 중단된 적이(interrupt) 있다는 것을 기억할 수가 없음</li>
      </ul>
    </li>
    <li><strong>Thread에서의 동기화</strong>
      <ul>
        <li>다중 Thread 환경에서 한번에 하나의 쓰레드 만이 공유 데이터를 접근할 수 있도록 제어하는 것</li>
        <li>여러 Thread가 동시에 실행되는 다중 Thread에서 데이터를 공유하기 위해서는 어떤 Thread가 다른 Thread의 상태와 행동 들을 고려</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>형상관리 (1)</strong>
      <ul>
        <li>정의 : SW개발 및 유지보수 과정에서 발생하는 변경 사항들을 관리하기 위해 개발된 일련의 활동 (소프트웨어 개발의 전 단계에 적용되는 활동으로, 유지보수 단계에서 수행)</li>
        <li>목적 : 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증함</li>
      </ul>
    </li>
    <li>주요 기능 : 버전관리, 리비전 관리, 소스관리, 소스코드 관리</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>형상관리(2)</strong>
      <ul>
        <li>종류 : SVN, git, Mercurial, Bazaar 등, 주로 SVN과 git 사용</li>
        <li>SVN : 소규모 시스템 적합</li>
        <li>git : 대규모 시스템 적합</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>빌드도구</strong>
      <ul>
        <li>소스코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 생성하는 프로그램(프로젝트를 진행하며 시간이 지남에 따라 라이브러리의 버전을 자동으로 동기화)</li>
        <li>ANT : XML 기반 빌드 스크립트 개발, 명확한 빌드 절차 정의가 필요</li>
        <li>MAVEN : 프로젝트에 필요한 모든 종속성(Dependency)를 리스트의 형태로 관리, 전자정부 프레임원크</li>
        <li>Gradle : ANT와 MAVEN의 단점을 보완한 오픈소스 기반의 Build 자동화 도구, 안드로이드 스튜디오</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="프로그래밍-기출문제">프로그래밍 기출문제</h3>

<blockquote>
  <ul>
    <li><strong>JAVA와 C의 차이를 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 절차지향 vs 객체지향 / 하드웨어 최적화 vs 하드웨어 독립적 등의 여러 관점에서 비교 설명하자.

예시 : C언어는 아두이노를 활용한 IoT 수업에 사용하였었고, 자바는 안드로이드 어플 제작할 때 사용했습니다.
하드웨어를 제어할 때 C언어가 적합한 언어라고 생각합니다.
자바를 사용할 때에는 다양한 유형의 데이터를 정의와 데이터 간의 관계를 설정, 사용자의 동작을 정의, 구현하는 과정을 거쳤는데,
실제 업무와 유사하여 규모 있는 프로젝트를 개발할 때 자바가 적합했던 언어였습니다.

또한, 개발 환경에 있어서도 윈도우 환경에서 개발한 프로그램을 그대로 리눅스 기반으로 알고 있는 안드로이드 환경에서 동작하는 것을 통해서
하드웨어 독립적으로 운영이 가능한 것이 C언어와 차이라고 할 수 있습니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>JVM 가비지컬렉션 동작 과정을 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 가비지 컬렉션은 메모리와 연관된다.
소프트웨어 개발 경험 중 메모리 부족 현상을 겪은 경험이 있으면, 경험을 토대로 설명하자.

예시 : 가비지컬렉션은 JVM에서 메모리 관리를 하는 방법으로 더 이상 사용하지 않는 메모리에 대해서 수집해서 스스로 동작해서 사용을 해제하는 기능입니다.
C언어를 사용할 때에는 코드에서 메모리의 할당과 함께 해제를 같이 처리해주었는데,
자바에서는 직접 해제하는 기능은 없었고, 사용하지 않는 메모리에 대해서는 메모리의 참조변수에 null을 대입해서
참조변수와 연결된 메모리가 더 이상 사용하지 않음을 JVM에 알려주는 것만으로 메모리해제 요청을 하였습니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>JAVA에 적용된 OOP에 대해서 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 실제 작업한 사례를 통해서 설명하자. 설계한 객체와 클래스를 비교해서 설명

예시 : [관광정보 제공 서비스 프로젝트 개발]
* 서비스에서 제공되는 주요 정보인 관광지/ 식당/ 호텔 등을 객체로 정의
* 관광지를 모델링 한 것을 객체/ 모델링한 관광지를 자바의 코드로 정의한 것은 클래스
* 각 클래스에 실제 관광지 값을 대입하여 메모리에 올린 것은 인스턴스
 - 주요 모델링한 정보 : 관광지 이름/ 관광지 주소/ 관광지 위경도/ 관광지 길 탐색 기능
 - 클래스에서는 관광지의 이름은 PLACE_NAME의 String 타입으로 정의
 - 관광지 위/경도는 PLACE_LAT, PLACE_LNG의 double 타입으로 정의
 - 길을 탐색하는 기능은 navigate 라는 메소드로 구현
 - 객체는 실 세계를 모델링 한 것이면 클래스는 모델링 한 것을 실제 코드로 구현한 것
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>형상관리 활용 경험을 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 형상관리 경험이 있다면, 형상관리 경험을 이야기,
경험이 없다면, 회사에서 제공하는 서비스나 소프트웨어를 대상으로 필요성을 설명

예시 : 저는 4명의 팀원과 함께 프로젝트를 진행하였습니다.
이중에 2명은 라이브러리를 개발하고 1명은 서버 측을 1명은 사용자 화면 및 동작을 개발하였습니다.
동시에 같이 개발하면서 서로의 코드를 참조하고, 확인을 위해 SVN을 이용해서 형상관리를 진행하였습니다.

SVN을 활용한 형상관리를 하면서 코드 작업 후 업데이트할 때 오류가 있는 코드를 업데이트 하거나,
업데이트 시 정확한 코멘트를 남기지 않아서 애를 먹었던 경험도 있습니다.
초반에는 혼란을 겪었지만, 수시로 베이스 라인 변경과 통제를 통해 형상관리 프로젝트를 체계적으로 관리할 수 있었습니다.
</code></pre></div></div>

<h2 id="3-웹모바일-서비스">3. 웹&amp;모바일 서비스</h2>

<blockquote>
  <ul>
    <li><strong>웹 서비스(1)</strong>
      <ul>
        <li><em>기존의 웹</em>
          <ul>
            <li>HTTP, HTML, URL과 같은 기술을 통해 인터넷에 분산되어 있는 정보 자원들에 대하여 표준화된 접근과 정보 표현 방법</li>
          </ul>
        </li>
        <li><em>웹 서비스</em>
          <ul>
            <li>‘XML’과 ‘인터넷 프로토콜’을 통해 ‘표준화된 방식으로 상호작용’</li>
            <li>새로운 기술이라기 보다는 컴포넌트, 인터넷, XML등의 기술을 새로운 개념으로 적용하는 방법론</li>
            <li>기본적인 표준 인프라가 구축되어 있는 경우에는 그것을 바탕으로 무궁무진한 활용이 가능</li>
          </ul>
        </li>
        <li><em>웹서비스의 특징</em>
          <ul>
            <li>플랫폼에 독립적</li>
            <li>동적인 기능(Dynamic Function)</li>
            <li>비용 효율적</li>
            <li>기존 시스템(Legacy System)에 적용</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>웹 서비스 동작 흐름</strong></li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>웹 서버</strong></li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>정적페이지와 동적 웹페이지</strong>
      <ul>
        <li><em>정적 웹페이지</em>
          <ul>
            <li>컴퓨터에 저장된 텍스트 파일 그대로 보는것</li>
            <li>HTML</li>
          </ul>
        </li>
        <li><em>동적 웹페이지</em>
          <ul>
            <li>저장된 내용을 다른 변수로 가공 처리하여 보는 것</li>
            <li>PHP, ASP, JSP</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>클라이언트 - 서버</strong>
      <ul>
        <li><em>클라이언트-서버 모델 기반</em>
          <ul>
            <li>서버 : 서비스 정보들을 보관하고 이를 제공해주는 컴퓨터</li>
            <li>클라이언트 : 사용자가 서버에서 제공하는 정보를 받는 컴퓨터</li>
          </ul>
        </li>
        <li><em>서버 프로그램</em>
          <ul>
            <li>호스트 컴퓨터에 서버 역할을 수행</li>
            <li>아파치 또는 IIS등 웹 서버 프로그램</li>
            <li>FTP 서비스의 경우 FTP 서버 프로그램</li>
          </ul>
        </li>
        <li><em>클라이언트 프로그램</em>
          <ul>
            <li>사용자가 서버에 접속하여 서비스 이용</li>
            <li>Chrome, Explorer와 같은 웹 브라우저 프로그램/ FTP 클라이언트 프로그램 필요</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>웹 서버의 구성 예시</strong>
      <ul>
        <li>윈도우 서버 환경 구축 예시
          <ul>
            <li>Window Server + TOMCAT + JSP + (Oracle)</li>
          </ul>
        </li>
        <li>리눅스 서버 환경 구축 예시
          <ul>
            <li>리눅스 Server + APACHE + TOMCAT + JSP + (My SQL)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>모바일 서비스</strong>
      <ul>
        <li><em>시스템 소프트웨어</em>
          <ul>
            <li>모바일 운영체제(OS) : 모바일 단말기용 시스템 소프트웨어</li>
          </ul>
        </li>
        <li><em>애플리케이션</em>
          <ul>
            <li>다운로드 애플리케이션 (사용자가 직접 다운로드 하여 실행)</li>
            <li>모바일 웹 브라우저 (모바일 기기에서 실행되는 웹브라우저)</li>
            <li>내장 애플리케이션 (모바일 운영체제에 직접 구현된 프로그램)</li>
          </ul>
        </li>
        <li><em>모바일 운영체제(OS)</em>
          <ul>
            <li>휴대폰에서 PC의 운영체제와 같은 역할을 수행</li>
            <li>스마트폰의 프로세서, 메모리, 화면 등의 하드웨어를 관리하고 운영</li>
            <li>모바일 애플리케이션이 실행되는 소프트웨어 플랫폼 역할</li>
            <li>공개형(Open) 모바일 운영체제가 대세</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>모바일 앱 vs 모바일 웹 vs 하이브리드 앱</strong>
      <ul>
        <li>모바일 앱
          <ul>
            <li>디바이스에 최적화</li>
            <li>플랫폼 전용 언어로 개발함</li>
            <li>안드로이드 -java / Kotlin</li>
            <li>아이폰 - Object-C / Swift</li>
          </ul>
        </li>
        <li>하이브리드 앱
          <ul>
            <li>유지보수의 편의성</li>
            <li>하이브리드 앱 전용 언어로 개발함</li>
            <li>React Native</li>
            <li>Flutter</li>
            <li>XAMARIN</li>
            <li>IONIC</li>
          </ul>
        </li>
        <li>모바일 웹(앱)
          <ul>
            <li>모바일 웹가 모바일 앱의 호환</li>
            <li>유지보수의 편의성</li>
            <li>모바일 웹을 앱으로 제젝</li>
            <li>HTML5 / CSS3 기반의 모바일 웹 개발 후 WebView에서 제공</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="웹모바일-기출문제">웹&amp;모바일 기출문제</h3>

<blockquote>
  <ul>
    <li><strong>AJAX가 무엇인지 예를 들어서 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 기술적인 접근보다는 서비스를 예시로 설명하자. 쉽게 접할 수 있는 사례를 찾아서 설명한다.

예시 : AJAX는 비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법으로
주로 회원가입 시 아이디 중복검사나 비밀번호 유효성 검사 등에 사용합니다.
웹 페이지는 화면을 이동할 때 마다 화면의 컨텐츠를 다시 가져와서 표시하는데,
웹 서비스 중에는 현재의 화면을 그대로 둔 채로 특정 영역의 데이터를 추가/ 삭제/ 변경 등의 기능을 쓸 때 AJAX을 활용합니다.
AJAX를 사용하면 화면 전체를 재 로딩함으로 발생하는 트래픽의 증가도 필요한 영역의 적은 데이터만 통신함으로 트래픽을 줄이는 효과도 있습니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>웹 브라우저 검색창에서 키워드를 입력하면 결과가 나오는 과정을 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 웹 서버의 흐름을 생각하고, 키워드를 입력 받아 웹서버에서 처리해서 반환하는 과정을 도식화해서 설명

예시 : 웹 브라우저에 검색 창에 키워드를 입력하면 웹 사이트의 검색창에 정의된 form의 method(get/post)의 방식으로 action에 기록된 서버로 검색 키워드를 전송하게 됩니다.
서버는 검색 키워드를 전송 받으면 검색 키워드와 관련하여 구현된 비즈니스 로직을 실행시키고,
그 결과를 HTML로 구성하여 다시 웹 브라우저로 전송합니다.
웹 브라우저는 서버로 부터 새로운 HTML이 오면 결과를 화면에 보여지게 합니다.
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="CS" /><category term="CS" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (연관관계 매핑 기초, 다양한 연관관계 매핑)]</title><link href="http://localhost:4000/jpa/JPA_Basic-2/" rel="alternate" type="text/html" title="[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (연관관계 매핑 기초, 다양한 연관관계 매핑)]" /><published>2022-06-21T00:00:00+09:00</published><updated>2022-06-21T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA_Basic%202</id><content type="html" xml:base="http://localhost:4000/jpa/JPA_Basic-2/"><![CDATA[<p><br /></p>

<p>##</p>]]></content><author><name>김경호</name></author><category term="JPA" /><category term="JPA" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[CS 03. 기본이론]</title><link href="http://localhost:4000/cs/CS_Basic_3/" rel="alternate" type="text/html" title="[CS 03. 기본이론]" /><published>2022-06-21T00:00:00+09:00</published><updated>2022-06-21T00:00:00+09:00</updated><id>http://localhost:4000/cs/CS_Basic_3</id><content type="html" xml:base="http://localhost:4000/cs/CS_Basic_3/"><![CDATA[<p><br /></p>

<h2 id="1-보안">1. 보안</h2>

<blockquote>
  <ul>
    <li><strong>서비스 거부 공격(DoS)</strong>
      <ul>
        <li><strong>취약점 공격형</strong>
          <ul>
            <li>Boink, Bonk, TearDrop 공격</li>
            <li>프로토콜의 오류 제어 로직을 악용해 시스템 자원을 고갈시키는 방식</li>
          </ul>
        </li>
        <li><strong>랜드 공격</strong>
          <ul>
            <li>패킷을 전송할 때 출발지 IP 주소와 목적지 IP 주소의 값을 똑같이 만들어서 공격 대상에게 보내는 것</li>
          </ul>
        </li>
        <li><strong>자원 고갈 공격형</strong>
          <ul>
            <li>죽음의 핑 공격 - 시스템을 파괴하는 데 가장 흔히 쓰인 초기의 DoS 공격</li>
            <li>네트워크에서 패킷을 전송하기 적당한 크기로 잘라서 보내는 특성을 이용한 공격</li>
          </ul>
        </li>
        <li><strong>SYN 플러딩 공격</strong>
          <ul>
            <li>네트워크에서 서비스를 제공하는 시스템에 걸려있는 사용자 수 제한을 이용한 공격</li>
            <li>존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 제공받지 못하게 함.</li>
          </ul>
        </li>
        <li><strong>HTTP GET 플러딩 공격</strong>
          <ul>
            <li>공격 대상 시스템에 TCP 3-웨이 핸드셰이킹 과정으로 정상 접속한 뒤</li>
            <li>HTTP의 GET 메소드로 특정 페이지를 무한대로 실행하는 공격</li>
          </ul>
        </li>
        <li><strong>스머프 공격</strong>
          <ul>
            <li>ICMP 패킷과 네트워크에 존재하는 임의의 시스템으로 패킷을 확장해</li>
            <li>서비스 거부 공격을 수행하는 것으로, 네트워크 공격에 많이 사용힘.</li>
          </ul>
        </li>
        <li><strong>메일 폭탄 공격</strong>
          <ul>
            <li>메일이 폭주하여 디스크 공간을 가득 채우면 받아야 할 메일을 받을 수 없음</li>
            <li>스팸 메일을 서비스 거부 공격으로 분류</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>분산 서비스 거부 공격(DDoS)</strong>
      <ul>
        <li><strong>분산 서비스 거부 공격의 기본 구성</strong>
          <ul>
            <li>공격자(attacker) : 공격을 주도하는 해커 컴퓨터</li>
            <li>마스터(master) : 공격자에게 직접 명령을 받는 시스템으로 여러 대의 에이전트를 관리</li>
            <li>핸들러(handler) 프로그램 : 마스터 시스템의 역할을 수행하는 프로그램</li>
            <li>에이전트(agent) : 직접 공격을 가하는 시스템</li>
            <li>데몬(daemon) 프로그램 : 에이전트 시스템의 역할을 수행하는 프로그램</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>스니핑</strong>
      <ul>
        <li><strong>스니핑 공격</strong>
          <ul>
            <li>데이터 속에서 정보를 찾는 것으로 공격 시 아무것도 하지 않고 조용히 있는 것만으로도 충분하여 수동적 공격이라 함.</li>
            <li>스니핑 공격자는 가지지 말아야 할 정보까지 모두 볼 수 있어야 하므로 랜 카드의 프러미스큐어스(promiscuous) 모드를 이용해 데이터 링크 계층과 네트워크 계층의 정보를 이용한 필터링을 해제함</li>
          </ul>
        </li>
        <li><strong>스니핑 공격의 종류</strong>
          <ul>
            <li><strong>스위치 재밍 공격</strong>
              <ul>
                <li>스위치가 MAC 주소 테이블을 기반으로 포트에 패킷을 스위칭할 때 정상적인 스위칭 기능을 마비시키는 공격</li>
                <li>고가의 스위치는 MAC 테이블의 캐시와 연산자가 쓰는 캐시가 독립적으로 나뉘어 있어 스위치 재밍 공격이 통하지 않음</li>
              </ul>
            </li>
            <li><strong>SPAN 포트 태밍 공격</strong>
              <ul>
                <li>스위치 포트 미러링(port mirroring) 기능을 이용한 공격</li>
              </ul>
            </li>
            <li><strong>포트 미러링</strong>
              <ul>
                <li>각 포트에 전송되는 데이터를 미러링 하는 포트에도 똑같이 보내는 것으로 침입 탐지 시스템이나</li>
                <li>네트워크 모니터링 또는 로그 시스템을 설치할 때 많이 사용</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>스푸핑</strong>
      <ul>
        <li><strong>스푸핑 공격의 종류</strong>
          <ul>
            <li><strong>ARP 스푸핑 공격</strong>
              <ul>
                <li>ARP 스푸핑은 MAC 주소를 속이는 것</li>
                <li>로컬에서 통신하는 서버와 클라이언트의 IP 주소에 대한 데이터 링크 계층의 MAC 주소를 공격자의 MAC 주소로 속여 클라이언트에서 서버로 가는 패킷이나 서버에서 클라이언트로 가는 패킷이 공격자에게 향하게 하여 랜의 통신 흐름을 왜곡하는 공격</li>
              </ul>
            </li>
            <li><strong>IP 스푸핑 공격</strong>
              <ul>
                <li>트러스트 관계(신뢰 관계)를 맺고 있는 서버와 클라이언트를 확인한 후 클라이언트에 서비스 거부 공격을 하여 연결을 끊은 뒤 클라이언트의 IP 주소를 확보한 공격자는 실제 클라이언트처럼 패스워드 없이 서버에 접근하는 기법</li>
              </ul>
            </li>
            <li><strong>ICMP 리다이렉트 공격</strong>
              <ul>
                <li>네트워크 계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라고 알려 패킷의 흐름을 바꾸는 공격</li>
              </ul>
            </li>
            <li><strong>DNS 스푸핑 공격</strong>
              <ul>
                <li>실제 DNS 서버보다 빨리 DNS response 패킷을 보내어 공격 대상이 잘못된 IP 주소로 웹 접속을 하도록 유도하는 공격</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>세션하이재킹</strong>
      <ul>
        <li><strong>세션하이재킹의 정의</strong>
          <ul>
            <li>세션 가로채기라는 뜻</li>
            <li>세션은 사용자와 컴퓨터 또는 두 컴퓨터 간의 활성화된 상태</li>
            <li>세션 하이재킹은 두 시스템 간의 연결이 활성화된 상태, 즉 로그인된 상태를 가로채는 것</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>보안 프로토콜</strong>
      <ul>
        <li><strong>SSL</strong>
          <ul>
            <li>SSL은 방대한 인터넷 상거래의 안전을 위해 사용되는 프로토콜</li>
          </ul>
        </li>
        <li><strong>SSL 세션 vs 접속</strong>
          <ul>
            <li>SSL은 HTTP 1.0과 함께 사용되도록 설계</li>
            <li>HTTP 1.0은 보통 다수 접속을 병렬로 유지</li>
            <li>SSL 세션 설정은 비용이 소요</li>
            <li>공개키 연산이 필요</li>
            <li>SSL 세션이 이미 존재할 때 효율적으로 새로운 SSL 접속을 구현하는 프로토콜 포함</li>
          </ul>
        </li>
        <li><strong>IPSec</strong>
          <ul>
            <li>IPSec은 네트워크 계층에 존재</li>
            <li>IPSec은 응용프로그램으로부터 자유</li>
            <li>IPSec은 복잡한 프로토콜
              <ul>
                <li>“너무 과도하게 기술적”</li>
                <li>별로 필요하지 않은 기능이 과도하게 많음.</li>
              </ul>
            </li>
            <li>결함 보유
              <ul>
                <li>몇 가지 심각한 보안상 결함을 보유</li>
              </ul>
            </li>
            <li>상호운용성에 심각한 도전
              <ul>
                <li>표준을 갖고 있는 목적에 부합하지 않음!</li>
              </ul>
            </li>
            <li>복잡성(반복적으로 강조)</li>
          </ul>
        </li>
        <li><strong>SSL vs IPSec 비교</strong>
          <ul>
            <li><strong>IPSec</strong>
              <ul>
                <li>네트워크 계층에 존재(OS의 일부)</li>
                <li>암호화, 무결성, 인증 등을 포함하고 있음.</li>
                <li>과도하게 복잡(심각한 결말 포함)</li>
              </ul>
            </li>
            <li><strong>SSL(IEEE 표준 TLS)</strong>
              <ul>
                <li>소켓 계층(Session/Presentation/Application)(사용자 영역의 일부)</li>
                <li>암호화, 무결성, 인증 등을 포함하고 있음.</li>
                <li>간단한 규격</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="2-4차-산업혁명-관련-기술">2. 4차 산업혁명 관련 기술</h2>

<blockquote>
  <ul>
    <li><strong>4차 산업혁명</strong>
      <ul>
        <li><strong>4차 산업혁명이란 무엇인가</strong>
          <ul>
            <li>파괴적 기술과 역사적 산업혁명의 전개</li>
            <li><strong>AI 기술</strong>을 <strong>핵심동인</strong>으로 상품,서비스의 <strong>생산,유통,소비 전 과정</strong>에서 모든것이 <strong>연결</strong>되고 <strong>지능화</strong></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>4차 산업혁명의 주요기술</strong>
      <ul>
        <li><strong>기술 맵</strong>
          <ul>
            <li><strong>6대 디지털화 기술</strong>
              <ul>
                <li>IoT 사물인터넷 : 사물들의 초연결</li>
                <li>LBS : 공간정보의 디지털화</li>
                <li>클라우드 : 빅데이터의 공간</li>
                <li>빅데이터 : 가치 있는 거대한 데이터</li>
                <li>IoB(웨어러블) : 인간과 스마트기기의 융합</li>
                <li>플랫폼 : 인간의 융합 촉진 연결망</li>
              </ul>
            </li>
            <li><strong>6대 아날로그화 기술</strong>
              <ul>
                <li>서비스 디자인 : 인간을 위한 서비스 제공</li>
                <li>
                  <table>
                    <tbody>
                      <tr>
                        <td>3D 프린터</td>
                        <td>로봇 : 가상의 정보를 물질화</td>
                      </tr>
                    </tbody>
                  </table>
                </li>
                <li>증강 가상 현실 : 가상정보를 현실 경험화</li>
                <li>블록체인 핀테크 : 분산화된 신뢰와 거래</li>
                <li>게임화 : O2O의 동기부여</li>
                <li>플랫폼 : 반복되는 공통역량의 공유</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>IoT-Bigdata-AI</strong>
      <ul>
        <li><strong>기술 맵</strong>
          <ul>
            <li><strong>개념</strong>
              <ul>
                <li>
                  <table>
                    <tbody>
                      <tr>
                        <td>IoT</td>
                        <td>Mobile : 모든 기계,인간으로부터 데이터 수집</td>
                      </tr>
                    </tbody>
                  </table>
                </li>
                <li>Cloud &amp; Big Data : 정보처리능력 고도화로 데이터 축적,분석 강화</li>
                <li>
                  <table>
                    <tbody>
                      <tr>
                        <td>A.I.</td>
                        <td>새로운 가치 : 기계가 데이터로 빠르게 학습하여 새로운 지능정보 가치 창출</td>
                      </tr>
                    </tbody>
                  </table>
                </li>
              </ul>
            </li>
            <li><strong>특징</strong> -만물의 데이터화
              <ul>
                <li>실시간 반응</li>
                <li>자율 진화</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>적용 사례</strong> : 아마존
          <ul>
            <li>데이터 수집(IoT) : 고객의 구매정보 데이터 수집</li>
            <li>저장 &amp; 분석(CLOUD/ BIG DATA) : 구매 패턴 빅 데이터화</li>
            <li>가치창출(A.I) : 인공지능으로 예상 구매 물품 예상</li>
            <li>
              <table>
                <tbody>
                  <tr>
                    <td>최적화(기술융합) : 발주전 배송 서비스</td>
                    <td>유통과 물류 비용 감소</td>
                  </tr>
                </tbody>
              </table>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>IoT(Internet of Thing)</strong>
      <ul>
        <li>센서 기반 디바이스로부터 데이터/정보추출</li>
        <li>확장성있는 유무선 네트워크를 통해 안정적 전송</li>
        <li>효과적 분석을 통한 자동화, 지능형 서비스 구현</li>
      </ul>
    </li>
  </ul>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Sensor</th>
      <th style="text-align: left">Device</th>
      <th style="text-align: left">Network Security</th>
      <th style="text-align: left">Standards</th>
      <th style="text-align: left">Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">고성능화 <br /> 소형화 <br /> 다기능화 <br /> 저전력화</td>
      <td style="text-align: left">OPEN H/W <br /> OPEN S/W</td>
      <td style="text-align: left">저전력화 <br /> 장거리 통신 <br /> 낮은 비용 <br /> 안정성/보안</td>
      <td style="text-align: left">공유 <br /> 안정적 <br /> 표준화</td>
      <td style="text-align: left">OPEN API <br /> Cloud Service <br /> Application</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <ul>
    <li><strong>빅데이터</strong>
      <ul>
        <li><strong>빅데이터의 특성</strong>
          <ul>
            <li>속도 : 데이터가 생성되고, 저장되며, 가공되어 표시되는 속도가 빠름도</li>
            <li>크기 : 데이터의 물리적인 크기가 매우 큼</li>
            <li>다양성 : 데이터의 형태 유무와, 연산가능 여부에 따라 나누어지는 데이터들이 매우 다양</li>
            <li>빅데이터의 공통적 속성 3V = 속도(Velocity), 크기(Volume), 다양성(Variety) 최근에는 정확성(Veracity)과 가변성(variability), 가치(Value), 시각화(Visualization)등의 속성이 추가</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">구분</th>
      <th style="text-align: center">전통적 데이터</th>
      <th style="text-align: center">빅데이터</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">데이터 원천</td>
      <td style="text-align: center">전통적 정보 서비스</td>
      <td style="text-align: center">일상화된 정보 서비스</td>
    </tr>
    <tr>
      <td style="text-align: center">목적</td>
      <td style="text-align: center">업무와 효율성</td>
      <td style="text-align: center">사회적 소통, 자기표현, 사회 기반 서비스</td>
    </tr>
    <tr>
      <td style="text-align: center">생성 주체</td>
      <td style="text-align: center">정부 및 기업 등 조직</td>
      <td style="text-align: center">개인 및 시스템</td>
    </tr>
    <tr>
      <td style="text-align: center">데이터 유형</td>
      <td style="text-align: center">정형 데이터 <br /> 조직 내부 데이터(고객 정보, 거래 정보, 등) <br /> 주로 비공개 데이터</td>
      <td style="text-align: center">비정형 데이터 <br /> (비디오 스트림, 이미지 오디오, 소셜 네트워크 등 사용자 데이터, 센서 데이터, 응용프로그램 데이터 등)</td>
    </tr>
    <tr>
      <td style="text-align: center">데이터 특징</td>
      <td style="text-align: center">데이터 증가량 관리 가능 <br /> 신뢰성 높은 핵심 데이터</td>
      <td style="text-align: center">기하급수로 양적 증가 <br /> 쓰레기 데이터 비중 높음 <br /> 문맥 정보 등 다양한 데이터</td>
    </tr>
    <tr>
      <td style="text-align: center">데이터 보유</td>
      <td style="text-align: center">정부, 기업 등 대부분 조직</td>
      <td style="text-align: center">인터넷 서비스 기업(구글, 아마존 등) <br /> 포털(네이터, 다음 등) <br /> 이동 통신사(SKT,KT 등) <br /> 디바이스 생산회사(삼성, 애플 등)</td>
    </tr>
    <tr>
      <td style="text-align: center">데이터 플랫폼</td>
      <td style="text-align: center">정형 데이터를 생산, 저장, 분석, 처리 할 수 있는 전통적 플랫폼</td>
      <td style="text-align: center">비정형 대량 데이터를 생산, 저장, 분석, 처리할 수 있는 새로운 플랫폼</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <ul>
    <li><strong>빅데이터 장단점</strong>
      <ul>
        <li><strong>장점</strong>
          <ul>
            <li>의사결정의 정확도를 높일 수 있다.</li>
            <li>가까운 미래를 예측하고 새로운 기회를 창출 할 수 있다.</li>
            <li>고객에 관한 통찰력을 향상 시킬 수 있다.</li>
          </ul>
        </li>
        <li><strong>단점</strong>
          <ul>
            <li>프라이버시</li>
            <li>예측이 완벽하지 않다.</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>빅데이터 관점</strong>
      <ul>
        <li><strong>소스로서 빅데이터</strong>는 대용량 자료나 문제해결 및 분석을 위한 원천자료를 의미</li>
        <li><strong>분석으로서 빅데이터</strong>는 자료의 분석과 해석에서 어떠한 의미를 도출하는 과정</li>
        <li><strong>시각화로서 빅데이터</strong>는 데이터의 시각화나 시각화 이전 현상을 구조화하거나 패턴화하는 것</li>
        <li><strong>문화로서 빅데이터</strong>는 문화를 발견하고 이해하고 예측하는 도구를 의미</li>
      </ul>
    </li>
    <li><strong>빅데이터 분석과정</strong>
      <ul>
        <li>빅데이터 분석과정에서 가장 우선되어야 하는 것은?
          <ul>
            <li>where : 데이터를 <strong>어디</strong>로부터 가져오는가</li>
            <li>why : 데이터 분석 결과가 <strong>왜</strong> 필요한가</li>
            <li>who : <strong>누구</strong>를 위해 사용할 것인가</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>빅데이터 처리과정</strong>
      <ul>
        <li>데이터소스 -&gt; 수집 -&gt; 저장 -&gt; 처리 -&gt; 분석 -&gt; 표현</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>AI</strong>
      <ul>
        <li><strong>인공지능의 중요성</strong>
          <ul>
            <li>최근 들어 인공지능이 중요한 화두로 떠오른 데에는 빅데이터로 대변되는 데이터양의 폭발적인 증가가 한몫 함</li>
            <li>기존에 보유하고 있던 데이터는 물론, 사물인터넷으로 수집된 데이터까지 분석하여 비즈니스에 활용하고자 하는 요구가 많아 짐</li>
            <li>범용성 : 하나의 기술을 여러 용도로 다양한 산업에 사용할 수 있음을 의미함</li>
            <li>최근에는 인공지능의 범용성이 높아짐</li>
            <li>기존에는 IT 산업에만 인공지능 기술이 적용되었다면, 최근에는 제조, 금융, 의료 등 전 산업에 적용되고 있는 추세</li>
          </ul>
        </li>
        <li><strong>인공지능 서비스 개발 과정</strong>
          <ul>
            <li>데이터 수집 : 사용자 문의, 다른 회사와의 협업</li>
            <li>데이터 저장 및 처리 : 저장 및처리 장치 이용, 클라우드 서비스 이용</li>
            <li>프로그램 제작 : AI 알고리즘 활용, 패턴 분석 및 제작</li>
            <li>서비스 배포 : 클라우드 서비스 활용</li>
          </ul>
        </li>
        <li><strong>AI 서비스 개발을 위한 기술</strong>
          <ul>
            <li>데이터 수집에 필요한 사물인터넷 기술</li>
            <li>데이터를 전송하기 위한 5G 기술</li>
            <li>데이터를 저장하고 처리하기 위한 클라우드 기술</li>
            <li>패턴 분석을 위한 인공지능 기술</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>블록체인</strong>
      <ul>
        <li>블록체인은 제 3자 도움 없이 타인과의 거래를 가능하게 하고, 그 거래를 기록한 장부 시스템을 유지하는 기술개념</li>
        <li><strong>블록체인에 관한 다양한 정의</strong>
          <ul>
            <li>TCP/IP와 같은 기술 프로토콜 계층</li>
            <li>거래 데이터베이스, 모든 거래들의 탈중앙화된 공공장부</li>
            <li>거래 목록으로 이루어진 블록들의 체인으로, 거래들의 순차적 장부이다.</li>
            <li>새로운 형태의 정보기술로, 지구적 스케일의 조직 시스템이자 인프라로서 자기점검능력과 통제력을 가지는 탈중앙화된 시스템</li>
            <li>자기결정과 책임을 가지는 디지털 노마드를 성장시키는 기반환경</li>
          </ul>
        </li>
        <li><strong>주요기능</strong>
          <ul>
            <li>거래 승인과 함께 거래 정보가 공유되는 플랫폼</li>
            <li>암호화 기술을 통해 구현된 안전한 데이터 저장소</li>
            <li>서로 신뢰가 없는 주체들을 연결시켜주는 통로</li>
          </ul>
        </li>
        <li><strong>주요 매커니즘</strong>
          <ul>
            <li>거래의 유효성 검증</li>
            <li>거래내역이 분산 및 공유</li>
            <li>암호화되어 저장</li>
          </ul>
        </li>
        <li><strong>How it work</strong>
          <ul>
            <li>거래요청 -&gt; 거래정보가 네트워크 참여자들로 전파 -&gt; 거래 유효성 검증 -&gt; 거래정보 담긴 블록 생성 -&gt; 블록체인에 블록 연결 -&gt; 거래승인 완료</li>
          </ul>
        </li>
        <li><strong>블록체인 확장분야 8C</strong>
          <ul>
            <li>Currency : 비트코인과 같이 다양한 목적의 파생 및 지능형 화폐들이 등장할 수 있다.</li>
            <li>Contract : 일정 조건을 만족시키면 자동으로 거래가 실행되도록 하는 것으로 소유권 이전이나 상속,증여 등에 사용될 수 있다.</li>
            <li>Cross border : 국제 송금 서비스 등의 국제 금융거래를 획기적으로 개선할 수 있으며 효율적으로 거래를 가능하도록 한다.</li>
            <li>Community : OPA를 활용하여 기존 상품권, 로열티 포인트 등을 블록체인에 기입하고 관리할 수 있다.</li>
            <li>Common Record : 블록체인은 공공기록을 관리하기에 적합하고 효율적인 기술로 활용될 것으로 전망된다.</li>
            <li>Consensus : 발행된 토큰을 유권자에게 나눠주고 정책이나 후보에게 토큰을 다시 보내는 방식으로 투표가 가능하다.</li>
            <li>Contents : 디지털아트, 웹툰 등의 저작권을 증명하는것이 가능하여 새로운 콘텐츠 시장의 등장도 가능하다. (<strong>NFT</strong>)</li>
            <li>Co-Ownership : 집, 자동차 등의 소유권 등록 후 이용시간과 범위 등 세부적인 수준으로 공유할 수 있다.</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>클라우드</strong>
      <ul>
        <li><strong>클라우드로 인한 변화</strong>
          <ul>
            <li>클라우드 컴퓨팅은 이제 단순히 기술 트렌드가 아니라 이미 우리 생활 속에 깊숙이 들어온 것</li>
            <li>네이버 N드라이브나 드롭박스 등의 퍼스널 클라우드는 동기화 기술의 발전과 더불어 언제 어느 곳에서나 문서를 편집하고 공유</li>
          </ul>
        </li>
        <li><strong>엣지 컴퓨팅</strong>
          <ul>
            <li>센서와 디바이스에서 쏟아지는 데이터를 네트워크 엣지에서 먼저 선별한 후, 중요한 데이터만을 서버로 내보내는 기술</li>
            <li><strong>특징</strong>
              <ul>
                <li>엣지 컴퓨팅은 클라우드 컴퓨팅의 단점인 안전성, 즉시성, 효율성을 극복할 수 있는 대안</li>
                <li>자율주행 자동차(네트워크 지연이나 데이터 전송 오류로 인한 사고 예방)</li>
                <li>항공엔진 및 드론(산업기계 자체가 중앙 서버와 원거리에 있는 연결의 문제 해결)</li>
                <li>스마트 팩토리(대규모의 센서 데이터에 대한 효율적 처리가 필요) 등에 적용</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>클라우드 컴퓨팅 vs 엣지 컴퓨팅</strong>
          <ul>
            <li>클라우드 컴퓨팅은 ‘클라우드 데이터 센터’에 아웃소싱 준 형태라면, 엣지 컴퓨팅은 클라우드에 위임했던 작업을 ‘엣지’에서 한 차례 추린 후 데이터 센터로 전달하는 방식</li>
          </ul>
        </li>
        <li><strong>클라우드의 구분</strong>
          <ul>
            <li><strong>하이브리드 클라우드</strong>
              <ul>
                <li>퍼블릭 클라우드와 프라이빗 클라우드의 결합 모델</li>
                <li>퍼블릭 프라이빗 클라우드의 장접을 모아 클라우드가 줄 수 있는 혜택을 최대한 제공하는 유형</li>
              </ul>
            </li>
            <li><strong>오픈스택(OpenStack)</strong>
              <ul>
                <li>클라우드 환경에서 컴퓨팅 자원과 스토리지 인프라를 셋업하고 구동하기 위해 사용하는 오픈소스 소프트웨어 프로젝트의 집합</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>5G</strong>
      <ul>
        <li><strong>이동통신의 환경변화</strong>
          <ul>
            <li><strong>초고속</strong>
              <ul>
                <li>2020년까지 개인당 매월 생성하는 데이터 양이 15년 대비 6.6배 증가 예상</li>
                <li>이 중 비디오 사용량이 전체 모바일 데이터 트래픽의 75% 차지</li>
              </ul>
            </li>
            <li><strong>저지연</strong>
              <ul>
                <li>자율 주행 차량이 매일 동안 4,000GB 데이터 생성 운전자와 차량을 안전하게 유지하기 위해 밀리 초 단위 의사 결정 필수</li>
              </ul>
            </li>
            <li><strong>초연결</strong>
              <ul>
                <li>2020년까지 모바일 사용자수는 15년 48억에서 55억으로 증가 예상</li>
                <li>모바일 기기 및 연결은 기기 85억개와 M2M 연결 31억개를 포함해 2020년까지 79억개(15년)에서 116억개로 증가 전망</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>공식명칭</strong>
          <ul>
            <li>5G 이동통신은 3GPP*에서 기술 표준화에 대한 논의가 시작되었으며 ITU**에서는 IMT-2020이라는 공식 명칭</li>
          </ul>
        </li>
        <li><strong>5G 네트워크의 기술적 특징</strong>
          <ul>
            <li>최대 전송속도 향상</li>
            <li>다수 기기 연결</li>
            <li>초저지연 실시간 서비스</li>
          </ul>
        </li>
        <li><strong>5G 서비스 영역</strong>
          <ul>
            <li><strong>초고속</strong>
              <ul>
                <li>4K/8K UHD</li>
                <li>홀로그램</li>
                <li>VR,AR</li>
              </ul>
            </li>
            <li><strong>저지연</strong>
              <ul>
                <li>실시간 통신 및 촉감 인터넷</li>
                <li>로봇 실시간 원격 조종</li>
                <li>커넥티드 카 (V2X)</li>
              </ul>
            </li>
            <li><strong>초연결</strong>
              <ul>
                <li>시설, 환경 원격 감시 및 제어</li>
                <li>스마트 빌딩/도시</li>
                <li>사물인터넷</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="4차-산업혁명-관련-기출문제">4차 산업혁명 관련 기출문제</h3>

<blockquote>
  <ul>
    <li><strong>빅테이터 활용 방안에 대해서 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 지원한 회사의 서비스 (가능하다면 차세대 전력 서비스)에 적용하여 설명하자.
지원한 회사에 대한 정확한 분석이 필요

예시 : ex.카카오 모빌리티
카카오 모빌리티는 오랜 기간 동안 카카오택시 등의 서비스로 다양한 종류의 빅데이터를 수집했습니다.
그리고 빅데이터를 기반으로 하는 다양한 서비스를 제공하고 있습니다.
제가 그 서비스에 하나를 더한다면, 카카오택시를 운행하는 기사님들의 이동경로 빅데이터를 활용해서
기사식당과 같은 로컬 맛집을 제공하고 싶습니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>인공지능 기술은 회사의 사업에 적용해서 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 회사의 사업분야 중에서 인공지능이 필요로 하는 영역이나 반복적인 연산과 판단이 필요한 분야를 제안하자.

예시 : ex. 우아한 형제들
우아한 형제들이 제공하는 배달의 민족 어플에서 사용자의 주문내역과 날씨 등의 환경을 분석해서
사용자에게 음식을 추천하는 서비스를 제공합니다.
가령, 고객이 치킨을 지속적으로 주문을 했다면 치킨의 종류를 분석하여 고객이 한 종류의 치킨을 주로 시킨다면
다른 브랜드의 유사한 치킨이 나왔을 때 추천해주거나, 고객이 새로운 유형의 치킨을 시킨다면 새로운 유형의 치킨이 나올 때
추천하는 등의 배달메뉴 추천 서비스를 인공지능 기술을 활용하여 제공할 수 있습니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>실생활에서 볼 수 있는 사물인터넷 기술에 대해서 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 거창한 기술이 아닌, 주변에서 기술요소들을 찾자.
사물인터넷은 교통분야, 방제분야, 상하수 처리분야 등에서 활용되고 있다. 구체적으로 답변하는 것이 필요하다.

예시 : 사물인터넷은 모든 사물에 인터넷을 연결하여 정보를 수집하고 수집된 정보를 기반으로 다양한 서비스를 제공하는 것으로
이해하고 있습니다. 주변 환경에서도 가깝게 찾는다면, 면접 보러 가는 길에 적용된 IoT 기술의 두 가지 사례를 얘기해보겠습니다.

집 근처에의 하천 길에는 하천의 수위를 측정하는 센서와 하천의 수위를 모니터링 하는 CCTV가 있습니다.
이렇게 수집된 정보는 재난방지 시스템에 연동되는 것으로 알고 있습니다.

두 번째로는 버스는 타고 면접장까지 이동할 때, 정류장에는 버스의 이동을 탐지하는 센서와 카메라가 있어
버스 안에서도 버스의 위치를 파악하고, 버스 내부를 모니터링 하는 CCTV가 이러한 정보들도 수집되는 것으로 알고 있습니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>4차 산업혁명의 핵심 기술들을 은행에서 어떻게 활용해야 하는가?</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 4차 산업혁명의 대표적인 기술은 IoT - 빅데이터 - AI가 큰 줄기를 가지고 있다. 이 줄기 기반으로 확장해서 설명할 수 있다.
은행에서 (또는 기업에서) 활용할 수 있는 방법을 제시하자.

예시 : 은행은 신규상품을 개발하기 위해서 자사 및 계열사의 고객정보나 SNS 등을 통해 수집된 데이터,
기후,재난과 같은 사회,자연 현상과 관련된 데이터 등 다양하고 광대한 정보를 활용할 수 있습니다.
특히 신규 개발상품의 적절한 가격을 책정하는 데(예: 보험 상품의 효율 책정)에 사용할 수 있습니다.
</code></pre></div></div>

<h2 id="final-기본-이론-5가지-wrap---up">Final. 기본 이론 5가지 WRAP - UP</h2>

<blockquote>
  <ul>
    <li><strong>소프트웨어 공학</strong>
      <ol>
        <li>소프트웨어 개발 주기</li>
        <li>프로세스
          <ul>
            <li>정의</li>
            <li>모델(5가지)</li>
          </ul>
        </li>
        <li>아키텍쳐
          <ul>
            <li>정의</li>
            <li>모델(4가지)</li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>프로그래밍</strong>
      <ol>
        <li>프로그래밍 언어종류</li>
        <li>객체지향
          <ul>
            <li>개요 및 특징</li>
            <li>객체지향 언어(Java)</li>
          </ul>
        </li>
        <li>데이터 분석 주요언어</li>
        <li>인공지능 주요언어</li>
        <li>IoT 사물인터넷</li>
        <li>형상관리</li>
        <li>디자인 패턴</li>
        <li>리팩토리</li>
      </ol>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>웹/모바일 서비스</strong>
      <ol>
        <li>웹서비스</li>
        <li>웹서버
          <ul>
            <li>웹페이지</li>
            <li>클라이언트 서버</li>
            <li>웹서버 종류 (6가지)</li>
            <li>웹서버 구성</li>
            <li>웹기술</li>
          </ul>
        </li>
        <li>모바일 서비스
          <ul>
            <li>모바일 앱</li>
            <li>모바일 웹</li>
            <li>하이브리드 앱</li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>데이터베이스</strong>
      <ol>
        <li>데이터 분류</li>
        <li>DB관리시스템</li>
        <li>DB 용어</li>
        <li>DB 언어</li>
        <li>View 정의</li>
        <li>Index 정의</li>
        <li>데이터 모델링
          <ul>
            <li>개념, 절차, 구성</li>
            <li>관계데이터 모델</li>
            <li>논리적데이터 모델</li>
          </ul>
        </li>
        <li>정규화</li>
      </ol>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>네트워크</strong>
      <ol>
        <li>OSI7 layer</li>
        <li>TCP/IP</li>
        <li>Routing</li>
      </ol>
    </li>
  </ul>
</blockquote>]]></content><author><name>김경호</name></author><category term="CS" /><category term="CS" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[CS 02. 기본이론]</title><link href="http://localhost:4000/cs/CS_Basic_2/" rel="alternate" type="text/html" title="[CS 02. 기본이론]" /><published>2022-06-21T00:00:00+09:00</published><updated>2022-06-21T00:00:00+09:00</updated><id>http://localhost:4000/cs/CS_Basic_2</id><content type="html" xml:base="http://localhost:4000/cs/CS_Basic_2/"><![CDATA[<p><br /></p>

<h2 id="1-자료구조">1. 자료구조</h2>

<blockquote>
  <ul>
    <li><strong>자료구조의 분류</strong>
      <ul>
        <li><strong>정의</strong>
          <ul>
            <li>자료를 효율적으로 표현하고 처리할 수 있도록 정리하는것</li>
          </ul>
        </li>
        <li><strong>자료의 분류</strong>
          <ul>
            <li>단순구조 (정수, 실수, 문자, 문자열 등의 기본 자료형)</li>
            <li>선형구조 (자료들 사이의 관계가 1:1관계/ 순차 리스트, 연결 리스트, 스택, 큐, 데크 등)</li>
            <li>비선형구조 (자료들 사이의 관계가 1:다, 또는 다:다 관계/트리, 그레프 등)</li>
            <li>파일 구조 (서로 관련있는 필드로 구성된 레코드 집합인 파일에 대한 구조, 순차파일, 색인파일, 직접파일 등)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>순차 자료구조</strong>
      <ul>
        <li><strong>순차 자료구조의 개념</strong>
          <ul>
            <li>구현할 자료들을 논리적 순서로 메모리에 연속 저장하는 구현 방식</li>
            <li>논리적인 순서와 물리적인 순서가 항상 일치해야 함</li>
            <li>C프로그래밍에서 순차 자료구조의 구현 방식 제공하는 프로그램 기법은 배열</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>선형리스트</strong>
      <ul>
        <li><strong>리스트</strong>
          <ul>
            <li>자료를 구조화 하는 가장 기본적인 방법은 나열하는 것</li>
          </ul>
        </li>
        <li><strong>선형 리스트</strong>
          <ul>
            <li>순서 리스트</li>
            <li>자료들 간에 순서를 갖는 리스트</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>연결자료구조</strong>
      <ul>
        <li><strong>자료의 논리적인 순서와 물리적인 순서가 불일치</strong>
          <ul>
            <li>각 원소에 저장되어 있는 다음 원소의 주소에 의해 순서가 연결되는 방식</li>
            <li>물리적인 순서를 맞추기 위한 오버헤드가 발생하지 않음</li>
          </ul>
        </li>
        <li><strong>연결리스트의 종류</strong>
          <ul>
            <li>연결하는 방식에 따라 단순 연결 리스트와 원형 연결 리스트, 이중 연결</li>
            <li>리스트, 이중 원형 연결 리스트</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>연결리스트</strong>
      <ul>
        <li><strong>단순 연결 리스트</strong>
          <ul>
            <li>단순 연결리스트의 개념
              <ul>
                <li>노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가짐</li>
                <li>연결 리스트, 선형 연결 리스트, 단순 연결 선형 리스트</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>원형 연결 리스트</strong>
          <ul>
            <li>단순 연결 리스트에서 마지막 노드가 리스트의 첫 번째 노드와 연결된 리스트</li>
            <li>단순 연결 리스트의 마지막 노드의 링크 필드에 첫 번째 노드 연결</li>
            <li>링크를 따라 계속 순회하면 이전 노드에 접근 가능</li>
          </ul>
        </li>
        <li><strong>이중 연결 리스트</strong>
          <ul>
            <li>양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>순차 자료구조와 연결 자료구조의 비교</strong></li>
  </ul>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">구분</th>
      <th style="text-align: left">순차 자료구조</th>
      <th style="text-align: left">연결 자료구조</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">메모리 저장 방식</td>
      <td style="text-align: left">메모리의 저장 시작 위치부터 빈자리 없이 자료를 <br /> 순서대로 연속하여 저장, 논리적 순서와 물리적 순서가 일치</td>
      <td style="text-align: left">메모리에 저장된 물리적 위치가 순서와 상관없이 <br /> 링크에 의해서 논리적인 순서를 표현하는 구현 방식</td>
    </tr>
    <tr>
      <td style="text-align: center">연산 특징</td>
      <td style="text-align: left">삽입, 삭제 연산 후 자료가 순서대로 연속하여 저장 <br /> 변경된 논리적인 순서와 물리적 순서가 일치</td>
      <td style="text-align: left">삽입, 삭제 연산을 하여 논리적인 순서가 변경되어도, <br /> 링크 정보만 변경되고, 물리적인 순서가 변경되지 않음</td>
    </tr>
    <tr>
      <td style="text-align: center">프로그램 기법</td>
      <td style="text-align: left">배열을 이용</td>
      <td style="text-align: left">포인터를 이용</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <ul>
    <li><strong>스택</strong>
      <ul>
        <li><strong>스택의 정의</strong>
          <ul>
            <li>접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 형태의 자료구조</li>
            <li>스택에 저장된 원소는 top으로 정한 곳에서만 접근 가능</li>
            <li>Top의 위치에서만 원소를 삽입하므로, 먼저 삽입한 원소는 밑에 쌓이고, 나중에 삽입한 원소는 위에 쌓이는 구조</li>
            <li>마지막에 삽입(Last-In)한 원소는 맨 위에 쌓여있다가 가장 먼저 삭제(First-Out)됨</li>
            <li>후입선출 구조(LIFO, Last-In-First-Out)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>큐</strong>
      <ul>
        <li><strong>큐의 정의</strong>
          <ul>
            <li>스택과 비슷한 삽입과 삭제의 위치가 제한되어 있는 유한 순서 리스트</li>
            <li>큐는 뒤에서는 삽입만 하고, 앞에서는 삭제만 할 수 있는 구조</li>
            <li>삽입한 순서대로 원소가 나열되어 가장 먼저 삽입(First-In)한 원소는 맨 앞에 있다가 가장 먼저 삭제(First-Out)됨</li>
            <li>선입선출 구조(FIFO, First-In-First-Out)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>스택과 큐의 연산 비교</strong></li>
  </ul>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">삽입연산</th>
      <th style="text-align: center"> </th>
      <th style="text-align: center">삭제연산</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">자료구조</td>
      <td style="text-align: center">연산자</td>
      <td style="text-align: center">삽입위치</td>
      <td style="text-align: center">연산자</td>
      <td style="text-align: center">삭제위치</td>
    </tr>
    <tr>
      <td style="text-align: center">스택</td>
      <td style="text-align: center">PUSH</td>
      <td style="text-align: center">TOP</td>
      <td style="text-align: center">POP</td>
      <td style="text-align: center">TOP</td>
    </tr>
    <tr>
      <td style="text-align: center">큐</td>
      <td style="text-align: center">enQueue</td>
      <td style="text-align: center">rear</td>
      <td style="text-align: center">deQueue</td>
      <td style="text-align: center">front</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <ul>
    <li><strong>데크(Deque : Double-ended queue)</strong>
      <ul>
        <li><strong>데크의 정의</strong>
          <ul>
            <li>큐 두 개 중 하나를 좌우로 뒤집어서 붙인 구조</li>
            <li>큐의 양쪽 끝에서 삽입 연산과 삭제 연산을 수행할 수 있도록 확장한 자료구조</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>트리</strong>
      <ul>
        <li><strong>트리(tree)의 정의</strong>
          <ul>
            <li>원소들 간에 1:n 관계를 가지는 비선형 자료구조</li>
            <li>원소들 간에 계층관계를 가지는 계층형 자료구조 (Hierarchical Data Structure)</li>
            <li>상위 원소에서 하위 원소로 내려가면서 확장되는 트리 모양의 구조</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>이진트리</strong>
      <ul>
        <li><strong>이진트리의 정의</strong>
          <ul>
            <li>트리의 모든 노드의 차수를 2 이하로 제한하여 전체 트리의 차수가 2 이하가 되도록 정의</li>
            <li>이진트리의 모든 노드는 왼쪽 자식 노드와 오른쪽 자식 노드만 가짐</li>
            <li>부모 노드와 자식 노드 수와의 관계 -&gt; 1:2</li>
            <li>공백 노드도 자식 노드로 취급</li>
            <li>0&lt;= 노드의 차수 &lt;= 2</li>
          </ul>
        </li>
        <li><strong>이진트리의 종류</strong>
          <ul>
            <li><strong>포화 이진트리</strong> Full Binary Tree
              <ul>
                <li>모든 레벨에 노드가 포화상태로 차 있는 이진트리</li>
              </ul>
            </li>
            <li><strong>완전 이진트리</strong> Complete Binary Tree
              <ul>
                <li>높이가 h이고 노드 수가 n개일 때 (단, n &lt; 2h+1-1), 노드 위치가 포화 이진트리에서의 노드 1번부터 n번까지의 위치와 완전히 일치하는 이진트리</li>
              </ul>
            </li>
            <li><strong>편향 이진트리</strong> Skewed Binary Tree
              <ul>
                <li>높이가 h일 때 h+1개의 노드를 가지면서 모든 노드가 왼쪽이나 오른쪽 중 한 방향으로만 서브 트리를 가지고 있는 트리</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>그래프</strong>
      <ul>
        <li><strong>그래프의 정의</strong>
          <ul>
            <li>연결되어 있는 원소 사이의 다:다 관계를 표현하는 자료구조</li>
          </ul>
        </li>
        <li><strong>그래프 G</strong>
          <ul>
            <li>객체를 나타내는 정점(vertex)과 객체를 연결하는 간선(edge)의 집합</li>
            <li>G = (V,E)</li>
            <li>V 는 그래프에 있는 정점들의 집합</li>
            <li>E는 정점을 연결하는 간선들의 집합</li>
          </ul>
        </li>
        <li><strong>그래프의 종류</strong>
          <ul>
            <li><strong>무방향 그래프(undirected graph)</strong>
              <ul>
                <li>두 정점을 연결하는 간선에 방향이 없는 그래프</li>
              </ul>
            </li>
            <li><strong>방향 그래프(directed graph), 다이그래프(digraph)</strong>
              <ul>
                <li>간선에 방향이 있는 그래프</li>
              </ul>
            </li>
            <li><strong>완전 그래프(complete graph)</strong>
              <ul>
                <li>각 정점에서 다른 모든 정점을 연결하여 최대로 많은 간선 수를 가진 그래프</li>
              </ul>
            </li>
            <li><strong>부분 그래프(subgraph)</strong>
              <ul>
                <li>원래의 그래프에서 정점이나 간선을 일부만 제외하여 만든 그래프</li>
              </ul>
            </li>
            <li><strong>가중 그래프(weight graph), 네트워크(network)</strong>
              <ul>
                <li>정점을 연결하는 간선에 가중치(weight)를 할당한 그래프</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>알고리즘</strong>
      <ul>
        <li><strong>알고리즘의 정의</strong>
          <ul>
            <li>문제해결 방법을 추상화 하여 단계적 절차를 논리적으로 기술해 놓은 명세서</li>
          </ul>
        </li>
        <li><strong>알고리즘의 조건</strong>
          <ul>
            <li>입력 : 알고리즘 수행에 필요한 자료가 외부에서 입력으로 제공</li>
            <li>출력 : 알고리즘 수행 후 하나 이상의 결과를 출력</li>
            <li>명확성 : 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어들은 명확하게 정의되어야 함</li>
            <li>유한성 : 알고리즘은 수행 뒤에 반드시 종료</li>
            <li>효과성 : 알고리즘의 모든 명령어들은 기본적이며 실행이 가능해야 함</li>
          </ul>
        </li>
        <li><strong>알고리즘 표현방법</strong>
          <ul>
            <li>자연어를 이용한 서술적 표현 방법</li>
            <li>순서도(Flow chart)를 이용한 도식화 표현 방법</li>
            <li>프로그래밍 언어를 이용한 구체화 방법</li>
            <li>가상코드(Pseudo-code)를 이용한 추상화 방법</li>
          </ul>
        </li>
        <li><strong>알고리즘 성능기준</strong>
          <ul>
            <li>정확성 : 올바른 자료 입력 시 유한한 시간 내에 올바른 결과 출력 여부</li>
            <li>명확성 : 알고리즘이 얼마나 이해하기 쉽고 명확하게 작성되었는가</li>
            <li>수행량 : 일반적인 연산 제외, 알고리즘 특성 나타내는 중요 연산 모두 분석</li>
            <li>메모리 사용량 : 알고리즘 연산시 메모리의 사용량</li>
            <li>최적성 : 가장 중요한 요소로 최적화 된 성능을 가져야 함</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>정렬</strong>
      <ul>
        <li><strong>정렬의 정의</strong>
          <ul>
            <li>순서 없이 배열된 자료를 작은 것부터 큰 것 순서인 오름차순(Ascending)이나 큰 것부터 작은 것 순서인 내림차순(Descending)으로 재배열하는 것</li>
            <li>키(Key) - 자료를 정렬하는데 사용하는 기준이 되는 특정 값</li>
          </ul>
        </li>
        <li><strong>정렬의 종류</strong>
          <ul>
            <li><strong>선택 정렬</strong>(selection sort)
              <ul>
                <li>전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식으로 정렬</li>
              </ul>
            </li>
            <li><strong>버블 정렬</strong>(bubble sort)
              <ul>
                <li>인접한 두 개의 원소를 비교하여 자리를 교환하는 방식</li>
              </ul>
            </li>
            <li><strong>퀵 정렬</strong>(quick sort)
              <ul>
                <li>정렬할 전체 원소에 대해서 정렬을 수행하지 않고, 기준 값을 중심으로 왼쪽 부분 집합과 오른쪽 부분 집합으로 분할하여 정렬하는 방법</li>
              </ul>
            </li>
            <li><strong>삽입 정렬</strong>(insert sort)
              <ul>
                <li>정렬되어있는 부분집합에 정렬할 새로운 원소의 위치를 찾아 삽입하는 방법</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>검색(search)</strong>
      <ul>
        <li><strong>검색의 정의</strong>
          <ul>
            <li>컴퓨터에 저장한 자료 중에서 원하는 항목을 찾는 작업</li>
            <li>탐색 키를 가진 항목을 찾는 것</li>
          </ul>
        </li>
        <li><strong>탐색 키</strong>(search key)
          <ul>
            <li>자료를 구별하여 인식할 수 있는 키</li>
          </ul>
        </li>
        <li><strong>삽입/삭제 작업에서의 검색</strong>
          <ul>
            <li>원소를 삽입하거나 삭제할 위치를 찾기 위해서 검색 연산 수행</li>
          </ul>
        </li>
        <li><strong>수행 위치에 따른 분류</strong>
          <ul>
            <li>내부 검색 : 메모리 내의 자료에 대해서 검색 수행</li>
            <li>외부 검색 : 보조 기억 장치에 있는 자료에 대해서 검색 수행</li>
          </ul>
        </li>
        <li><strong>검색 방식에 따른 분류</strong>
          <ul>
            <li>비교 검색 방식 : 검색 대상의 키를 비교하여 검색, 순차검색, 이진검색, 트리검색</li>
            <li>계산 검색 방식 : 계수적인 성질을 이용한 계산으로 검색, 해싱</li>
          </ul>
        </li>
        <li><strong>순차 검색</strong>(sequential search), <strong>선형 검색</strong>(linear search)
          <ul>
            <li>일렬로 된 자료를 처음부터 마지막까지 순서대로 검색하는 방법</li>
          </ul>
        </li>
        <li><strong>색인 순차 검색</strong>(index sequential search)
          <ul>
            <li>정렬되어 있는 자료에 대한 인덱스 테이블(index)을 추가로 사용하여 탐색 효율을 높인 검색 방법</li>
          </ul>
        </li>
        <li><strong>이진 검색, 이분 검색, 보간 검색</strong>
          <ul>
            <li>자료의 가운데에 있는 항목을 키 값과 비교하여 다음 검색 위치를 결정하여 검색을 계속하는 방법</li>
          </ul>
        </li>
        <li><strong>이진트리 검색</strong>
          <ul>
            <li>이진 탐색 트리를 사용한 검색 방법</li>
          </ul>
        </li>
        <li><strong>해싱</strong>
          <ul>
            <li>산술적인 연산을 이용하여 키가 있는 위치를 계산하여 바로 찾아가는 계산 검색 방식</li>
            <li>검색 방법
              <ul>
                <li>키 값에 대해서 해시 함수를 계산하여 주소를 구하고, 구한 주소에 해당하는 해시 테이블로 바로 이동</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="2-데이터베이스">2. 데이터베이스</h2>

<blockquote>
  <ul>
    <li><strong>데이터의 분류</strong>
      <ul>
        <li><strong>정형 데이터</strong>
          <ul>
            <li>구조화된 데이터, 즉 미리 <strong>정해진 구조에 따라 저장된 데이터</strong> <br /> 예) 엑셀의 스프레드시트, 데이터베이스의 테이블</li>
          </ul>
        </li>
        <li><strong>반정형 데이터</strong>
          <ul>
            <li>구조에 따라 저장된 데이터이지만 데이터 내용 안에 구조에 대한 설명이 함께 존재</li>
            <li>구조를 파악하는 파싱(parsing) 과정이 필요 <br /> 예) <strong>HTML, XML, JSON 문서나 웹 로그, 센서 데이터</strong></li>
          </ul>
        </li>
        <li><strong>비정형 데이터</strong>
          <ul>
            <li>정해진 <strong>구조가 없이 저장된 데이터</strong> <br /> 예) <strong>소셜 데이터의 텍스트</strong>, 영상, 이미지, 워드나 PDF 문서와 같은 멀티미디어 데이터</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>데이터베이스 관리시스템의 정의</strong>
      <ul>
        <li><strong>1세대</strong>
          <ul>
            <li>네트워크 DBMS(그래프 형태), 계층 DBMS(트리 형태)</li>
          </ul>
        </li>
        <li><strong>2세대</strong> (관계 DBMS)
          <ul>
            <li>데이터베이스를 테이블 형태로 구성
              <ul>
                <li>오라클, MS SQL 서버, MySQL</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>3세대</strong> (객체지향 DBMS, 객체관계 DBMS)
          <ul>
            <li>객체지향 DBMS : 객체를 이용해 데이터베이스를 구성
              <ul>
                <li>오투(O2), 온투스(ONTOS), 젬스톤(GemStone)</li>
              </ul>
            </li>
            <li>객체관계 DBMS : 객체 DBMS + 관계 DBMS</li>
          </ul>
        </li>
        <li><strong>4세대</strong> (NoSQL/NewSQL DBMS)
          <ul>
            <li>NoSQL DBMS : 비정형 데이터를 처리하는데 적합하고 확장성이 뛰어남
              <ul>
                <li>몽고디비(MongoDB), 카산드라(Cassandra)</li>
              </ul>
            </li>
            <li>NewSQL DBMS : 관계 DBMS의 장점 + NoSQL의 확장성 및 유연성
              <ul>
                <li>구글 스패너(Spanner), 볼트DB(VoltDB), 누오DB(NuoDB)</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>데이터베이스 용어</strong>
      <ul>
        <li><strong>스키마(schema) == 테이블(Table)</strong>
          <ul>
            <li>데이터베이스에 저장되는 데이터 구조와 제약조건을 정의한 것</li>
          </ul>
        </li>
        <li><strong>인스턴스</strong>(instance)
          <ul>
            <li>스키마에 따라 데이터베이스에 실제로 저장된 값</li>
          </ul>
        </li>
        <li><strong>데이터 독립성</strong>(data independency)
          <ul>
            <li>하위 스키마를 변경하더라도 상위 스키마가 영향을 받지 않는 특성</li>
            <li>논리적 데이터 독립성
              <ul>
                <li>개념 스키마가 변경되어도 외부 스키마는 영향을 받지 않음</li>
              </ul>
            </li>
            <li>물리적 데이터 독립성
              <ul>
                <li>내부 스키마가 변경되어도 개념 스키마는 영향을 받지 않음</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>데이터베이스 언어</strong>
      <ul>
        <li><strong>데이터 정의어</strong>(DDL; Data Definition Language)
          <ul>
            <li>스키마를 정의하거나, 수정 또는 삭제하기 위해 사용</li>
            <li>CREATE, ALTER, DROP, RENAME, TRUNCATE</li>
          </ul>
        </li>
        <li><strong>데이터 조작어</strong>(DML; Data Manipulation Language)
          <ul>
            <li>데이터의 삽입, 삭제, 수정, 검색 등의 처리를 요구하기 위해 사용</li>
            <li>절차적 데이터 조작어와 비절차적 데이터 조작어로 구분</li>
            <li>SELECT, INSERT, UPDATE, DELETE</li>
          </ul>
        </li>
        <li><strong>데이터 제어어</strong>(DCL; Data Control Language)
          <ul>
            <li>내부적으로 필요한 규칙이나 기법을 정의하기 위해 사용</li>
            <li>GRANT, REVOKE</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>View의 정의</strong>
      <ul>
        <li>관계 데이터베이스의 데이터베이스 언어 SQL에서 하나 이상의 테이블(또는 다른 뷰)에서 원하는 모든 데이터를 선택하여, 그들을 사용자 정의하여 나타낸 것</li>
        <li>데이터를 실제로 저장하지 않고 <strong>논리적으로만 존재하는 테이블</strong>이지만, 일반 테이블과 동일한 방법으로 사용함</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>데이터베이스 인덱스</strong>
      <ul>
        <li><strong>인덱스의 정의</strong>
          <ul>
            <li>데이터베이스 분야에 있어서 테이블에 대한 <strong>동작의 속도를 높여주는 자료 구조</strong></li>
            <li>인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성</li>
            <li>고속의 검색 동작 뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>관계 데이터 모델 키(Key)</strong>
      <ul>
        <li>릴레이션에서 투플들을 유일하게 구별하는 속성 또는 속성들의 집합</li>
      </ul>
    </li>
    <li><strong>키의 특성</strong>
      <ul>
        <li>유일성(uniqueness) : 하나의 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야 함</li>
        <li>최소성(minimality) : 꼭 필요한 최소한의 속성들로만 키를 구성함</li>
      </ul>
    </li>
    <li><strong>키의 종류</strong>
      <ul>
        <li><strong>슈퍼키</strong>(super key) : 유일성을 만족하는 속성 또는 속성들의 집합, 고객아이디, (고객아이디, 고객이름)</li>
        <li><strong>후보키</strong>(candidate key) : 유일성과 최소성을 만족하는 속성 또는 속성들의 집합, 고객아이디, (고객이름, 주소) 등</li>
        <li><strong>기본키</strong>(primary key) : 후보키 중에서 기본적으로 사용하기 위해 선택한 키, 고객아이디</li>
        <li><strong>대체키</strong>(alternate key) : 기본키로 선택되지 못한 후보키</li>
        <li><strong>외래키</strong>(foreign key) : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>제약조건</strong>
      <ul>
        <li><strong>무결성 제약조건</strong>(integrity constraint)
          <ul>
            <li>데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙</li>
            <li>무결성 : 데이터를 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것</li>
          </ul>
        </li>
        <li><strong>개체 무결성 제약조건</strong>(entity integrity constraint)
          <ul>
            <li>기본키를 구성하는 모든 속성은 널 값을 가질 수 없는 규칙</li>
          </ul>
        </li>
        <li><strong>참조 무결성 제약조건</strong>(referential integrity constraint)
          <ul>
            <li>외래키는 참조할 수 없는 값을 가질 수 없는 규칙</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="데이터베이스-기출문제">데이터베이스 기출문제</h3>

<blockquote>
  <ul>
    <li><strong>View에 대해 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : View 사용 경험을 예를 들어서 설명하자

예시 : 관광정보 정보서비스 제공 프로젝트를 개발할 때 제공되는
정보에는 관광정보에 관광 후기 / 사진정보 등의 여러 정보를 제공해야 했는데,
하나의 쿼리로 데이터를 불러오는 것이 쉽지 않아서 관광정보의 목록을 보여주는 View와
관광지의 정보를 보여주는 View를 만들어서 사용하였습니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>인덱스에 대해 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 인덱스 사용 경험을 예를 들어서 설명하자.
인덱스를 사용할 때와 사용하지 않을 때의 결과를 비교해서 설명하자.

예시 : 관광정보를 제공하는 서비스를 개발하면서 관광정보에 대한 사용자 후기 정보를 크롤링해서 수집했습니다.
관광정보의 후기 정보의 수집건수가 만 건 이상이 수집되면서 조회속도와 검색 속도가 많이 늦어졌습니다.
이 부분을 해결하기 위해서 검색의 대상이 되는 필드에 대해서 인덱스를 설정하여 속도를 향상하였습니다.

</code></pre></div></div>

<h2 id="3-컴퓨터구조">3. 컴퓨터구조</h2>

<blockquote>
  <ul>
    <li><strong>폰노이만 구조</strong>
      <ul>
        <li><strong>개요</strong>
          <ul>
            <li>CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조</li>
            <li>폰노이만 구조의 가장 큰 특징은 저장장치에서 바로 실행할 수 없고 메모리로 가지고 올라와야 실행이 가능함
              <ul>
                <li>메모리 관리가 중요한 이슈</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>컴퓨터 시스템 구성요소</strong>
      <ul>
        <li><strong>프로세서(Processor)</strong>
          <ul>
            <li>운영체제와 가장 밀접한 하드웨어로 각 부분의 동작 제어 및 연산 수행</li>
          </ul>
        </li>
        <li><strong>버스(Bus)</strong>
          <ul>
            <li>프로세서를 포함한 각 장치 간 또는 서브시스템을 서로 연결하여 정보(데이터)를 주고받을 수 있게 해주는 통로</li>
          </ul>
        </li>
        <li><strong>레지스터(Register)</strong>
          <ul>
            <li>프로세서에 위치한 고속 메모리로 프로세서가 바로 사용할 수 있는 데이터 저장</li>
          </ul>
        </li>
        <li><strong>메모리(Memory)</strong>
          <ul>
            <li>메모리 계층 구조는 1950년 ~ 1960년대 메인 메모리의 높은 가격으로 인해 제안된 방법으로, 다양한 레벨의 메모리를 연결하여 비용, 속도, 용량, 접근 시간 등을 상호 보완</li>
          </ul>
        </li>
        <li><strong>주변장치</strong>
          <ul>
            <li>컴퓨터의 기능을 향상시키기 위한 추가 장비</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>운영체제 아키텍쳐</strong>
      <ul>
        <li><strong>모놀리식 커널</strong>
          <ul>
            <li>모든 컴포넌트 커널에 포함</li>
            <li>호출 기능만으로 다른 구성 요소와 통신 가능</li>
            <li>컴퓨터 시스템에 제한 없이 접근</li>
            <li>높은 성능</li>
            <li>오류나 악성 코드에 취약</li>
          </ul>
        </li>
        <li><strong>마이크로커널</strong>
          <ul>
            <li>소수의 서비스만 제공</li>
            <li>커널 규모 감소, 규모 확장성 향상</li>
            <li>구성 요소를 낮은 수준의 권한으로 커널 외부에서 실행</li>
            <li>확장성, 이식성, 규모 확장성 향상</li>
            <li>모듈 간의 통신이 많아 성능 감소</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>커널</strong>
      <ul>
        <li><strong>프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모아 놓은 것</strong></li>
        <li><strong>단일형 구조 커널</strong>
          <ul>
            <li>모듈 간의 통신 비용이 줄어들어 효율적인 운영이 가능</li>
          </ul>
        </li>
        <li><strong>계층형 구조 커널</strong>
          <ul>
            <li>비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들고 계층 간의 통신을 통해 운영체제를 구현하는 방식</li>
          </ul>
        </li>
        <li><strong>마이크로 구조 커널</strong>
          <ul>
            <li>프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공</li>
            <li>커널의 각 모듈은 세분화되어 존재하고 모듈 간의 정보교환은 프로세스 간 통신을 이용하여 이루어짐</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>가상머신</strong>
      <ul>
        <li><strong>가상머신의 정의</strong>
          <ul>
            <li>운영체제와 응용 프로그램 사이에서 작동하는 프로그램</li>
            <li>가상머신을 설치하면 응용 프로그램이 모두 동일한 환경에서 작동하는 것처럼 보임</li>
            <li>자바는 유닉스와 윈도우에서 작동하는 다양한 가상머신을 만들어 배포하는데 이를 자바 가상머신 JavaVirtual Machine, JVM 이라고 함</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>시스템의 주요개념</strong>
      <ul>
        <li><strong>캐시</strong>
          <ul>
            <li>고속 메모리</li>
            <li>캐시 적중(cache hit) - 참조하는 정보가 캐시 메모리에 있는 경우</li>
            <li>캐시 실패(cache miss) - 참조하는 정보가 메모리에 없는 경우</li>
            <li>메모리 참조의 상당수가 캐시 적중되어야 성능 향상 가능</li>
            <li>캐시의 예 - L1과 L2 프로세서 캐시</li>
            <li>메인 메모리의 일정 부분을 할당해 2차 저장소의 데이터를 캐시하는데 활용</li>
          </ul>
        </li>
        <li><strong>버퍼</strong>
          <ul>
            <li>장치들 사이 혹은 다른 속도로 동작하는 프로세스들 사이에서 데이터를 전송할 때 일시적으로 데이터를 보관하는 저장영역</li>
            <li>소프트웨어와 하드웨어 장치들이 데이터를 비동기적으로 전송하게 함으로써 시스템 성능 향상</li>
          </ul>
        </li>
        <li><strong>스풀링</strong>
          <ul>
            <li>한 프로세스와 저속 또는 버퍼가 제한된 입출력 장치 사이에 디스크와 같은 중간 매개체를 두는 기술</li>
          </ul>
        </li>
        <li><strong>폴링</strong>
          <ul>
            <li>CPU가 직접 입출력장치에서 데이터를 가져오거나 내보내는 방식</li>
            <li>CPU가 입출력장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 데이터를 처리</li>
            <li>CPU가 명령어 해석과 실행이라는 본래 역할 외에 모든 입출력까지 관여해야 하므로 작업 효율이 떨어짐</li>
          </ul>
        </li>
        <li><strong>인터럽트</strong>
          <ul>
            <li>입출력 관리자가 대신 입출력을 해주는 방식</li>
            <li>CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영함으로써 시스템의 효율을 높임</li>
            <li>데이터의 입출력이 이루어지는 동안 CPU가 다른 작업을 할 수 있음</li>
          </ul>
        </li>
        <li><strong>인터럽트의 종류</strong>
          <ul>
            <li>외부 인터럽트 : 입출력장치로부터 오는 인터럽트뿐 아니라 전원 이상이나 기계적인 오류 때문에 발생하는 인터럽트를 포함</li>
            <li>내부 인터럽트 : 프로세스의 잘못이나 예상치 못한 문제 때문에 발생하는 인터럽트</li>
            <li>시그널 : 사용자가 직접 발생시키는 인터럽트</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>리눅스 커널</strong>
      <ul>
        <li><strong>리눅스 커널의 역할</strong>
          <ul>
            <li>기본적으로 인터럽트 또는 시스템 콜에 의해 수행됨</li>
            <li>모든 작업에 우선하여 동작하는 프로그램</li>
            <li>CPU, 메모리, 하드디스크 등의 하드웨어 자원을 제어하여 운영체제의 기본적인 기능을 사용자에게 제공
              <ul>
                <li>프로세스 스케줄링</li>
                <li>기억장치 관리</li>
                <li>파일 시스템 관리</li>
                <li>네트워크 관리</li>
                <li>시스템 콜 인터페이스</li>
                <li>오퍼레이터 콘솔 및 인터페이스 기능</li>
                <li>멀티 프로그래밍 지원</li>
                <li>파일시스템 서비스</li>
                <li>입출력 서비스 등</li>
              </ul>
            </li>
            <li>명령 인터프리터(interpreter) 부분은 커널에 내장되어 있지 않으며, 다른 사용자 프로그램과 똑같이 애플리케이션(application) 프로그램으로 독립되어 있음</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="4-네트워크">4. 네트워크</h2>

<blockquote>
  <ul>
    <li><strong>TCP/IP</strong>
      <ul>
        <li><strong>TCP/IP의 시작</strong>
          <ul>
            <li>네트워크는 서로 다른 기종의 컴퓨터로 구성되어 있어 각 네트워크 간에 공통으로 사용할 수 있는 프로토콜이 필요</li>
            <li>인터넷에서 컴퓨터 간의 통신이 가능하도록 표준화하여 채택한 <strong>국제표준통신규약</strong></li>
            <li>네트워크와 네트워크를 연결하는 데 사용하는 프로토콜인 TCP/IP는 ‘전송 제어 프로토콜(TCP;Transmission Control Protocol)’과 ‘인터넷 프로토콜(IP; Internet Protocol)’을 의미</li>
            <li>인터넷에서 사용하는 응용 프로그램은 대부분 이 TCP/IP 프로토콜을 이용하여 데이터를 교환</li>
          </ul>
        </li>
        <li><strong>TCP/IP의 구조</strong>
          <ul>
            <li>응용 계층 - FTP, 텔넷, SMTP, DNS, DHCP</li>
            <li>전송 계층 - TCP, TDP -&gt; 포트 주소</li>
            <li>네트워크 계층 - IP, ARP, ICMP -&gt; IP 주소</li>
            <li>네트워크 접속 계층 - PPP, SLIP -&gt; 물리 주소</li>
            <li><strong>물리주소</strong>
              <ul>
                <li>물리 주소(MAC 주소)는 링크 주소 또는 통신망에서 정의된 노드의 주소, 이더넷 네트워크 인터페이스 카드(NIC) 6바이트(48비트) 주소 등을 말한다.</li>
              </ul>
            </li>
            <li><strong>인터넷 주소</strong>
              <ul>
                <li>인터넷에서는 기존 물리 주소와는 별도로 각 호스트를 식별할 수 있는 유일한 주소를 지정해야 한다.</li>
              </ul>
            </li>
            <li><strong>포트주소</strong>
              <ul>
                <li>수신지 컴퓨터까지 전송하려면 IP 주소와 물리 주소가 필요하다.</li>
                <li>인터넷 통신의 최종 목적은 한 프로세스가 다른 프로세스와 통신할 수 있도록 하는 것이다.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>TCP/IP의 이해</strong>
          <ul>
            <li><strong>프로토콜의 필요성</strong>
              <ul>
                <li>네트워크는 서로 다른 기종의 컴퓨터로 구성되어 있어 각 네트워크 간에 공통으로 사용할 수 있는 프로토콜의 필요성이 대두</li>
              </ul>
            </li>
            <li><strong>프로토콜의 정의</strong>
              <ul>
                <li>컴퓨터 간의 통신이 가능하도록 표준화 하여 채택한 통신규약</li>
              </ul>
            </li>
            <li><strong>TCP/IP의 정의</strong>
              <ul>
                <li>네트워크와 네트워크를 연결하는 데 사용하는 프로토콜인 TCP/IP는 ‘전송 제어 프로토콜(TCP;Transmission Control Protocol)’과 ‘인터넷 프로토콜(IP; Internet Protocol)’을 의미</li>
                <li>인터넷에서 사용하는 응용 프로그램은 대부분 이 TCP/IP 프로토콜을 이용하여 데이터를 교환</li>
              </ul>
            </li>
            <li><strong>TCP/IP vs OSI 7</strong></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: left">유사점</th>
      <th style="text-align: left">차이점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1. 계층 모델이다</td>
      <td style="text-align: left">1. TCP/IP 모델의 응용 프로그램 계층은 <br /> OSI 계층 모델의 표현 계층과 세션 계층은 포함한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">2. 응용 프로그램 계층</td>
      <td style="text-align: left">2. TCP/IP 모델의 네트워크 액세스 계층은 OSI 계층 모델의 데이터 링크 계층과 물리 계층을 포함한다.</td>
    </tr>
    <tr>
      <td style="text-align: left">3. 트랜스 포트 계층/ 네트워크 계층과 호환되는 계층</td>
      <td style="text-align: left">3. TCP/IP 프로토콜은 인터넷 표준</td>
    </tr>
    <tr>
      <td style="text-align: left">4. 패킷 스위칭 기술 기반</td>
      <td style="text-align: left"> </td>
    </tr>
  </tbody>
</table>

<blockquote>
  <ul>
    <li><strong>TCP/IP 주소</strong>
      <ul>
        <li><strong>IP Address</strong>
          <ul>
            <li>인터넷에 연결된 모든 컴퓨터에는 고유의 주소가 부여</li>
            <li>현재 사용하는 IP 주소 체계는 IP ver.4이다.</li>
            <li>일반 우편 주소를 시, 동, 번지 등으로 구분하는 것처럼 IP 주소도 네트워크 주소(Net ID)와 호스트 주소(Host ID)로 구분</li>
            <li>IP 주소를 효율적으로 배정하려고 클래스라는 개념 도입</li>
            <li>클래스에는 A,B,C,D,E 다섯 종류
              <ul>
                <li>Class A : NET ID (1 Byte) + HOST ID (3 Byte)</li>
                <li>Class B : NET ID (2 Byte) + HOST ID (2 Byte)</li>
                <li>Class C : NET ID (3 Byte) + HOST ID (1 Byte)</li>
                <li>Class D : MULTICAST ADDRESS (4 Byte)</li>
                <li>Class E : RESERVED (4 Byte)</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>IPv4 vs IPv6</strong></li>
  </ul>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">구분</th>
      <th style="text-align: left">IPv4</th>
      <th style="text-align: left">IPv6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">주소 길이</td>
      <td style="text-align: left">32비트</td>
      <td style="text-align: left">128비트</td>
    </tr>
    <tr>
      <td style="text-align: center">표시 방법</td>
      <td style="text-align: left">8비스씩 4부분 10진수 표시 <br /> ex) 203.252.53.55</td>
      <td style="text-align: left">16비트 8부분 16진수로 표시 <br /> ex) 2002:0221:ABCD:DCBA:0000:FFFF:4002</td>
    </tr>
    <tr>
      <td style="text-align: center">주소 개수</td>
      <td style="text-align: left">약 43억개</td>
      <td style="text-align: left">2^128개 (약 43억x43억x43억x43억)</td>
    </tr>
    <tr>
      <td style="text-align: center">주소할당 방식</td>
      <td style="text-align: left">A,B,C,D 등의 클래스 단위 비순차 할당</td>
      <td style="text-align: left">네트워크 규모, 단말기수에 따라 순차할당</td>
    </tr>
    <tr>
      <td style="text-align: center">브로드캐스트 주소</td>
      <td style="text-align: left">있음</td>
      <td style="text-align: left">없음(대신, 로컬범위 내에서 모든 노드에 대한 멀티캐스트 주소 사용</td>
    </tr>
    <tr>
      <td style="text-align: center">헤더 크기</td>
      <td style="text-align: left">가변</td>
      <td style="text-align: left">고정</td>
    </tr>
    <tr>
      <td style="text-align: center">QoS 제공</td>
      <td style="text-align: left">미흡</td>
      <td style="text-align: left">제공</td>
    </tr>
    <tr>
      <td style="text-align: center">보안</td>
      <td style="text-align: left">IPSec 프로토콜 별도 설치</td>
      <td style="text-align: left">IPSec 자체 지원</td>
    </tr>
    <tr>
      <td style="text-align: center">서비스 품질</td>
      <td style="text-align: left">제한적 품질 보장 (Type of Service에 의한 서비스 품질 일부 지원)</td>
      <td style="text-align: left">확장된 품질 보장 (트래픽 클래스, 플로우 레이블에 의한 서비스 품질 지원)</td>
    </tr>
    <tr>
      <td style="text-align: center">Plug &amp; Play</td>
      <td style="text-align: left">불가(DHCP 이용 시 가능)</td>
      <td style="text-align: left">가능</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <ul>
    <li><strong>Routing</strong>
      <ul>
        <li>패킷의 전송 경로를 지정</li>
        <li>전송 경로 결정시 고려 사항
          <ul>
            <li><strong>공평 원칙</strong> : 다른 패킷의 우선 처리를 위해 다른 패킷이 손해를 보면 안됨</li>
            <li><strong>효율 원칙</strong> : 전체 네트워크의 효율성에 대해 고려해야 함</li>
          </ul>
        </li>
        <li><strong>Routing algorithm</strong>
          <ul>
            <li>간결성과 시스템 및 네트워크 자원의 최소 사용</li>
            <li>라우팅 정보의 안정성과 견고성</li>
            <li>라우터간의 라우팅 테이블의 빠른 갱신</li>
            <li>네트워크 환경 변화에 따른 갱신</li>
          </ul>
        </li>
        <li><strong>Static Routing vs Dynamic Routing</strong>
          <ul>
            <li><strong>정적 라우팅</strong>(Static Routing)
              <ul>
                <li>패킷 전송이 이루어지기 전에 경로 정보를 라우터가 미리 저장하여 중개</li>
                <li>단점 : 경로 정보의 갱신이 어려우므로, 네트워크 변화/ 네트워크 혼잡도 대처 부족</li>
              </ul>
            </li>
            <li><strong>동적 라우팅</strong>(Dynamic Routing)
              <ul>
                <li>라우터의 경로 정보가 네트워크 상황에 따라 적절히 조절됨</li>
                <li>단점 : 경로 정보의 수집과 관리로 인한 성능 저하</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>Router</strong>
          <ul>
            <li>라우터(Router)는 서로 구조가 다른 망을 연결할 수 있어 <strong>근거리 통신망(LAN)과 대도시 통신말(MAN), 광대역 통신망(WAN)</strong>을 연결하는 데 사용</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>HTTP 프로토콜</strong>
      <ul>
        <li><strong>정의</strong>
          <ul>
            <li>HTTP(Hypertext Transfer Protocol)는 웹의 기본 통신 프로토콜이다.
              <ul>
                <li>프로토콜이란 상호 간에 정의한 규칙을 의미하며 특정 기기 간에 데이터를 주고받기 위해 정의되었다.</li>
              </ul>
            </li>
            <li>웹에서 브라우저와 서버 간에 데이터를 주고받기 위한 방식</li>
          </ul>
        </li>
        <li><strong>특징</strong>
          <ul>
            <li>HTTP 프로토콜은 상태가 없는(stateless) 프로토콜이다.</li>
            <li>여기서 상태가 없다 라는 말은 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 뜻</li>
            <li>좀 더 쉽게 말해서 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다는 뜻</li>
            <li>이러한 특징으로 서버는 세션과 같은 별도의 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있는 성능 상의 이점이 생김</li>
            <li>HTTP 프로토콜은 일반적으로 TCP/IP 통신 위에서 동작하며 기본 포트는 80번이다.</li>
          </ul>
        </li>
        <li><strong>HTTP Request &amp; HTTP Response</strong>
          <ul>
            <li>요청과 응답을 이해하기 위해서는 클라이언트(Client)와 서버(Server)를 이해해야 한다.</li>
            <li>클라이언트란 요청을 보내는 쪽을 의미하며 일반적으로 웹 관점에서는 브라우저를 의미</li>
            <li>서버란 요청을 받는 쪽을 의미하며 일반적으로 데이터를 보내주는 원격지의 컴퓨터를 의미</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>URL</strong>
      <ul>
        <li><strong>URL의 정의</strong>
          <ul>
            <li>서버에 자원을 요청하기 위해 입력하는 영문 주소</li>
            <li>숫자로 되어 있는 IP 주소보다는 기억하기 쉽기 때문에 사용</li>
          </ul>
        </li>
        <li><strong>URL 구조</strong>
          <ul>
            <li>http://www.domain.com:1234/path/to/resource?a=b&amp;x=y
              <ul>
                <li>http : protocol</li>
                <li>www.domain.com : host</li>
                <li>1234 : port</li>
                <li>path/to/resource : resource path</li>
                <li>?a=b&amp;x=y : query</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>HTTP 요청메소드</strong>
      <ul>
        <li>요청한 URL을 이용하여 서버에 특정 데이터를 요청</li>
        <li>요청하는 데이터에 특정 동작을 수행하고 싶으면 HTTP 요청 메서드(Http Request Methods)를 이용</li>
        <li><strong>HTTP 요청 메소드</strong>
          <ul>
            <li>GET : 존재하는 자원에 대한 요청</li>
            <li>POST : 새로운 자원을 생성</li>
            <li>PUT : 존재하는 자원에 대한 변경</li>
            <li>DELETE : 존재하는 자원에 대한 삭제</li>
          </ul>
        </li>
        <li>이와 같이 데이터에 대한 조회, 생성, 변경, 삭제 동작을 HTTP 요청 메서드로 정의</li>
        <li><strong>기타 요청 메서드</strong>
          <ul>
            <li>HEAD : 서버 헤더 정보를 획듯. GET과 비슷하나 Response Body를 반환하지 않음</li>
            <li>OPTIONS : 서버 옵션들을 확인하기 위한 요청. CORS에서 사용</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>HTTP 상태코드</strong>
      <ul>
        <li><strong>HTTP 상태코드(HTTP Status Code)</strong>
          <ul>
            <li>서버에서 설정해주는 응답(Response) 정보</li>
          </ul>
        </li>
        <li><strong>2xx - 성공</strong>
          <ul>
            <li>200번 대의 사애 코드는 대부분 성공을 의미한다.</li>
            <li>200 : GET 요청에 대한 성공</li>
            <li>204 : No Content. 성공했으나 응답 본문에 데이터가 없음</li>
            <li>205 : Reset Content. 성공했으나 클라이언트의 화면을 새로고침 하도록 권고</li>
            <li>206 : Partial Content. 성공했으나 일부 범위의 데이터만 반환</li>
          </ul>
        </li>
        <li><strong>3xx - 리다이렉션</strong>
          <ul>
            <li>300번 대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우이다.</li>
            <li>301 : Moved Permanently, 요청한 자원이 새 URL에 존재</li>
            <li>303 : See Other, 요청한 자원이 임시 주소에 존재</li>
            <li>304 : Not Modified, 요청한 자원이 변경되지 않았으므로 클라이언트에서 캐싱된 자원을 사용하도록 권고. ETag와 같은 정보를 활용하여 변경 여부를 확인</li>
          </ul>
        </li>
        <li><strong>4xx - 클라이언트 에러</strong>
          <ul>
            <li>400번 대의 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우로 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생.</li>
            <li>400 : Bad Request, 잘못된 요청</li>
            <li>401 : Unauthorized, 권한 없이 요청. Authorization 헤더가 잘못된 경우</li>
            <li>403 : Foribidden, 서버에서 해당 자원에 대한 접근 금지</li>
            <li>405 : Method Not Allowed, 허용되지 않은 요청 메서드</li>
            <li>409 : Conflict, 최신 자원이 아닌데 업데이트 하는 경우. ex) 파일 업로드 시 버전 충돌</li>
          </ul>
        </li>
        <li><strong>5xx - 서버에러</strong>
          <ul>
            <li>500번 대의 상태 코드는 서버 쪽에서 오류가 난 경우이다.</li>
            <li>501 : Not Implemented, 요청한 동작에 대해 서버가 수행할 수 없는 경우</li>
            <li>503 : Service Unavailable, 서버가 과부하 또는 유지 보수로 내려간 경우</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="네트워크-기출문제">네트워크 기출문제</h3>

<blockquote>
  <ul>
    <li><strong>https://www.test.com 이라면 어떻게 동작하는지 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : 네트워크 관점에서 동작을 설명하자.
예시 : 이용자가 웹 브라우저에서 www.test.com을 주소창에 입력하면,
웹 브라우저에서는 www.test.com 도메인에 대한 실제 IP ADDRESS를 .RP 프로토콜을 이용해서 DNS에 조회하게 됩니다.
그 이후에 실제 IP ADDRESS를 이용해서 서버의 80 포트를 통해서 서비스를 제공하는 웹 서버에 해당 도메인에 대한 웹 컨텐츠를 요청합니다.
웹 서버는 웹 브라우저를 위한 별도의 포트에 소켓을 개설하고, 그 소켓은 웹 브라우저와 연결됩니다.
웹 서버는 요청 받은 컨텐츠를 웹 브라우저로 보내게 됩니다.
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>IPv4와 IPv6에 대해서 비교 설명하시오.</strong></li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>답변 Point : IPv4와 IPv6에 대해서 비교 설명하자.
예시 : IPv4가 확장성과 용량 면에서 그 한계가 드러나면서 인터넷 요구 사항의 폭증을 수용하기 위해서 IPv6가 개발되었습니다.
IPv6는 IPv4에 비해 다음과 같은 개선점이 있습니다.

1. 패킷을 단편화하지 않고 효율적인 라우팅을 제공함
2. 시간 지연에 민감한 패킷을 구분하는 기본적인 QoS(Quality of Service)를 제공
3. NAT를 없앰으로써 주소 공간을 32비트에서 128비트로 확장
4. 네트워크 레이어 보안을 내장하고 있음 (IPsec)
5. 손쉬운 네트워크 관리를 위한 스테이트리스 주소 자동 구성하고 처리 오버헤드가 줄어든 개선된 헤더 구조를 가지고 있습니다.
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="CS" /><category term="CS" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (영속성 관리, 앤티티 매핑)]</title><link href="http://localhost:4000/jpa/JPA_Basic-1/" rel="alternate" type="text/html" title="[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (영속성 관리, 앤티티 매핑)]" /><published>2022-06-17T00:00:00+09:00</published><updated>2022-06-17T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA_Basic%201</id><content type="html" xml:base="http://localhost:4000/jpa/JPA_Basic-1/"><![CDATA[<p><br /></p>

<p>##</p>]]></content><author><name>김경호</name></author><category term="JPA" /><category term="JPA" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Java 02. 기본 문법 및 응용 (Java의 클래스, 객체, 변수의 종류)]</title><link href="http://localhost:4000/java/Java_Basic-4/" rel="alternate" type="text/html" title="[Java 02. 기본 문법 및 응용 (Java의 클래스, 객체, 변수의 종류)]" /><published>2022-01-18T00:00:00+09:00</published><updated>2022-01-18T00:00:00+09:00</updated><id>http://localhost:4000/java/Java_Basic%204</id><content type="html" xml:base="http://localhost:4000/java/Java_Basic-4/"><![CDATA[<p><br /></p>

<h2 id="0-객체지향-프로그래밍이란-object-oriented-programming">0. 객체지향 프로그래밍이란? (Object Oriented Programming)</h2>

<blockquote>
  <ul>
    <li><strong>객체</strong>란?
      <ul>
        <li>주체가 아닌 것, 주체가 활용하는 것
          <ul>
            <li>우리 주변에 있는 모든 것으로 프로그래밍의 대상 : 사물, 개념, 논리 …</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>객체지향</strong> 프로그래밍
      <ul>
        <li>주변의 많은 것들을 객체화 해서 프로그래밍 하는것</li>
        <li>객체지향은 객체를 많이 만드는 것을 추천한다?? YES!</li>
      </ul>
    </li>
    <li><strong>객체지향 프로그래밍의 장점</strong>
      <ul>
        <li>블록 형태의 모듈화된 프로그래밍
          <ul>
            <li>신뢰성 높은 프로그래밍이 가능하다.</li>
            <li>추가/수정/삭제가 용이하다.</li>
            <li>재사용성이 높다.</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>현실 세계 객체, 클래스, 프로그램의 객체(instance, object)의 관계</strong>
      <ul>
        <li><strong><em>현실의 객체</em></strong>가 갖는 속성과 기능은 <strong><em>추상화(abstraction)</em></strong>되어 <strong><em>클래스</em></strong>에 정의된다.</li>
        <li><strong><em>클래스는 구체화</em></strong> 되어 <strong><em>프로그램의 객체(instance, object)</em></strong>가 된다.</li>
      </ul>
    </li>
    <li>실생활에서의 예) 붕어빵 틀 = Type, 붕어빵 = 객체
      <ul>
        <li><strong>프로그램의 클래스와 객체</strong>
          <ul>
            <li>클래스
              <ul>
                <li>객체를 정의해 놓은 것 즉 객체의 설계도, 틀</li>
                <li>클래스는 직접 사용할 수 없고 직접 사용되는 객체를 만들기 위한 틀을 제공할 뿐</li>
              </ul>
            </li>
            <li>객체(instance, object)
              <ul>
                <li>클래스를 데이터 타입으로 메모리에 생성된 것</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      &lt;클래스&gt;                                       &lt;객체&gt;
- 객체를 정의해 놓은 것                         - 클래스를 구체화 한 것
- 객체를 생성할 때 사용     =&gt; 구체화 객체화     - 실제로 동작하는 것
- 데이터 타입                                  - 메모리에 생성된 데이터
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">현실세계</span><span class="o">&gt;</span>

  <span class="n">철수</span>            <span class="n">영희</span>          <span class="o">=&gt;</span> <span class="n">객체</span>
<span class="nl">이름:</span> <span class="n">철수</span>      <span class="nl">이름:</span> <span class="n">영희</span>
<span class="nl">나이:</span> <span class="mi">40</span>        <span class="nl">나이:</span> <span class="mi">38</span>        <span class="o">=&gt;</span> <span class="n">상태</span><span class="o">,</span> <span class="n">속성</span> <span class="o">-</span> <span class="n">변수</span><span class="o">,</span> <span class="n">필드</span>
<span class="nl">배고픔:</span> <span class="no">X</span>       <span class="nl">배고픔:</span> <span class="no">X</span>

<span class="n">먹는다</span>          <span class="n">먹는다</span>          <span class="o">=&gt;</span> <span class="n">기능</span><span class="o">,</span> <span class="n">행위</span> <span class="o">-</span> <span class="n">메서드</span><span class="o">,</span> <span class="n">함수</span>
<span class="n">일한다</span>          <span class="n">일한다</span>

<span class="o">&lt;</span><span class="n">프로그래밍</span><span class="o">&gt;</span>
<span class="o">-</span><span class="n">추상화</span><span class="o">-</span>
<span class="nc">Person</span>                         <span class="o">=&gt;</span> <span class="n">클래스</span>
<span class="nc">String</span> <span class="nl">name:</span>
<span class="kt">int</span> <span class="nl">age:</span>                       <span class="o">=&gt;</span> <span class="n">멤버변수</span>
<span class="kt">boolean</span> <span class="nl">isHungry:</span>

<span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span>                     <span class="o">=&gt;</span> <span class="n">멤버메서드</span>
<span class="kt">void</span> <span class="nf">work</span><span class="o">()</span>

<span class="o">-</span><span class="n">구체화</span><span class="o">-</span>                       <span class="o">=&gt;</span> <span class="n">객체</span><span class="o">(</span><span class="n">메모리</span> <span class="n">어딘가에</span> <span class="n">존재해야</span> <span class="n">사용할</span> <span class="n">수</span> <span class="n">있다</span><span class="o">)</span>
<span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
<span class="n">p</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"철수"</span><span class="o">;</span>
<span class="n">p</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
<span class="n">p</span><span class="o">.</span><span class="na">isHungry</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

<span class="n">p</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
<span class="n">p</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
</code></pre></div></div>

<p><strong><em>추상화로 클래스 만들고 구체화로 객체 사용하기</em></strong><br />
<strong><em>Person 클래스 작성하기</em></strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Public</span> <span class="kd">class</span> <span class="nc">Person</span><span class="o">{</span>
  <span class="c1">//멤버 변수 - 속성</span>
  <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
  <span class="kt">boolean</span> <span class="n">isHungry</span><span class="o">;</span>

  <span class="c1">//멤버 메서드 - 동작</span>
  <span class="kt">void</span> <span class="nf">eat</span><span class="o">(){</span>
    <span class="n">isHungry</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"먹기"</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kt">void</span> <span class="nf">work</span><span class="o">(){</span>
    <span class="n">isHungry</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"일하기"</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="nc">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
    <span class="n">p1</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"홍길동"</span><span class="o">;</span>
    <span class="n">p1</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="n">p1</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>

    <span class="nc">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
    <span class="n">p2</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"장길산"</span>
    <span class="n">p2</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="n">p2</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="n">p1</span> <span class="n">과</span> <span class="n">p2는</span> <span class="n">같은</span> <span class="n">타입일</span> <span class="n">뿐</span><span class="o">,</span> <span class="n">데이터가</span> <span class="n">공유되거나</span> <span class="n">하지는</span> <span class="n">않는다</span><span class="o">.</span>
</code></pre></div></div>

<h3 id="객체-생성과-메모리">객체 생성과 메모리</h3>

<p><img src="/assets/forPost/JVM_1.png" /> <br />
<img src="/assets/forPost/JVM_2.png" /></p>

<h2 id="1-변수">1. 변수</h2>

<blockquote>
  <p>변수의 종류</p>

  <ul>
    <li><strong>타입에 따른 분류</strong>
      <blockquote>
        <table>
          <thead>
            <tr>
              <th style="text-align: center">변수 종류</th>
              <th>특징</th>
              <th style="text-align: center">비고</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center">Primitive Type</td>
              <td>기본 8가지 type의 변수</td>
              <td style="text-align: center">int i, char c, float f…</td>
            </tr>
            <tr>
              <td style="text-align: center">Reference Type</td>
              <td>나머지 모든 것(객체 참조)</td>
              <td style="text-align: center">String s, int[] a, Person p…</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
    </li>
    <li><strong>선언 위치에 따른 분류</strong>
      <blockquote>
        <table>
          <thead>
            <tr>
              <th style="text-align: center">종류</th>
              <th style="text-align: center">변수 종류</th>
              <th>선언 위치</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center">멤버 변수</td>
              <td style="text-align: center">클래스 멤버변수</td>
              <td>클래스 영역 (static keyword)</td>
            </tr>
            <tr>
              <td style="text-align: center"> </td>
              <td style="text-align: center">인스턴스 멤버 변수</td>
              <td>클래스 영역</td>
            </tr>
            <tr>
              <td style="text-align: center">지역 변수</td>
              <td style="text-align: center">지역 변수</td>
              <td>함수 내부</td>
            </tr>
            <tr>
              <td style="text-align: center"> </td>
              <td style="text-align: center">파라미터 변수</td>
              <td>함수 선언부</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">VariableType</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">instanceVariable</span><span class="o">;</span> <span class="c1">//인스턴스 멤버 변수</span>
  <span class="kd">static</span> <span class="kt">int</span> <span class="n">classVariable</span><span class="o">;</span> <span class="c1">//클래스 멤버 변수</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span><span class="c1">//파라미터 변수</span>
    <span class="kt">int</span> <span class="n">localVariable</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">//로컬변수</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span><span class="c1">//로컬변수</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>인스턴스 멤버 변수의 특징</p>

  <ul>
    <li>선언 위치 : 클래스{}영역에 선언</li>
    <li>변수의 생성 : 객체가 만들어질 때 객체 별로 생성됨
      <ul>
        <li>생성 메모리 영역 : heap</li>
      </ul>
    </li>
    <li>변수의 초기화 : 타입 별로 default 초기화</li>
    <li>변수에 접근 : 객체 생성 후(메모리에 올린 후) 객체 이름(소속)으로 접근
      <ul>
        <li>객체를 만들 때 마다 객체 별로 생성 -&gt; 객체마다 고유한 상태(변수 값) 유지</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
<span class="n">p1</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"김경호"</span><span class="o">;</span>
<span class="nc">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
<span class="n">p2</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"호경김"</span><span class="o">;</span>
<span class="c1">//////////////////////////////////// 여기까지 작성, 18일 2번째 5:22</span>
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Java" /><category term="Java" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Java 01. 기본 문법 및 응용 (Java의 특징, 변수, 데이터 타입)]</title><link href="http://localhost:4000/java/Java_Basic-1/" rel="alternate" type="text/html" title="[Java 01. 기본 문법 및 응용 (Java의 특징, 변수, 데이터 타입)]" /><published>2022-01-17T00:00:00+09:00</published><updated>2022-01-17T00:00:00+09:00</updated><id>http://localhost:4000/java/Java_Basic%201</id><content type="html" xml:base="http://localhost:4000/java/Java_Basic-1/"><![CDATA[<p><br /></p>

<h2 id="0-자바의-특징">0. 자바의 특징</h2>

<blockquote>
  <ul>
    <li>OOP is <strong>A.P.I.E</strong> ?
      <ul>
        <li>OOP(Object-Oriented-Programming = 객체지향 프로그래밍) is<br />
<strong>Abstraction. Polymorphism. Inheritance. Encapsulation</strong></li>
      </ul>
    </li>
    <li><strong>GC</strong>(Garbage Collection)
      <ul>
        <li>더 이상 사용하지 않는 메모리를 자동으로 정리하는 기능</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="1-변수">1. 변수</h2>

<blockquote>
  <ul>
    <li>수학에서는 변하는 수 x</li>
    <li>컴퓨터에서는 메모리 공간(그릇)</li>
    <li>메모리 공간에 값(value)을 할당(assign) 후 사용</li>
    <li>공간의 크기는 타입별로 달라짐</li>
  </ul>
</blockquote>

<h2 id="2-type-이란">2. Type 이란?</h2>

<blockquote>
  <ul>
    <li>데이터의 종류</li>
    <li><strong>Primitive Type</strong> (기본형)
      <ul>
        <li>미리 정해진 크기의 Memory Size로 표현</li>
        <li>변수 자체에 값 저장</li>
      </ul>
    </li>
    <li><strong>Reference Type</strong> (참조형)
      <ul>
        <li>크기가 미리 정해질 수 없는 데이터의 표현</li>
        <li>변수에는 실제 값을 참조할 수 있는 주소만 저장</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>Primitive Type
      <blockquote>
        <table>
          <thead>
            <tr>
              <th style="text-align: center">구분</th>
              <th>Type</th>
              <th style="text-align: center">bit 수</th>
              <th>값</th>
              <th>Wrapper Class</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center">논리형</td>
              <td>boolean</td>
              <td style="text-align: center"> </td>
              <td>true/false</td>
              <td>Boolean</td>
            </tr>
            <tr>
              <td style="text-align: center">정수형</td>
              <td>byte</td>
              <td style="text-align: center">8</td>
              <td>-2^7 ~ 2^7-1 (-128 ~ 127)</td>
              <td>Byte</td>
            </tr>
            <tr>
              <td style="text-align: center"> </td>
              <td>short</td>
              <td style="text-align: center">16</td>
              <td>-2^15 ~ 2^15-1 (-32768 ~ 32767)</td>
              <td>Short</td>
            </tr>
            <tr>
              <td style="text-align: center"> </td>
              <td>int</td>
              <td style="text-align: center">32</td>
              <td>-2^31 ~ 2^31-1 (-2147483648 ~ 2147483647, 대략 20억)</td>
              <td>Integer</td>
            </tr>
            <tr>
              <td style="text-align: center"> </td>
              <td>long</td>
              <td style="text-align: center">32</td>
              <td>-2^31 ~ 2^31-1 (-9223372036854775808 ~ 9223372036854775807)</td>
              <td>Long</td>
            </tr>
            <tr>
              <td style="text-align: center">실수형</td>
              <td>float</td>
              <td style="text-align: center">32</td>
              <td>float f = 0.1234567890123456789f; =&gt; 0.12345679</td>
              <td>Float</td>
            </tr>
            <tr>
              <td style="text-align: center"> </td>
              <td>double</td>
              <td style="text-align: center">64</td>
              <td>double d = 0.1234567890123456789; =&gt; 0.12345678901234568</td>
              <td>Double</td>
            </tr>
            <tr>
              <td style="text-align: center">문자형</td>
              <td>char</td>
              <td style="text-align: center">16</td>
              <td>\u0000 ~ \uffff(0~2^16-1)</td>
              <td>Character</td>
            </tr>
          </tbody>
        </table>

        <ul>
          <li><strong>총 8개</strong></li>
        </ul>
      </blockquote>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>Reference Type
      <blockquote>
        <ul>
          <li>나머지 모든 데이터 타입(String, int[], Node와 같은 사용자 정의 타입 …)</li>
        </ul>
      </blockquote>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기본문제</span>
<span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i2</span><span class="o">);</span>

<span class="c1">//실행결과</span>
<span class="c1">//overflow</span>
</code></pre></div></div>

<h2 id="3-형-변환type-casting">3. 형 변환(Type Casting)</h2>

<blockquote>
  <ul>
    <li>변수의 타입을 다른 타입으로 변환하는 것
      <ul>
        <li>char &lt;= =&gt; int</li>
      </ul>
    </li>
    <li>Primitive는 Primitive끼리, Reference는 Reference기리 형 변환 가능
      <ul>
        <li>boolean은 다른 기본 타입과 호환되지 않음</li>
        <li>기본 타입과 참조형의 형 변환을 위해서 Wrapper 클래스 활용</li>
      </ul>
    </li>
    <li>형 변환 방법
      <ul>
        <li>형 변환 연산자(괄호) 사용</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">100.5</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">d</span><span class="o">;</span>
<span class="c1">// d = 100.5</span>
<span class="c1">// result = 100</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li>타입의 표현 범위
      <ul>
        <li>byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</li>
        <li>char  -&gt; int …</li>
      </ul>
    </li>
    <li>타입의 표현 범위가 커지는 방향으로 할당할 경우는 묵시적 형 변환 발생</li>
    <li>명시적 형 변환은 값 손실이 발생할 수 있다.</li>
    <li>묵시적 형 변환은 값 손실 걱정없이 JVM이 서비스 해줌</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//묵시적 형 변환(값 손실 x)       //명시적 형 변환 (값 손실 o)</span>
<span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>                    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">300</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">b</span><span class="o">;</span>                 <span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span><span class="n">i</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//기본문제</span>
<span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i2</span><span class="o">);</span> <span class="c1">// -2147483648</span>

<span class="kt">long</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">l1</span><span class="o">);</span> <span class="c1">// -2147483648</span>

<span class="kt">long</span> <span class="n">l2</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)(</span><span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">l2</span><span class="o">);</span> <span class="c1">// -2147483648</span>

<span class="kt">long</span> <span class="n">l3</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">(</span><span class="n">i1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">l3</span><span class="o">);</span> <span class="c1">// 2147483648</span>

<span class="kt">int</span> <span class="n">i3</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">*</span> <span class="mi">1000000</span> <span class="o">/</span> <span class="mi">100000</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">i4</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">/</span> <span class="mi">100000</span> <span class="o">*</span> <span class="mi">100000</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i3</span> <span class="o">+</span> <span class="s">" : "</span> <span class="o">+</span> <span class="n">i4</span><span class="o">);</span> <span class="c1">// -7273 : 1000000 , 컴퓨터는 앞에서부터 계산하기 때문에</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">66</span><span class="o">;</span>
<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span><span class="n">k</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">);</span> <span class="c1">// B</span>

<span class="n">c</span><span class="o">=</span><span class="sc">'A'</span><span class="o">;</span>
<span class="n">k</span><span class="o">=</span><span class="n">c</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">k</span><span class="o">);</span> <span class="c1">//65</span>

<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="c1">//3</span>

<span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">);</span> <span class="c1">//3.0</span>

<span class="kt">float</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">10</span><span class="n">f</span> <span class="o">/</span> <span class="mi">3</span><span class="no">F</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">);</span> <span class="c1">//3.3333333</span>

<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">10</span><span class="n">d</span> <span class="o">/</span> <span class="mi">3</span><span class="no">D</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d</span><span class="o">);</span> <span class="c1">//3.3333333333333335</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="mi">10</span><span class="o">/</span><span class="mi">3</span><span class="o">)*</span><span class="mi">3</span><span class="o">);</span> <span class="c1">//9</span>
</code></pre></div></div>

<h3 id="wrapper-클래스">Wrapper 클래스?</h3>

<blockquote>
  <p><strong>래퍼 클래스(Wrapper Class)</strong>는 산술연산을 위해 정의된 클래스가 아니므로 인스턴스에 저장된 값을 변경할 수 없다.<br />
단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스 값만을 참고할 수 있다.<br />
<strong>박싱</strong> : 기본타입 -&gt; 래퍼클래스 / <strong>언박싱</strong> : 래퍼클래스 -&gt; 기본타입 (JDK 1.5부터는 컴파일러가 자동처리, 오토 박싱, 오토 언박싱)</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="mi">17</span><span class="o">);</span> <span class="c1">//박싱</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span> <span class="c1">//언박싱</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

<span class="nc">Character</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">'X'</span><span class="o">;</span> <span class="c1">// 오토박싱, Character ch = new Character('X')</span>
<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ch</span><span class="o">;</span> <span class="c1">//오토언박싱, char c = ch.charValue();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

<span class="c1">//실행결과</span>
<span class="c1">//17</span>
<span class="c1">//X</span>
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Java" /><category term="Java" /><summary type="html"><![CDATA[]]></summary></entry></feed>