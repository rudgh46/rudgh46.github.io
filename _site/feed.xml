<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-06T02:03:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">경호의 블로그</title><subtitle>느리더라도 천천히 성장하는 블로그입니다.</subtitle><author><name>김경호</name></author><entry><title type="html">[데이터 크롤링의 세계]</title><link href="http://localhost:4000/daily%20contents/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%AC%EB%A1%A4%EB%A7%81%EC%9D%98-%EC%84%B8%EA%B3%84/" rel="alternate" type="text/html" title="[데이터 크롤링의 세계]" /><published>2022-07-29T00:00:00+09:00</published><updated>2022-07-29T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%81%AC%EB%A1%A4%EB%A7%81%EC%9D%98%20%EC%84%B8%EA%B3%84</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%AC%EB%A1%A4%EB%A7%81%EC%9D%98-%EC%84%B8%EA%B3%84/"><![CDATA[<p><br /></p>

<h1 id="데이터-크롤링">데이터 크롤링</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>누군가가 인터넷에 올린 정보를 수집해 사용하는 기술
-&gt; 불법적인 행위로 이어질 수 있음.
</code></pre></div></div>

<h2 id="q1-인터넷상에서-자동으로-데이터를-수집하는-방법에는-어떤-것들이-있나요">Q1. 인터넷상에서 자동으로 데이터를 수집하는 방법에는 어떤 것들이 있나요?</h2>

<h3 id="1-openapi-등-공개된-api-를-사용">1) OpenAPI 등 공개된 API 를 사용</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>공공데이터포털, NaverDevelopers, Mydata 허브 등
</code></pre></div></div>

<h3 id="2-http-get-method">2) HTTP Get Method</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 정보가 게시되어 있는 대상 웹사이트를 HTTP GET을 사용하여 HTML 코드를 얻고 Text Parsing해서 사용
- 거의 대부분의 언어로 구현 가능
- 동적으로 변하는 웹페이지에는 활용이 어려움
</code></pre></div></div>

<h3 id="3-selenium-web-driver">3) Selenium Web Driver</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 본디 테스트를 위해 개발되었으나 데이터 수집용으로 활용 중
- 웹 브라우저 인스턴스를 생성해 실행시킨 후 해당 인스턴스를 컨트롤
- 웹사이트 테스트 자동화 목적으로 개발
- 가상의 브라우저를 실행시키는 Headless Mode 등이 있음
- HTTP GET 방식에 비해 느리고 불안정적이나 보다 많은 웹사이트를 스크래핑 가능
- 사람이 하는 것과 유사한 자동화 방법
</code></pre></div></div>

<h3 id="4-사람이-수작업으로-데이터를-수집하는-방법ㄴㅇㄱ">4) 사람이 수작업으로 데이터를 수집하는 방법(ㄴㅇㄱ)</h3>

<h2 id="q2-웹-크롤러와-웹-스크랩퍼는-같은-의미인가요">Q2. 웹 크롤러와 웹 스크랩퍼는 같은 의미인가요?</h2>

<h3 id="웹-크롤러-vs-웹-스크래퍼">웹 크롤러 vs 웹 스크래퍼</h3>

<p>** 웹 크롤러(Web Crawler) **</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>조직적, 자동화된 방법으로 웹을 탐색/수집하는 프로그램
ex) 구글, 네이버 등의 검색엔진 결과 데이터를 수집하기 위한 봇(Bot)
</code></pre></div></div>

<p>** 웹 스크래퍼(Web Scrapper) **</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>웹사이트에서 정보를 추출하는 프로그램
ex) 상품별 가격을 알기 위해 해당 상품을 파는 페이지들의 가격을 추출
</code></pre></div></div>

<ul>
  <li>크롤러보다는 대부분 단순 스크래퍼 개발 수요가 많음.</li>
  <li>우리나라에서는 많은 기업들이 같은 의미로 혼용.</li>
</ul>

<h2 id="q3-웹-크롤링은-불법이-아닌가요">Q3. 웹 크롤링은 불법이 아닌가요?</h2>

<h3 id="크롤링은-불법인가">크롤링은 불법인가?</h3>

<p>** 불법에 노출되기 쉬운 기술 중 하나라 주의 **
** 웹사이트의 홈디렉토리에 위치한 robots.txt 파일을 열어보고 해당 사이트의 정책을 준수하지 않는다면 불법 **</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>크롤링할 웹사이트의 URL의 /robots.txt로 접속하면 크롤링해도 되는 파일, 안 되는 파일을 Disallow와 Allow로 구분해서 명시해 놓음.
</code></pre></div></div>

<p>** 크롤링한 자료를 상업적인 용도로 사용하면 불법 **</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>국내에서는 불법, 해외(미국)에서는 합법 판결이 난 전례가 있음
</code></pre></div></div>

<p>** 원작자의 수익을 해치지 않았다면 합법 **
** 비상업적인 용도라 하더라도 원작자에게 불이익을 주면 불법 **
** 크롤러를 활용해 고의적으로 Abusing -</p>

<h2 id="qa">Q&amp;A</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 이전 기수에서 크롤링으로 문제가 된 사례가 있었는지?
A. 보통 상담을 받고 진행하기 때문에 미연에 방지된다.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 셀레니움을 사용할 때 렌더링되기 전에 실행되는 경우가 많아 대량의 사이트 데이터를 수집할 때 오류가 발생. 줄일 수 있을지.
A. 한 페이지가 다 출력될 때까지 기다리게 하는 커맨드가 있다. 딜레이를 줘서 기다리게 하는 건 아마추어적인 방식. 레퍼런스에서 메서드 알아보기.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 가장 크롤링을 잘 활용한 프로젝트는?
A. 토스.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 데이터가 많이 필요한 경우 수많은 URL을 찾아봐야 할 수도 있는데 방대한 데이터가 필요한 경우 수십만 번 HTTP 요청을 보내서 크롤링을 하는지?
A. 한 사이트에 한 번 요청하면 데이터는 크롤링 완료. 수십만 번 같은 사이트에 요청하면 소송감.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. API 요청을 너무 많이 해서 차단된 케이스가 있다고 하는데 어느 정도 해야 그런 제한이 걸릴지.
A. 사이트의 운영정책에 따라 별개.
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[파이어베이스 소개]</title><link href="http://localhost:4000/daily%20contents/%ED%8C%8C%EC%9D%B4%EC%96%B4%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%86%8C%EA%B0%9C/" rel="alternate" type="text/html" title="[파이어베이스 소개]" /><published>2022-07-27T00:00:00+09:00</published><updated>2022-07-27T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%ED%8C%8C%EC%9D%B4%EC%96%B4%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EC%86%8C%EA%B0%9C</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%ED%8C%8C%EC%9D%B4%EC%96%B4%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%86%8C%EA%B0%9C/"><![CDATA[<p><br /></p>

<h2 id="db-로그인-호스팅에-사용">DB, 로그인, 호스팅에 사용…</h2>

<h2 id="firebase란">Firebase란?</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>개발, 성장, 수익 등에 쓰임
</code></pre></div></div>

<h3 id="1-인증">1. 인증</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FirebaseUI는 Firebase 인증 SDK를 바탕으로 빌드된 라이브러리로, 앱에서 사용할 수 있는 삽입형 UI 흐름을 제공. 이점은 다음과 같다.
- 여러 제공업체
- 계정 연결
- 맞춤 설정
- 간편 가입 및 자동 로그인
- 현자화된 UI
- 익명 사용자 업그레이드

* 구글 로그인 Kotlin, JS, C++, flutter 등 지원
</code></pre></div></div>

<h3 id="2-데이터-베이스">2. 데이터 베이스</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Firebase는 실시간 데이터 동기화를 지원하며 클라이언트에서 액세스할 수 있는 2가지 클라우드 기반 데이터베이스 솔루션을 제공.
* Cloud Firestore는 모바일 앱 개발을 위한 최신 데이터베이스로서 직관적인 새로운 데이터 모델, 실시간 데이터베이스보다 풍부하고 빠른 쿼리와 원활한 확장성 제공.
* 실시간 데이터베이스는 Firebase기존 데이터베이스로, 여러 클라이언트에서 실시간으로 상태를 동기화해야 하는 모바일 앱을 위한 효율적이고 지연 시간이 짧은 솔루션.

# firestore가 여러 단점을 보강한 최신 DB이므로 추천.
# 실시간 수신대기-Vue나 React에서 작성(Web, IOS, Kotlin, flutter, python, C++, go, Unity, ruby, C# 등 지원)
</code></pre></div></div>

<h3 id="3-스토리지">3. 스토리지</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Firebase용 Cloud Storage
- 사진, 동영상 등의 사용자 제작 콘텐츠를 저장하고 제공해야 하는 앱 개발자를 위해 제작
- Blob 또는 File에서 업로드, Byte 배열, 문자열에서 업로드
</code></pre></div></div>

<h3 id="4-호스팅">4. 호스팅</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Vue나 React로 코드 작성 후 압축, 별도 웹 서버에 설정 없이 Firebase에 올리면 호스팅 사이트 제공.
- 자신만의 도메인을 갖고 싶다면 따로 결제.
</code></pre></div></div>

<h3 id="5-function">5. Function</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Firebase용 Cloud Functinos
- Firebase 기능과 HTTPS 요청에 의해 트리거되는 이벤트에 응답하여 백엔드 코드를 자동으로 실행할 수 있는 서버리스 프레임워크.
- Google의 클라우드 서비스에 저장되고 관리형 환경에서 실행.
- 자체 서버를 관리하고 크기를 확장할 필요 없음.
</code></pre></div></div>

<h2 id="qa">Q&amp;A</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 백엔드 서버 따로 두고 유저인증 부분만 Firebase 사용 가능한지?
A. 가능함.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 대규모 트래픽에서 Firebase가 적합하지 않다고 하는데 어느 정도까지가 사용에 적합한가?
A. 대규모 트래픽에서 장애가 있었다는 소식을 들은 적은 없음. 일반적인 스타트업이나 싸피 프로젝트에서는 충분.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 기업에서 많이 사용하는지?
A. 전체적으로 다 사용하는 기업은 얼마 없으나 인증, 호스팅, Function 등 기능 하나를 사용하는 기업은 다수.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 계정 관련 이외에도 Firebase의 유용한 점은?
A. 인증 이외에도 Key-Value 기반 DB, Storage, Function, Cloud message(앱에 메세지 오는 것) 등등 가능.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 서버리스하게 만들어주는 Function 통해서, DB 접근해서 데이터 줄 수 있을지.
A. Function이 Node.js, HTTP 기능 지원. REST 구현하고 데이터 전송.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. Firebase로 API 요청에 대한 응답을 각각 실행 가능한가?
A. 가능.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 이미지 관련 처리만 Firebase로 처리, 백엔드 서버를 따로 두는 것도 가능한가?
A. 가능.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. Spring 백엔드가 있는 경우에 Firebase를 쓰는 것이 어떤 이점이 있을지.
A. 다른 기능을 사용하는 것을 추천. 인증이나 message, storage 등을 이용하면 좋을 것.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 이런 좋은 기능이 왜 무상인지?
A. 일정 이상의 트래픽을 넘어가면 유료.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 기존에 잘 작동하던 프로젝트로 Firebase로 이식하는 게 더 나은 경우가 있을지? 유지관리비용, 보수성, 편리성 측면 등에 대해 의문.
A. 코드가 줄어들기 때문에 유지관리비용 등은 감소.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. GCP 콘솔에서 제공하는 Firebase와 홈페이지에서 제공하는 것과 차이가 있을지?
A. GCP 콘솔이 더 방대하다고 함.
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[개발자와 UX]</title><link href="http://localhost:4000/daily%20contents/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%99%80-UX/" rel="alternate" type="text/html" title="[개발자와 UX]" /><published>2022-07-26T00:00:00+09:00</published><updated>2022-07-26T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%99%80%20UX</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%99%80-UX/"><![CDATA[<p><br /></p>

<h2 id="uxui-정의">UX/UI 정의</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UX(User Experience) : 사용자 경험
UI(User Interface) : 사용자 상호 작용
- 디지털 기기(어느 플랫폼에서?), 사용자(누가?), 상호 작용(어떻게 사용할 것인가?)과 관련
</code></pre></div></div>

<p><strong>_ UX/UI 정의 : 어느 플랫폼에서 누가 어떻게 사용할 것인가를 고민하는 일 _</strong></p>

<h3 id="현업에서의-uiux">현업에서의 UI/UX</h3>

<ul>
  <li>회사 규모에 따라 역할이 달라짐</li>
  <li>사용자 : 기획자 PM_ex) 삼성전자</li>
  <li>상호 작용 : 디자이너</li>
  <li>디지털 기기 : 개발자 IT회사_ex) 네이버, 카카오</li>
</ul>

<h3 id="개발자-관점의-현업">개발자 관점의 현업</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>기획자 -&gt; 디자이너 -&gt; 개발자
- 플랫폼 스펙에 없는 기능들 요구
- 결과물에 대한 책임은 개발자, 가만히 있으면 피해를 입음
</code></pre></div></div>

<h4 id="스펙에-없는-기능-예시">스펙에 없는 기능 예시</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 플랫폼에 없는 컴포넌트(IOS에는 있으나 안드로이드에는 없는 기능)
2. 해상도 변화를 고려하지 않은 디자인(늘어나지 않는 이미지와 늘어나는 기준에 대한 가이드)
3. 구현할 수 없는 인터렉션(애니메이션)
4. 예외처리 되지 않은 기능들("이 상황에는 어떤 화면을 표시해야 하죠?")
5. 폰트의 line height(웹 환경과 디자인 툴의 표시 차이)
</code></pre></div></div>

<h3 id="현업-관점에서-유능한-개발자">현업 관점에서 유능한 개발자</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 요구 사항에 대한 [가능/불가능/예외 사항 판단 능력]
- 이를 정확하게 납득시킬 수 있는 ***설득력***(가장 중요)
- 그 기능을 요구하게 된 기획자, 디자이너의 의도 파악
- 최대한 요구와 일정에 맞출 수 있는 개발 실력
* 생각보다 (훨씬) 설득이 잘 안 된다...
</code></pre></div></div>

<h4 id="설득이-잘-안-되는-이유">설득이 잘 안 되는 이유</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 설명할 수준으로 알고 있기 어려움
- 개발자에 대한 인식(수동적인 태도 "그건 안 돼요" -&gt; 그냥 하기 싫어서 안 된다고 말하고 있다는 인상을 주면 안 됨)
- *** 지속적인 협업을 통해 나에 대한 신뢰 확보 ***
</code></pre></div></div>

<h3 id="ui-이해의-중요성">UI 이해의 중요성</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 각 영역에 대한 이해가 높을수록 일을 하기 수월함
- 한 가지 전문적인 영역 +@ 가 높은 연봉을 만든다
</code></pre></div></div>

<h3 id="백엔드-개발자에게-uiux">백엔드 개발자에게 UI/UX?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 백엔드 개발자도 UI/UX 이해가 필요한가요?
- 만들고 있는 기능이 어디에 쓰일 것인지 알고 있어야 함.(API 설계 및 예외 처리 등)
- 개발자 실력 측정은 동료의 평가로부터 나온다.
</code></pre></div></div>

<h2 id="uiux-개발-특징">UI/UX 개발 특징</h2>

<h3 id="좋은-ux란">좋은 UX란</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 기존 불편함을 개선(카카오뱅크)
- 새로운 경험(넷플릭스)
- 서비스의 목적/의도는 무엇인가요?
- 사용자에게 어떤 느낌을 주고 있나요?
</code></pre></div></div>

<h3 id="ux의-어려움">UX의 어려움</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 정답이 없는 분야/예측하기 힘든 분야
- 결과(데이터)를 바탕으로 설계
- 사용자 행동 분석 필요 -&gt; 툴 이용
- 학습의 분야 -&gt; 여러 사례들을 분석한 책들을 학습하자
</code></pre></div></div>

<h3 id="uiux-개발-특징-1">UI/UX 개발 특징</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 뮤직 플레이어 서비스를 개발한다고 가정
- UI/UX 설계를 담당하게 되었다 가정
* 익숙한 UI/UX도 직접 설계하려면 기억하기 어려움
</code></pre></div></div>

<h3 id="uiux-학습-방법">UI/UX 학습 방법</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 서비스의 UI/UX를 의식하며 사용
- 기존 서비스들의 UI/UX를 분석 -&gt; 평소 관심이 가장 중요
</code></pre></div></div>

<h3 id="ui-학습-방법">UI 학습 방법</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 디자인 영감 얻기(Behance, Dribble, Pinterest)
- 폰트 크기/간격, 여백/색상의 조합을 규칙화해 보기
</code></pre></div></div>

<h3 id="front-end-개발자의-매력">Front-End 개발자의 매력</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 프로젝트, 서비스의 첫 이미지는 화면에서 결정
- 서비스의 평가는 Client 품질에서 결정
- 큰 이슈는 Back-End에서 나온다.
</code></pre></div></div>

<h3 id="인정받는-front-end-개발자">인정받는 Front-End 개발자?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 개발 실력 == 결과물 또는 동료들의 평가
</code></pre></div></div>

<h3 id="ux-사례">UX 사례</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 요구사항 : 음악에 따라 배경 사항을 바꾸고 싶어요.
* 어떤 색상을 선택하지? 미리 정한 랜덤 색상 or 앨범 색상 느낌? -&gt; 앨범 색상은 어떻게 얻지? 이미지에서 평균 값 색상 추출? 라이브러리가 있나?
</code></pre></div></div>

<p><strong>_ 개발자의 선택 : 그 기능이 정말 중요한가? 개발 비용은? 개발자의 애정이 있는가? _</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 개발 예외 케이스 발생 : 너무 밝거나 어두운 경우
* 기능을 취소하고 롤백/해결 방안 고민 -&gt; 어둡거나 밝을 때 분기를 이용할 수 있을까? -&gt; 색상 대비(color contrast)를 참고해 보자.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 중요하지만 기획/디자인 단계에서 예상하지 못한 UX
* 다른 곳에서는 어떻게 하고 있나?(음원 사이트 참조) 어떻게 구현해야 할까?
</code></pre></div></div>

<p><strong>_ 개발 팁 <em>**
**</em> 사소한 부분이 실력 차이를 만듭니다. _</strong></p>

<h3 id="현업-uiux">현업 UI/UX</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* 암호화폐 자동 거래 봇 서비스 UI를 만듭니다.
- 거래소 API를 활용하여 거래소 계정 연결
- 유저가 작성한 알고리즘 매수/매도
- 동시 여러 개 봇 운용 가능
- 유저가 작성한 알고리즘 백테스트 기능
- 유저 간 알고리즘 공유 기능
</code></pre></div></div>

<h2 id="qa">Q&amp;A</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 퍼블리싱은 어느 정도까지 공부해야 하는지?
A. Todo 앱이나 레이아웃을 잡을 정도의 UI 제작 연습. CSS는 생각보다 오래 걸리지 않음.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 웹다자인 기능사 자격증은 따는 것이 좋은지?
A. 자격증도 좋으나 개인 포토폴리오 사이트를 하나 만드는 것이 좋음.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 추가적으로 참고할 수 있는 다른 디자이너 분.
A. 구글 인터렉티브 디벨로퍼.
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Project DB설계]</title><link href="http://localhost:4000/daily%20contents/Project-DB%EC%84%A4%EA%B3%84/" rel="alternate" type="text/html" title="[Project DB설계]" /><published>2022-07-22T00:00:00+09:00</published><updated>2022-07-22T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/Project%20DB%EC%84%A4%EA%B3%84</id><content type="html" xml:base="http://localhost:4000/daily%20contents/Project-DB%EC%84%A4%EA%B3%84/"><![CDATA[<p><br /></p>

<h2 id="1-db-설계의-목적">1. DB 설계의 목적</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 프로젝트, 명세서 등의 정보 요구사항에 대한 정확한 이해
- 분석자, 개발자, 사용자 간의 원활한 의사소통 수단
- 데이터 중심의 분석 방법
- 현행 시스템만이 아닌 신규 시스템 개발의 기초 제공
</code></pre></div></div>

<ul>
  <li>설계를 대충 하면 기능 한 개 추가될 때마다 DB와 관련된 이미 개발된 프로그램도 함께 뜯어고쳐야 하는 경우가 발생한다.</li>
</ul>

<h2 id="2-설계를-위한-요구사항-분석">2. 설계를 위한 요구사항 분석</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 데이터베이스에 대한 사용자의 요구사항을 수집하고 분석해서 요구사항 기능 명세서를 작성
</code></pre></div></div>

<h2 id="3-개념적-설계">3. 개념적 설계</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 작성한 요구사항 명세서에서 데이터베이스를 구성하는데 필요한 개체, 속성, 개체 간의 관계를 추출하여 ERD를 생성
1. 개체와 속성을 추출한다.
a. 대부분 명사로 선별한다.
2. 개체 간의 관계를 추출한다.
a. 대부분 동사로 선별한다.
b. 관계에 속한 속성도 있을 수 있다.
c. 1:1, 1:N, N:M
d. 필수적인 참여, 선택적인 참여
</code></pre></div></div>

<h3 id="3-1-개체와-속성">3-1. 개체와 속성</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 요구사항에서 개체는 대부분 명사로 이루저여 있지만, 속성과 구별하여 추출한다.
</code></pre></div></div>

<h3 id="3-2-개체-간의-관계">3-2. 개체 간의 관계</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 개체 간의 관계는 여러가지로 분류해서 정의된다.
</code></pre></div></div>

<h3 id="3-3-개념-설계-기반으로-erd-생성">3-3. 개념 설계 기반으로 ERD 생성</h3>

<h2 id="4-논리적-설계">4. 논리적 설계</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 모든 개쳬는 릴레이션(Table)으로 변환
- N:M 관계는 릴레이션으로 변환
- 1:N 관계는 외래키로 표현
- 1:1 관계는 외래키로 표현
- 다중 값 속성은 독립 릴레이션으로 변환
</code></pre></div></div>

<h3 id="4-1-모든-개체는-릴레이션으로-변환">4-1. 모든 개체는 릴레이션으로 변환</h3>

<h3 id="4-2-nm-관계는-릴레이션으로-변환">4-2. N:M 관계는 릴레이션으로 변환</h3>

<h3 id="4-3-1n-관계는-외래키fk로-표현">4-3. 1:N 관계는 외래키(FK)로 표현</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 일반적으로 1:N 관계에서 1측 개체의 기본키를 N측 릴레이션에 포함시키고 외래키(FK)로 지정
</code></pre></div></div>

<h3 id="4-4-11-관계는-외래키로-표현">4-4. 1:1 관계는 외래키로 표현</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 일반적 1:1 관계는 외래키(FK)를 서로 주고 받는다.
</code></pre></div></div>

<h3 id="4-5-다중값-속성은-독립-릴레이션으로">4-5. 다중값 속성은 독립 릴레이션으로</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 릴레이션에서는 다중 값 속성으로 가질 수 없으므로 다중값 속성은 별도의 릴레이션으로 생성해야 함.
</code></pre></div></div>

<h2 id="5-물리적-스키마-및-구현">5. 물리적 스키마 및 구현</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- ERD를 실제 테이블로 생성한다.(Workbench 같은 DB Tool이나 SQL 스크립트 사용으로도 가능해야 함)
</code></pre></div></div>

<h2 id="반정규화란">반정규화란?</h2>

<p>** 정규화된 엔티티타입, 속성, 관계를 시스템의 성능 향상, 개발과 운영의 단순화를 위해 모델을 통합하는 프로세스 **</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>** 정규화 모델 **
- SQL 작성이 용이하지 않고 과다한 테이블 조인이 발생하여 성능이 저하될 가능성이 높다.
** 반정규화 모델 **
- 같은 데이터가 여러 테이블에 걸쳐 존재하므로 무결성이 깨질 우려가 있다.
- 하지만 성능을 더 중시한다면 고려해 볼 만한 선택지.
</code></pre></div></div>

<h2 id="테이블-반정규화-방법">테이블 반정규화 방법</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 1:1 관계의 테이블 병합
- 1:N 관계의 테이블 병합
- 슈퍼/서브 타입 테이블 변환
- 수직 분할(집중화된 일부 컬럼을 분리)
- 수평 분할(행으로 구분하여 구간별 분리)
- 테이블 추가(중복 테이블, 통계 테이블, 이력 케이블, 부분 테이블)
</code></pre></div></div>

<h2 id="대표적-반정규화---컬럼-반정규화">대표적 반정규화 - 컬럼 반정규화</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 중복 컬럼 추가(자주 조회하는 컬럼이 있는 경우)
- 파생 컬럼 추가(미리 계산한 값)
- PK에 의한 컬럼 추가
- 응용시스템 오작동을 위한 컬럼 추가(이전데이터 임시 보관)
</code></pre></div></div>

<h2 id="대표적-반정규화---관계-반정규화">대표적 반정규화 - 관계 반정규화</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 중복 관계 추가(이미 A 테이블에서 C 테이블의 정보를 읽을 수 있는 관계가 있음에도 관계를 중복하여 조회 경로를 단축)
</code></pre></div></div>

<h2 id="정규화가-좋은가-반정규화가-좋은가">정규화가 좋은가 반정규화가 좋은가?</h2>

<p>** 정답은 정해져 있지 않고 그때그떄 다르다. 개념을 잘 알고 있어야 적절하게 쓸 수 있다. **</p>

<h2 id="quiz정리">Quiz(정리)</h2>

<ul>
  <li>면접관 Q. 반정규화에 대해 간단하게 설명해 보세요.</li>
  <li>지원자 ** A. 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법입니다. **</li>
</ul>

<h2 id="qa">Q&amp;A</h2>

<ul>
  <li>Q. 수평 분할과 인덱스는 데이터 접근을 빠르게 하는 원리가 동일한 듯한데 어느 면에서 차이점이 있는지?</li>
  <li>A. 필드가 굉장히 많이 늘어나는 경우가 있다. 이런 경우인데도 특정 부분만 조회하게 되는 경우가 있는데, 이런 조회를 반복하면 메모리에 부하가 늘어나게 된다. 그래서 여기서 가장 많이 쓰는 필드만을 추출해서 사용한다. 즉, 속도와 퍼포먼스를 위해 수평 분할을 하는 것.</li>
</ul>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[React로 FrontEnd 개발해보기]</title><link href="http://localhost:4000/daily%20contents/React%EB%A1%9C-FrontEnd%EA%B0%9C%EB%B0%9C/" rel="alternate" type="text/html" title="[React로 FrontEnd 개발해보기]" /><published>2022-07-20T00:00:00+09:00</published><updated>2022-07-20T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/React%EB%A1%9C%20FrontEnd%EA%B0%9C%EB%B0%9C</id><content type="html" xml:base="http://localhost:4000/daily%20contents/React%EB%A1%9C-FrontEnd%EA%B0%9C%EB%B0%9C/"><![CDATA[<p><br /></p>

<h1 id="react">React</h1>

<h2 id="설치-및-시작">설치 및 시작</h2>

<ol>
  <li>Nodejs 설치 : npm(Node Package Manager)</li>
  <li>CRA 설치 : 설치 희망 path &gt; npx create-react-app testpjt</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- npm = npx
- npm이 버전업이 되면서 나온 명령어
</code></pre></div></div>

<p>** npm start 로 실행!! **</p>

<ul>
  <li>
    <p>App.js : 모든 소스가 있는 곳</p>
  </li>
  <li>
    <p>index.html, index.js</p>

    <ul>
      <li>index.js 파일의 root.render 라는 렌더링 선언, 그 내부의 App라는 커스터마이징된 태그가 컴포넌트.</li>
      <li>App.js가 SPA를 위해 injection 되어있다.</li>
      <li>App.js의 내부 function 등의 내용 수정에 따라 페이지의 내용이 변경.</li>
    </ul>
  </li>
</ul>

<h2 id="테이블-생성--데이터-적용">테이블 생성 &amp; 데이터 적용</h2>

<ul>
  <li>React 문법 : 대부분의 Object 표현 방식</li>
  <li>{ } 중괄호 활용. ex) let title = [‘이름’, ‘전공’] =&gt; { title[0] }</li>
</ul>

<h2 id="usestate">useState</h2>

<ul>
  <li>import { useState } from ‘react’;</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[객체, 대체값]
let[name, nameUpdate] = useState['이름1', '이름2'];
=&gt; button onClick {() =&gt; { nameUpdate(['이름3', '이름4']) } }

앞의 name은 대표하는 변수명, 뒤의 nameUpdate는 대체할 수 있는 값.
=&gt; 아래의 버튼으로 원래의 이름1, 이름2를 이름3, 이름4로 바꾸는 것이 가능.
</code></pre></div></div>

<h2 id="component">component</h2>

<ul>
  <li>ex) function TrComp(props)</li>
  <li>상위 컴포넌트에서 name과 major 등의 미리 정해둔 변수값을 props를 통해 하위 컴포넌트로 전함.</li>
</ul>

<h2 id="datagrid">DataGrid</h2>

<ul>
  <li>import { DataGrid } from ‘@mui/x-data-grid’;</li>
  <li>json 형태로 만들어둔 값을 &lt;DataGrid rows={rows} columns={columns} /&gt; 등으로 주입.</li>
</ul>

<h2 id="datagrid-응용">DataGrid 응용</h2>

<ul>
  <li>API 활용하여 응용</li>
  <li>ex) &lt;DataGrid rows={rows} columns={columns} rowsPerPageOptions={[13,26,100]} checkboxSelection /&gt;</li>
</ul>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[SpringBoot JPA]</title><link href="http://localhost:4000/daily%20contents/SpringBoot-JPA/" rel="alternate" type="text/html" title="[SpringBoot JPA]" /><published>2022-07-19T00:00:00+09:00</published><updated>2022-07-19T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/SpringBoot%20JPA</id><content type="html" xml:base="http://localhost:4000/daily%20contents/SpringBoot-JPA/"><![CDATA[<p><br /></p>

<h2 id="jpa">JPA</h2>

<h3 id="jpa--표준-ormobject-relational-mapping">JPA : 표준 ORM(Object-Relational Mapping)</h3>

<h3 id="객체-관계-매핑--데이터가-담긴-자료구조들의-객체를-저장">객체 관계 매핑 : 데이터가 담긴 자료구조들의 객체를 저장</h3>

<h3 id="장점">장점</h3>

<ul>
  <li>쿼리를 몰라도 구현할 수 있다.</li>
</ul>

<h3 id="두-가지만-하면-된다">두 가지만 하면 된다!!</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DB 테이블명 @Entity
원하는 것을 명령하는 쿼리가 되는 JpaRepository
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th>누가</th>
      <th>언제</th>
      <th>어디서</th>
      <th>무엇을</th>
      <th> </th>
      <th>어떻게</th>
      <th>왜</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>게시판</td>
      <td>UID</td>
      <td> </td>
      <td>글쓴 사람</td>
      <td>글쓴 날짜</td>
      <td>ip 주소</td>
      <td>제목</td>
      <td>내용</td>
      <td>모바일/웹</td>
      <td>N/A</td>
    </tr>
    <tr>
      <td>Board</td>
      <td>uid</td>
      <td> </td>
      <td>user</td>
      <td>createdDate</td>
      <td>ip</td>
      <td>title</td>
      <td>contents</td>
      <td>1/2</td>
      <td> </td>
    </tr>
    <tr>
      <td>댓글</td>
      <td>UID</td>
      <td>게시판_UID</td>
      <td>글쓴 사람</td>
      <td>글쓴 날짜</td>
      <td>ip 주소</td>
      <td> </td>
      <td>내용</td>
      <td>모바일/웹</td>
      <td>N/A</td>
    </tr>
    <tr>
      <td>Reply</td>
      <td>uid</td>
      <td> </td>
      <td>user</td>
      <td>createdDate</td>
      <td>ip</td>
      <td> </td>
      <td>contents</td>
      <td>1/2</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>프로퍼티 설정</li>
  <li>resources/static/application.properties » ddl의 옵션(create 등) 의미 자율학습</li>
</ul>

<h2 id="relationship-mapping">Relationship Mapping</h2>

<ul>
  <li>다중성, 방향성, 연관관계의 주인</li>
</ul>

<h3 id="다중성">다중성</h3>

<ul>
  <li>@OneToOne, @OneToMany…</li>
  <li>일대일, 일대다, 다대일, 다대다</li>
</ul>

<h3 id="방향성">방향성</h3>

<ul>
  <li>@JoinColumn</li>
  <li>양방향은 JPA에서는 지양</li>
</ul>

<h3 id="연관관계의-주인">연관관계의 주인</h3>

<ul>
  <li>@OneToMany(mappedBy = “boardFk”)
** 양방향일 경우 어떤 테이블 기준으로 데이터를 삭제하면 그것에 관련된 데이터들을 다 삭제할 것인가?</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FK 키 관리 주인을 설정해 준다.
'다' 쪽이 주인이다.
@ManyToOne 은 항상 주인이다.
</code></pre></div></div>

<h2 id="jparepository">JpaRepository</h2>

<ul>
  <li>Read : find**** 로 시작</li>
  <li>Delete : delete**** 로 시작</li>
  <li>Create : save</li>
  <li>Update : 객체 조회 후 값 변경 그리고 다시 save</li>
</ul>

<h2 id="builder--객체-생성할-떄의-tip">Builder : 객체 생성할 떄의 Tip</h2>

<ul>
  <li>설계자가 객체를 생성할 떄 순서를 고려하지 않을 때를 방지, 생성자 앞에 @Builder 어노테이션을 작성.</li>
</ul>

<h2 id="springboot-jpa-docs">SpringBoot JPA Docs</h2>

<ul>
  <li>메소드 명이 곧 쿼리 (ex. findByID, findByTitle, findTop1000ByOrderByUidDesc…)</li>
</ul>

<ol>
  <li>SpringBoot JPA는 Hibernate라는 ORM 프레임워크를 사용해서 구현한다.</li>
  <li>기본적으로 제공되는 레파지토리 메소드 이름 중에 조회에 사용되는 메소드는 find로 시작되는 메소드이다.</li>
  <li>JPA를 사용할 때 꼭 구현해 줘야 하는 두 가지는 엔티티와 레파지토리다.</li>
  <li>연관관계를 설정할 때에는 3가지를 설정해 줘야 하는데 다중성, 방향성, 연관관계 주인을 설정해 주어야 한다.</li>
</ol>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Vue로 FrontEnd 개발해보기]</title><link href="http://localhost:4000/daily%20contents/Vue%EB%A1%9C-FrontEnd-%EA%B0%9C%EB%B0%9C%ED%95%B4%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="[Vue로 FrontEnd 개발해보기]" /><published>2022-07-15T00:00:00+09:00</published><updated>2022-07-15T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/Vue%EB%A1%9C%20FrontEnd%20%EA%B0%9C%EB%B0%9C%ED%95%B4%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/daily%20contents/Vue%EB%A1%9C-FrontEnd-%EA%B0%9C%EB%B0%9C%ED%95%B4%EB%B3%B4%EA%B8%B0/"><![CDATA[<p><br /></p>

<h2 id="vue로-front-end-개발-시작해보기">Vue로 Front End 개발 시작해보기</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* 기존 Vue.js의 렌더링을 위한 가상 DOM 설계는 HTML 기반의 템플릿을 제공하고, 이 템플릿 구문을 가상 DOM 트리로 변환하고 실제로 DOM에 어떤 영역이 업데이트 되어야 하는지 재귀적으로 탐색하는 방식.
* 불필요한 탐색이 많이 포함됨.
* 템플릿 구문에서 정적인 구문이 대부분을 차지하고 동적인 구문이 적을 경우 불필요한 부분이 더욱 발생.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>렌더링 성능을 향상하고자 최적화 작업 진행. 컴파일러로 동적 요소만을 탐색하여 트리 순환. 메모리 사용량 절감.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>트리쉐이킹 -&gt; 사용하지 않는 코드를 제거하여 코드 최적화
Vue3에서는 이를 강화하여 번들 크기를 절반 이상으로 대폭 줄이는 것에 성공
</code></pre></div></div>

<h3 id="대표적으로-composition-api-추가">대표적으로 Composition API 추가.</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>본래의 Vue의 코드는 직관적이지만 규모가 커지고 로직이 많아지면 결국은 사방에 흩어지게 될 것. 이 문제를 해결하기 위해 Composition API 등장.
</code></pre></div></div>

<h3 id="소셜-로그인에-대하여">소셜 로그인에 대하여</h3>

<ul>
  <li>로그인 기능은 중요. 알아두길.</li>
</ul>

<h3 id="아키텍쳐">아키텍쳐</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 왜 FE에서 로그인 인증 코드 등을 다 처리하지 않고 BE에 전달하는가?
A. 보안에 취약하기 때문에.
</code></pre></div></div>

<p>EX) Kakao</p>

<ul>
  <li>카카오 Developer 사이트에 개발자 가입을 한 후 API KEY를 받아 사용.
EX) Google</li>
  <li>Index html에 SDK를 넣거나 npm 라이브러리를 이용.
EX) Facebook, naver 등등… 위와 마찬가지.</li>
</ul>

<h3 id="firebase-인증">Firebase 인증</h3>

<ul>
  <li>사용자의 기본적인 프로필 사진, 닉네임 등이 저장되는 이점이 있음.</li>
</ul>

<h4 id="사용자의-편의를-위해-지속적-관리-로직-추가">사용자의 편의를 위해 지속적 관리, 로직 추가.</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로필 업데이트, 닉네임 변경, 아이디 기억하기, 회원 탈퇴 시 같이 탈퇴, 비밀번호 찾기, 세션 만료, 소셜 회원가입하고 비밀번호가 또 요구될 경우... 등등.
</code></pre></div></div>

<h3 id="qna">QnA</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 무슨 로직을 짜야 할지 생각나지 않을 떄.
A. 분위기 환기, 컨디션 재정비.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. React보다 Vue가 우수한 점은?
A. React의 경우 업데이트가 늦어지고 있는 등의 문제가 있으나 둘 다 우수.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 로그인할 때 모달을 사용하는가? 별도 라우팅 이동을 하는가?
A. 로그인 자체는 라우팅을 이용해야 함. 로그인이 필요한 기능을 사용할 때 라우터 기능을 이용.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 회원 가입된 유저의 테이블과 소셜 로그인에 사용하는 이메일 저장 테이블을 분리해서 써야 하는가?
A. 분리할 필요는 없음. 테이블 생성도 비용이기에 분리는 효과적으로 보이지 않음.
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[System과 Infra]</title><link href="http://localhost:4000/daily%20contents/System%EA%B3%BC-Infra/" rel="alternate" type="text/html" title="[System과 Infra]" /><published>2022-07-14T00:00:00+09:00</published><updated>2022-07-14T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/System%EA%B3%BC%20Infra</id><content type="html" xml:base="http://localhost:4000/daily%20contents/System%EA%B3%BC-Infra/"><![CDATA[<p><br /></p>

<h2 id="system">System</h2>

<ul>
  <li>목적에 맞춰서 만든 체계</li>
</ul>

<h2 id="infra">Infra</h2>

<ul>
  <li>(특정한 APP을 활용한 서비스를 운영하기 위해) 필요한 다양한 하드웨어나 운영체제, 미들웨어, 네트워크 등 시스템의 기반을 총칭</li>
  <li>IT 인프라 = 시스템들의 기반 체계</li>
</ul>

<h3 id="infra의-4대-구성-요소">Infra의 4대 구성 요소</h3>

<ul>
  <li>하드웨어</li>
  <li>운영체제</li>
  <li>네트워크</li>
  <li>미들웨어
    <ul>
      <li>운영체제와 소프트웨어, 소프트웨어와 소프트웨어 간에 통신, 중재하는 역할을 하는 소프트웨어.</li>
      <li>상황에 따라 시스템에 편입되기도 하고, 인프라에 편입되기도 함</li>
      <li>가장 흔하게 접하게 될 미들웨어는 <code class="language-plaintext highlighter-rouge">웹서버</code>, <code class="language-plaintext highlighter-rouge">웹 애플리케이션 서버(WAS)</code>, <code class="language-plaintext highlighter-rouge">DBA(Database Management System)</code>, <code class="language-plaintext highlighter-rouge">Nginx</code> 등</li>
    </ul>
  </li>
  <li>사용자는 인프라가 어떻게 구성되어 있는지 딱히 느끼지 못한다!</li>
</ul>

<h2 id="legacy는-뭘까"><code class="language-plaintext highlighter-rouge">Legacy</code>는 뭘까?</h2>

<ol>
  <li>오래된 시스템</li>
  <li>구성 시스템
    <ul>
      <li>현재는 <code class="language-plaintext highlighter-rouge">AWS</code>, <code class="language-plaintext highlighter-rouge">Azure</code>와 같은 가상화 시스템이 우세하고 있는 상황. 기존의 물리적인 서버를 가지고 있는 업체들은 기존 물리 서버를 활용하면서 시스템의 확장을 고려해야 한다. 반면에 신규 서비스를 만들 때는 물리 서버를 구축할 필요 없이 클라우드로 서버를 구축하면 되겠다!</li>
    </ul>
  </li>
</ol>

<h2 id="system과-infra의-관계">System과 Infra의 관계</h2>

<p><img src="https://user-images.githubusercontent.com/25563077/178861273-9d8a6b75-8875-4546-afbf-fe36b366a8a9.png" alt="제목 없음" /></p>

<p><img src="https://user-images.githubusercontent.com/25563077/178859792-c2459bca-4d8a-4183-b61c-df8d3d95696c.png" alt="image" /></p>

<h2 id="q--a">Q &amp; A</h2>

<blockquote>
  <p>SSAFY의 Infra를 어떻게 사용할 수 있나요?</p>
</blockquote>

<ul>
  <li>서버는 <code class="language-plaintext highlighter-rouge">Amazon EC2</code>, 운영체제는 <code class="language-plaintext highlighter-rouge">Ubuntu</code>, 공개망으로 제공됨</li>
  <li>여러분의 <code class="language-plaintext highlighter-rouge">Application</code>을 <code class="language-plaintext highlighter-rouge">Infra</code>, <code class="language-plaintext highlighter-rouge">System</code>에 올리기만 하면 돌아갑니다.</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Application</code>은 시스템이 아닌가요?</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">System</code>과는 구별되는 개념</li>
  <li>채팅 시스템을 구현했다고 생각해 보자!
    <ul>
      <li>카카오톡, 매터모스트처럼 다른 애플리케이션이 올라가도 서비스는 가능하다.</li>
      <li><code class="language-plaintext highlighter-rouge">Application</code>에 사용될 뼈대라고 생각하면 될까?</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<blockquote>
  <p>​아키텍쳐가 아닌 개발자라도 시스템 인프라를 체계적으로 파악했을 때와 파악하지 못했을 때 더 효율적인 개발이 가능할까요?</p>
</blockquote>

<ul>
  <li>시스템, 인프라는 지금은 SSAFY에서 제공해주지만 사실은 굉장히 넓은 영역</li>
  <li>조금이라도 흐름을 알아두면 프로젝트를 조금 더 짜임새 있게 설계하는 데에 도움이 되지 않을까?</li>
  <li>회사에 가면 인프라 팀이 있어서 인프라를 개발할 일은 적지만, 인프라를 이해하고 개발하는 것과 이해하지 못하고 개발하는 것은 차이가 있음!</li>
</ul>

<p><br /></p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">jvm</code>도 미들웨어인가요?</p>
</blockquote>

<ul>
  <li>그렇다고 볼 수 있다. 직접 다루는 게 아닌, 자바를 설치하면 알아서 동작하도록 도움을 주기 때문</li>
</ul>

<p><br /></p>

<blockquote>
  <p>인프라 공부에 순서가 있을까요?</p>
</blockquote>

<ul>
  <li>순서는 없다. 프로젝트를 만들었을 때 모르는 것들을 만나면 그때그때 공부해보자!</li>
</ul>

<p><br /></p>

<blockquote>
  <p>설계도 작성 시 시스템과 인프라를 구분해서 나타내주어야 할까요?</p>
</blockquote>

<ul>
  <li>보통은 시스템 설계도, 인프라 설계도 따로따로 작성한다. 다들 잘 모르기 때문에… 알고 있다면 강점이 될 것</li>
</ul>

<p><br /></p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Django</code> 는 웹 애플리케이션 프레임워크던데 미들웨어인가요 서버인가요?</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Django</code>를 실행하려면 <code class="language-plaintext highlighter-rouge">python</code>이 필요하기 때문에, <code class="language-plaintext highlighter-rouge">python</code>을 미들웨어로 보는 게 맞다.</li>
  <li><code class="language-plaintext highlighter-rouge">python</code> 위에 <code class="language-plaintext highlighter-rouge">Django</code>라는 프레임워크와 프레임워크로 만든 나만의 앱이 있는 것</li>
  <li>미들웨어는 개발을 도와주는 도구라고 생각해보자!</li>
</ul>

<p><br /></p>

<blockquote>
  <p>서버 인프라에서 <code class="language-plaintext highlighter-rouge">ubuntu</code>와 <code class="language-plaintext highlighter-rouge">centos</code>를 선택하는 기준이 있을까요?</p>
</blockquote>

<ul>
  <li>국내에서는 <code class="language-plaintext highlighter-rouge">centOS</code>가 많았지만 지원이 중단되면서 2021년 중반부터는 <code class="language-plaintext highlighter-rouge">ubuntu</code>로 많이들 옮기고 있다.</li>
</ul>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[앱? 웹? 어떤 플랫폼으로 개발할까?]</title><link href="http://localhost:4000/daily%20contents/%EC%95%B1-%EC%9B%B9-%EC%96%B4%EB%96%A4-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%9C%BC%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%A0%EA%B9%8C/" rel="alternate" type="text/html" title="[앱? 웹? 어떤 플랫폼으로 개발할까?]" /><published>2022-07-13T00:00:00+09:00</published><updated>2022-07-13T00:00:00+09:00</updated><id>http://localhost:4000/daily%20contents/%EC%95%B1%20%EC%9B%B9%20%EC%96%B4%EB%96%A4%20%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%9C%BC%EB%A1%9C%20%EA%B0%9C%EB%B0%9C%ED%95%A0%EA%B9%8C</id><content type="html" xml:base="http://localhost:4000/daily%20contents/%EC%95%B1-%EC%9B%B9-%EC%96%B4%EB%96%A4-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%9C%BC%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%A0%EA%B9%8C/"><![CDATA[<p><br /></p>

<p><strong>웹? 앱? 고민된다면 우리 서비스의 특징과 우리 팀의 역량을 살펴보자!</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>플랫폼 고민
 - 모바일? 웹? 하나만? 같이? 모바일은 IOS? 안드로이드? 크로스 플랫폼?
</code></pre></div></div>

<h2 id="웹의-특징">웹의 특징</h2>

<h3 id="장점">장점</h3>

<ul>
  <li>브라우저만 있으면 어디서든 접속 가능
    <ul>
      <li>모바일 앱은 배포하기 위해 마켓에 등록해야함</li>
      <li>모바일 앱의 사용자는 다운받고 실행받아야하는 불편함</li>
    </ul>
  </li>
  <li>웹 페이지가 업데이트된 후 배포 속도가 빠름
    <ul>
      <li>모바일 앱은 사용자마다 배포되는 때가 다름</li>
    </ul>
  </li>
  <li>플랫폼 환경에 제약이 없음
    <ul>
      <li>모바일 앱과 다르게 안드로이드, ios 등 따로 개발할 필요가 없음</li>
    </ul>
  </li>
</ul>

<h3 id="단점">단점</h3>

<ul>
  <li>모든 것을 다운받아야하기 때문에 속도가 느림 (페이지 전환되는 느낌)</li>
  <li>UI 사용성이 앱보다 좋지 않음</li>
  <li>연결 위해서 URL 입력해야함</li>
</ul>

<h2 id="모바일-앱의-특징">모바일 앱의 특징</h2>

<h3 id="장점-1">장점</h3>

<ul>
  <li>앱마켓 사용 가능 : 다양한 수익 창출
    <ul>
      <li>앱을 만들었다면 꼭 마켓에 배포해보기</li>
    </ul>
  </li>
  <li>푸시알람, 주소록, 카메라, GPS 등 스마트폰 기능 사용 가능
    <ul>
      <li>이런 리소스를 사용하는 것이 필요한 서비스라면 앱 추천</li>
    </ul>
  </li>
  <li>사용자들의 서비스 실행 편함 : 아이콘 클릭으로 서비스 시작 가능</li>
  <li>스마트폰에 최적화 됨 = 속도 빠름</li>
  <li>메모리 적인것, UI등이 최적화 되어있어 성능 좋음</li>
  <li>UI 사용성이 스마트폰에 최적화 되어 있음</li>
</ul>

<h3 id="단점-1">단점</h3>

<ul>
  <li>마켓 등록 위해 개발자 등록 해야함</li>
  <li>사용자가 앱을 다운 받아야하는 불편함
    <ul>
      <li>받았다가 바로 삭제하는 경우 많음</li>
    </ul>
  </li>
  <li>IOS, AOS 모두 개발 필요</li>
  <li>앱이 수정되면 마켓에 새로 배포해야함 = 배포까지 시간 오래걸림</li>
  <li>사용자가 사용하는 디바이스에 OS 따라 버전을 관리해야함</li>
</ul>

<h2 id="예시-카카오톡">예시) 카카오톡</h2>

<ul>
  <li>사용자가 서비스에 자주 접속 = 접속 간편해야함</li>
  <li>메세지 왔을 때 빠른 확인 필요 = 알람 필요</li>
  <li>UI 매우 중요 = 최적화 필요</li>
  <li>간편한 인앱 결제 기능 필요 = 이모티콘, 기프티콘 등</li>
  <li>반대 예시) 네이버 = 굳이 사용자가 앱으로 메일 확인할 필요 없다면…</li>
</ul>

<h2 id="일반적인-서비스의-구성">일반적인 서비스의 구성</h2>

<ul>
  <li>백(REST API), 프론드(Web + 모바일 앱)</li>
  <li>백(REST API), 프론드(Web)</li>
</ul>

<h2 id="개발의-현실">개발의 현실</h2>

<ul>
  <li>새로운 개발 프로젝트에 딱 맞는 인원 배치 어려움
    <ul>
      <li>해본 사람이 세팅하고 리드하는 동안 경험 없는 팀원이 공부를 조금 더 하고 시작</li>
    </ul>
  </li>
  <li>정해진 시간 안에 완성해야함 = 모든 기능 넣기 어려움</li>
  <li><strong>프로젝트</strong> : <strong>정해진 자원</strong>과 <strong>한정된 기간</strong> 내에 최대한 완성도를 높이는 것</li>
</ul>

<h2 id="타협-방법">타협 방법</h2>

<ul>
  <li>공통의 목표 정하기
    <ul>
      <li>백엔드 안해봤는데 공부해서 결과물 만들고 싶어 등</li>
    </ul>
  </li>
  <li>우리가 구현하고자 하는 핵심 기능 명확히 정의하고 개발자 배치
    <ul>
      <li>공부해서 앱할래, 현실과 타협해서 웹할래?</li>
    </ul>
  </li>
  <li>우리 팀의 역량 객관화</li>
  <li>서비스 구현하는 것 뿐만 아니라 서비스 구현까지 개발자의 역할</li>
</ul>

<h2 id="qa">Q&amp;A</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q. 하나의 서버로 웹과 앱 모두를 동시에 서비스할 수도 있나요?
A. 웹페이지, 모바일 두 개 다 모두 프론트엔드임. 동일한 프론트가 같은 서버에 API를 요청하면 안될까?
</code></pre></div></div>]]></content><author><name>김경호</name></author><category term="Daily Contents" /><category term="Daily Contents" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (값 타입)]</title><link href="http://localhost:4000/jpa/JPA_Basic-4/" rel="alternate" type="text/html" title="[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (값 타입)]" /><published>2022-06-28T00:00:00+09:00</published><updated>2022-06-28T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPA_Basic%204</id><content type="html" xml:base="http://localhost:4000/jpa/JPA_Basic-4/"><![CDATA[<p><br /></p>

<h2 id="값-타입">값 타입</h2>

<h3 id="1-기본값-타입">1. 기본값 타입</h3>

<blockquote>
  <ul>
    <li><strong>JPA의 데이터 타입 분류</strong>
      <ul>
        <li><strong>엔티티 타입</strong>
          <ul>
            <li>@Entity로 정의하는 객체</li>
            <li>데이터가 변해도 식별자로 지속해서 추적 가능</li>
            <li>예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능</li>
          </ul>
        </li>
        <li><strong>값 타입</strong>
          <ul>
            <li>int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체</li>
            <li>식별자가 없고 값만 있으므로 변경시 추적 불가</li>
            <li>예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입 분류</strong>
      <ul>
        <li><strong>기본값 타입</strong>
          <ul>
            <li>자바 기본 타입(int, double)</li>
            <li>래퍼 클래스(Integer, Long)</li>
            <li>String</li>
          </ul>
        </li>
        <li><strong>임베디드 타입</strong>(embedded type, 복합 값 타입)</li>
        <li><strong>컬렉션 값 타입</strong>(collection value type)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>기본값 타입</strong>
      <ul>
        <li>예 : String name, int age</li>
        <li>생명 주기를 엔티티에 의존
          <ul>
            <li>예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제</li>
          </ul>
        </li>
        <li>값 타입은 공유하면 안됨
          <ul>
            <li>예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨</li>
          </ul>
        </li>
      </ul>
    </li>
    <li><strong>참고</strong> : 자바의 기본 타입은 절대 공유되지 않는다.
      <ul>
        <li>int, double 같은 기본 타입(primitive type)은 절대 공유되지 않음</li>
        <li>기본 타입은 항상 값을 복사함</li>
        <li>Integer 같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경 자체가 불가능</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>

    <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
    <span class="c1">//기본 타입 공유 테스트</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a = "</span> <span class="o">+</span> <span class="n">a</span><span class="o">);</span> <span class="c1">// a = 10</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b = "</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span> <span class="c1">// b = 20</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-임베디드-타입">2. 임베디드 타입</h3>

<blockquote>
  <ul>
    <li><strong>임베디드 타입(복합 값 타입)</strong>
      <ul>
        <li>새로운 값 타입을 직접 정의할 수 있음</li>
        <li>JPA는 임베디드 타입(embedded type)이라 함</li>
        <li>주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함</li>
        <li>int, String과 같은 값 타입 (<strong>엔티티 아님</strong>)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>예제</strong>
      <ul>
        <li>회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다. =&gt; 너무 번잡하다.
<br /> <img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%ED%83%80%EC%9E%85%20%EB%B3%B5%EC%9E%A1.png" alt="TEXT" title="임베디드 타입 복잡" width="20%" height="30%" /></li>
        <li>회원 엔티티는 이름, 근무 기간, 집 주소를 가진다. =&gt; 이런식으로 묶어낼 수 있는게 임베디드 타입이다.
<br /> <img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%ED%83%80%EC%9E%851.png" alt="TEXT" title="임베디드 타입1" width="45%" height="60%" />
<img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%ED%83%80%EC%9E%852.png" alt="TEXT" title="임베디드 타입2" width="45%" height="60%" /></li>
        <li>쉽게 말해서 Period, Address 클래스를 새로 만들었다고 생각하면 된다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>임베디드 타입 사용법</strong>
      <ul>
        <li>@Embeddable : 값 타입을 정의하는 곳에 표시</li>
        <li>@Embedded : 값 타입을 사용하는 곳에 표시 (둘 중 하나만 넣고 생략 가능)</li>
        <li><strong>기본 생성자 필수</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>임베디드 타입의 장점</strong>
      <ul>
        <li>재사용</li>
        <li>높은 응집도</li>
        <li>Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음</li>
        <li>임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>임베디드 타입과 테이블 매핑</strong>
      <ul>
        <li>DB 입장에서는 값타입을 쓰든 안 쓰든, 임베디드 타입을 쓰든 안 쓰든 회원 테이블은 똑같다. 매핑만 해주면 된다.
<br /> <img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%20%ED%85%8C%EC%9D%B4%EB%B8%94%20%EB%A7%A4%ED%95%91.png" alt="TEXT" title="임베 테이블 매핑" width="45%" height="60%" /></li>
        <li>임베디드 타입은 엔티티의 <strong>값일 뿐</strong>이다.</li>
        <li>임베디드 타입을 사용하기 전과 후에 <strong>매핑하는 테이블은 같다.</strong></li>
        <li>객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능</li>
        <li>잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Period</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">startDate</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">endDate</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Address</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Address</span><span class="o">(</span><span class="nc">String</span> <span class="n">city</span><span class="o">,</span> <span class="nc">String</span> <span class="n">street</span><span class="o">,</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">city</span> <span class="o">=</span> <span class="n">city</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">street</span> <span class="o">=</span> <span class="n">street</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">zipcode</span> <span class="o">=</span> <span class="n">zipcode</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"USERNAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="c1">//기간 Period</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Period</span> <span class="n">workPeriod</span><span class="o">;</span>

    <span class="c1">//주소</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">homeAddress</span>
<span class="o">}</span>

<span class="nc">JpaMain의</span> <span class="k">try</span> <span class="n">내부</span>
<span class="k">try</span><span class="o">{</span>
    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setHomeAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span><span class="s">"street"</span><span class="o">,</span><span class="s">"10000"</span><span class="o">));</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setWorkPeriod</span><span class="o">(</span><span class="k">new</span> <span class="nc">Period</span><span class="o">());</span>

    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>임베디드 타입과 연관관계</strong></li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%EC%9E%84%EB%B2%A0%20%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84.png" alt="TEXT" title="임베 연관관계" width="45%" height="60%" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ZIPCODE"</span><span class="o">)</span> <span class="c1">//이름 설정도 가능</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span> <span class="c1">//임베디드 안에 엔티티도 들어올 수 있다.</span>

    <span class="kd">public</span> <span class="nf">Address</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Address</span><span class="o">(</span><span class="nc">String</span> <span class="n">city</span><span class="o">,</span> <span class="nc">String</span> <span class="n">street</span><span class="o">,</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">city</span> <span class="o">=</span> <span class="n">city</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">street</span> <span class="o">=</span> <span class="n">street</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">zipcode</span> <span class="o">=</span> <span class="n">zipcode</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>@AttributeOverride : 속성 재정의</strong>
      <ul>
        <li>한 엔티티에서 같은 값 타입을 사용하면?</li>
        <li>컬럼 명이 중복됨</li>
        <li>@AttributeOverrides, @AttributeOverride 를 사용해서 컬럼 명 속성을 재정의</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"USERNAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="c1">//기간 Period</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Period</span> <span class="n">workPeriod</span><span class="o">;</span>

    <span class="c1">//주소</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">homeAddress</span><span class="o">;</span>

    <span class="c1">//주소</span>
 <span class="c1">//   @Embedded</span>
 <span class="c1">//   private Address homeAddress; // 중복 때문에 에러가 난다.</span>

    <span class="nd">@Embedded</span>
    <span class="nd">@AttributeOverrides</span><span class="o">({</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"city"</span><span class="o">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"WORK_CITY"</span><span class="o">)),</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"street"</span><span class="o">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"WORK_STREET"</span><span class="o">)),</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"zipcode"</span><span class="o">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"WORK_ZIPCODE"</span><span class="o">))</span>
    <span class="o">})</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">workaddress</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>임베디드 타입과 null</strong>
      <ul>
        <li>임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="mappedsuperclass-vs-embeddable">@MappedSuperclass vs @Embeddable</h4>

<blockquote>
  <ul>
    <li><strong>@MappedSuperclass</strong>
      <ul>
        <li><strong>Entity</strong>로 정의하는 것이고 <strong>여러 Entity에 공통적으로</strong> 적용해야 할 때 사용할 수 있다.</li>
        <li><strong>상속</strong>이다.</li>
        <li><strong>상속</strong>은 <strong>다중상속도 안되고</strong> 객체지향 설계상 <strong>유연성</strong>이 떨어진다.</li>
      </ul>
    </li>
    <li><strong>@Embeddable</strong> + <strong>@Embedded</strong>
      <ul>
        <li><strong>Value</strong> 타입으로 정의하는 것이고 <strong>비슷한 속성</strong>을 가지는 애트리뷰트를 하나의 값으로 만들어 <strong>재사용성</strong>을 높일수 있는 방법이다.</li>
        <li><strong>위임</strong>이다.</li>
        <li><strong>JPQL</strong>을 사용할 때에는 엔티티에서 embedded type까지 쿼리하기 위해서 type을 명시해야 하는 불편함이 존재한다.
          <ul>
            <li>예) <strong>위임 사용</strong>: select u from User u where u.timestamped.createdDate &gt; ?</li>
            <li>예) <strong>상속 사용</strong> : select u from User u where u.createdDate &gt; ?</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>대부분의 상황에서는 <strong>embedded type</strong>을 사용하는 것이 좋겠지만 <strong>단순한 데이터를 다룰 때</strong>에는 단순한 방식(<strong>@MappedSuperclass</strong>)을 선택하여 처리하는 것이 더 나은 경우도 있다.</li>
    <li><strong>@MappedSuperclass</strong>를 사용하는 경우
      <ul>
        <li>수정시간, 등록시간, 수정자, 등록자 처럼 <strong>대부분의 엔티티들이 공통으로 사용하는 속성</strong>들을 다룰때 사용한다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><a href="https://lob-dev.tistory.com/entry/Base-Column를-사용할-때-MappedSuperclass-와-embedded-Type-중-무엇을-사용해야-할까">참고1</a> <br />
<a href="https://www.inflearn.com/questions/18578">참고2</a></p>

<h3 id="3-값-타입과-불변-객체">3. 값 타입과 불변 객체</h3>

<blockquote>
  <ul>
    <li>값 타입은 복잡한 객체 세상은 조금이라도 <strong>단순화</strong>하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입 공유 참조</strong>
      <ul>
        <li>임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함</li>
        <li>부작용(side effect) 발생</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%EA%B0%92%ED%83%80%EC%9E%85%20%EB%B6%80%EC%9E%91%EC%9A%A9.png" alt="TEXT" title="값 타입 부작용" /></p>

<blockquote>
  <ul>
    <li>회원 1과 회원 2가 같은 주소를 볼 경우, city를 NewCity로 바꾸면 회원1과 회원2도 같이 NewCity로 바뀐다</li>
    <li>의도적으로 쓰려면 값 타입을 쓰면 안되고 엔티티를 써야한다.</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="o">{</span>
      <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>

      <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
      <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
      <span class="n">member</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
      <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

      <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
      <span class="n">member2</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member2"</span><span class="o">);</span>
      <span class="n">member2</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
      <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

      <span class="n">member</span><span class="o">.</span><span class="na">getAddress</span><span class="o">().</span><span class="na">setCity</span><span class="o">(</span><span class="s">"newCity"</span><span class="o">);</span> <span class="c1">//member만 바뀌는게 아니라 member2까지 같이 바뀐다. (이런 버그는 잡아내기 어렵다.)</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>값 타입 복사</strong>
      <ul>
        <li>값 타입의 실제 인스턴스인 값을 <strong>공유하는 것은 위험</strong></li>
        <li>대신 값(인스턴스)를 <strong>복사해서 사용</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><img src="../../assets/forPost/JPA_Basic/%EA%B0%92%ED%83%80%EC%9E%85%20%EB%B3%B5%EC%82%AC.png" alt="TEXT" title="값 타입 복사" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>

            <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>

            <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
            <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

            <span class="nc">Address</span> <span class="n">copyAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="n">address</span><span class="o">.</span><span class="na">getCity</span><span class="o">(),</span> <span class="n">address</span><span class="o">.</span><span class="na">getStreet</span><span class="o">(),</span> <span class="n">address</span><span class="o">.</span><span class="na">getZipcode</span><span class="o">());</span> <span class="c1">//copy</span>
            <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
            <span class="n">member2</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member2"</span><span class="o">);</span>
            <span class="n">member2</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">copyAddress</span><span class="o">);</span>
            <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

            <span class="n">member</span><span class="o">.</span><span class="na">getAddress</span><span class="o">().</span><span class="na">setCity</span><span class="o">(</span><span class="s">"newCity"</span><span class="o">);</span> <span class="c1">//member2는 copyAddress로 저장했기 때문에 member2는 안바뀌고 member만 바뀐다.</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>객체 타입의 한계</strong>
      <ul>
        <li>항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.</li>
        <li>문제는 임베디드 타입처럼 <strong>직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입</strong>이다.</li>
        <li>자바 기본 타입에 값을 대입하면 값을 복사한다.</li>
        <li>객체 타입은 참조 값을 <strong>직접 대입하는 것을 막을 방법이 없다.</strong>
          <ul>
            <li>누군가 실수로 복사하지 않고 직접 대입하는 경우는 컴파일러 레벨에서 막을 방법이 없다.</li>
          </ul>
        </li>
        <li><strong>객체의 공유 참조는 피할 수 없다.</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">기본타입</span><span class="o">(</span><span class="n">primitive</span> <span class="n">type</span><span class="o">)</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> <span class="c1">//기본 타입은 값을 복사</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">//a 값은 10으로 유지</span>

<span class="n">객체</span> <span class="n">타입</span>
<span class="nc">Address</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"Old"</span><span class="o">);</span>
<span class="nc">Address</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> <span class="c1">//객체 타입은 참조를 전달</span>
<span class="n">b</span><span class="o">.</span><span class="na">setCity</span><span class="o">(</span><span class="s">"New"</span><span class="o">);</span> <span class="c1">//a와 b는 같은 인스턴스를 가르킨다. 따라서 a, b 둘 다 바뀐다.</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>불변 객체</strong>
      <ul>
        <li>객체 타입을 수정할 수 없게 만들면 <strong>부작용을 원천 차단</strong></li>
        <li><strong>값 타입은 불변 객체(immutable object)로 설계해야함</strong></li>
        <li><strong>불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체</strong></li>
        <li>생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨 (setter를 private로 만들어도 됨)</li>
        <li>참고 : Integer, String은 자바가 제공하는 대표적인 불변 객체</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>불변이라는 작은 제약으로 큰 재앙을 막을 수 있다.</strong></li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>값을 바꾸고 싶다면?</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Address</span> <span class="n">newAddress</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"NewCity"</span><span class="o">,</span> <span class="n">address</span><span class="o">.</span><span class="na">getStreet</span><span class="o">(),</span> <span class="n">address</span><span class="o">.</span><span class="na">getZipcode</span><span class="o">());</span>
<span class="n">member</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">newAddress</span><span class="o">);</span>
<span class="c1">//위 코드처럼 완전히 새로 만들어서 바꿔야한다.</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li>값 타입은 side effect를 대비해서 <strong>불변으로 만드는걸 추천</strong>한다.</li>
  </ul>
</blockquote>

<h3 id="4-값-타입의-비교">4. 값 타입의 비교</h3>

<blockquote>
  <ul>
    <li><strong>값 타입</strong> : 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야함</li>
    <li><strong>동일성(identity) 비교</strong> : 인스턴스의 참조 값을 비교, == 사용</li>
    <li><strong>동등성(equivalence) 비교</strong> : 인스턴스의 값을 비교, equals() 사용</li>
    <li>값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야함</li>
    <li>값 타입의 equals() 메소드를 적절하게 재정의(주로 모든 필드 사용)</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="c1">//a == b true</span>
<span class="nc">Address</span> <span class="n">address1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>
<span class="nc">Address</span> <span class="n">address2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>
<span class="c1">//address1 == address2 false</span>
<span class="c1">//address1.equals(address2) false (equals 오버라이드 전)</span>
<span class="c1">//address1.equals(address2) true (equals 오버라이드 후)</span>
<span class="c1">//Java에서는 ==비교시 참조값을 비교하기 때문에 false가 나온다.</span>
</code></pre></div></div>

<h3 id="5-값-타입-컬렉션">5. 값 타입 컬렉션</h3>

<p><img src="../../assets/forPost/JPA_Basic/%EA%B0%92%ED%83%80%EC%9E%85%20%EC%BB%AC%EB%A0%89%EC%85%98.png" alt="TEXT" title="값타입 컬렉션" /></p>

<blockquote>
  <ul>
    <li>값 타입을 하나 이상 저장할 때 사용</li>
    <li>@ElementCollection, @CollectionTable 사용</li>
    <li>데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.</li>
    <li>컬렉션을 저장하기 위한 별도의 테이블이 필요함</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입 컬렉션 사용</strong>
      <ul>
        <li>값 타입 저장</li>
        <li>값 타입 조회
          <ul>
            <li>값 타입 컬렉션도 지연 로딩 전략 사용</li>
          </ul>
        </li>
        <li>값 타입 수정</li>
        <li>참고 : 값 타입 컬렉션은 영속성 전이(Cascade) + 고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.
          <ul>
            <li>값 타입 컬렉션도 값 타입이기 때문에 라이프사이클이 member에 의존한다</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span>

    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FAVORITE_FOOD"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">))</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FOOD_NAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">favoriteFoods</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ADDRESS"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">))</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="nc">JpaMain의</span> <span class="k">try</span> <span class="n">내부</span>

<span class="k">try</span> <span class="o">{</span>

            <span class="c1">// 저장 예제</span>
            <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setHomeAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"homeCity"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>

            <span class="n">member</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"치킨"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"족발"</span><span class="o">);</span>
            <span class="n">member</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"피자"</span><span class="o">);</span>

            <span class="n">member</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"old1"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>
            <span class="n">member</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"old2"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>

            <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

            <span class="c1">// 조회 예제</span>
            <span class="n">em</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="n">em</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span> <span class="c1">//깔끔한 상태에서 조회하기 위해 clear 해준다</span>

            <span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span> <span class="c1">//쿼리를 보면 Member만 가져온다. 즉, 컬렉션은 지연로딩 사용</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Address</span> <span class="n">address</span> <span class="o">:</span> <span class="n">addressHistory</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"address = "</span> <span class="o">+</span> <span class="n">address</span><span class="o">.</span><span class="na">getCity</span><span class="o">());</span> <span class="c1">//지연로딩이기 때문에 이때 쿼리가 나감</span>
            <span class="o">}</span>

            <span class="c1">//수정 예제</span>
            <span class="c1">//homeCity -&gt; newCity</span>
<span class="c1">//            findMember.getHomeAddress().setCity("newCity"); //immutable 해야하기 때문에 이런식으로 변경하면 절대 안된다.</span>

            <span class="nc">Address</span> <span class="n">a</span> <span class="o">=</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getHomeAddress</span><span class="o">();</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">setHomeAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"newCity"</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">getStreet</span><span class="o">(),</span> <span class="n">a</span><span class="o">.</span><span class="na">getZipcode</span><span class="o">()));</span> <span class="c1">//이런식으로 완전히 교체를 해줘야한다.</span>

            <span class="c1">//치킨 -&gt; 한식</span>
            <span class="c1">//단순 String이기 때문에 remove로 지우고 add로 추가해야한다.</span>
            <span class="c1">//String은 업데이트가 없다.</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="s">"치킨"</span><span class="o">);</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"한식"</span><span class="o">);</span>

            <span class="c1">//old1 -&gt; newCity1</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"old1"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>
            <span class="c1">//remove의 기본 동작은 equals로 대상을 찾는다. 즉, equals, hashcode를 안넣으면 지워지지 않고 값이 계속 들어가게 된다.</span>
            <span class="n">findMember</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"newCity1"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">));</span>
            <span class="c1">// 출력 결과 : MEMBER_ID를 기준으로 ADDRESS 테이블의 모든 컬럼이 delete가 되고 기존의 테이터인 old2와 새로운 데이터인 newCity1이 insert가 된다.</span>
            <span class="c1">// 결론 : 쓰면안됨</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>값 타입 컬렉션의 제약사항</strong>
      <ul>
        <li>값 타입은 엔티티와 다르게 식별자 개념이 없다.</li>
        <li>값은 변경하면 추적이 어렵다.</li>
        <li>값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 <strong>모든 데이터를 삭제</strong>하고, 값 타입 컬렉션에 있는 <strong>현재 값을 모두 다시 저장</strong>한다. (실무에서는 사용하면 안된다.)</li>
        <li>값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야함 : null 입력 X, 중복 저장 X</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입 컬렉션 대안</strong>
      <ul>
        <li>실무에서는 상황에 따라 <strong>값 타입 컬렉션 대신에 일대다 관계를 고려</strong> (실무에서 많이 쓰임)</li>
        <li>일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용</li>
        <li>영속성 전이(Cascade) + 고아 객체 제거를 사용해서 값 타입 컬렉션 처럼 사용</li>
        <li>EX) AddressEntity</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>값타입 컬렉션은 언제쓰이나?
      <ul>
        <li>엄청 단순할때 사용 (업데이트 필요 없을 때, 추적할 필요 없을 때)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">AddressEntity</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AddressEntity</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">AddressEntity</span><span class="o">(</span><span class="nc">Address</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">address</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AddressEntity</span><span class="o">(</span><span class="nc">String</span> <span class="n">city</span><span class="o">,</span> <span class="nc">String</span> <span class="n">street</span><span class="o">,</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="n">city</span><span class="o">,</span> <span class="n">street</span><span class="o">,</span> <span class="n">zipcode</span><span class="o">);</span>
    <span class="o">}</span>

<span class="nc">Member</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">ALL</span><span class="o">,</span> <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">AddressEntity</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

</code></pre></div></div>

<blockquote>
  <ul>
    <li><strong>정리</strong>
      <ul>
        <li><strong>엔티티 타입의 특징</strong>
          <ul>
            <li>식별자 O</li>
            <li>생명 주기 관리</li>
            <li>공유</li>
          </ul>
        </li>
        <li><strong>값 타입 특징</strong>
          <ul>
            <li>식별자 X</li>
            <li>생명 주기를 엔티티에 의존</li>
            <li>공유하지 않는 것이 안전(복사해서 사용)</li>
            <li>불변 객체로 만드는 것이 안전</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li><strong>값 타입은 정말 값 타입이라 판단 될 때만 사용</strong></li>
    <li><strong>엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨</strong></li>
    <li><strong>식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것은 값 타입이 아닌 엔티티</strong></li>
  </ul>
</blockquote>

<h2 id="quiz">Quiz</h2>

<p><strong>문제 1.</strong> 다음 코드의 상황별 출력 결과를 쓰시오.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Address</span> <span class="n">address1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>
<span class="nc">Address</span> <span class="n">address2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city"</span><span class="o">,</span> <span class="s">"street"</span><span class="o">,</span> <span class="s">"10000"</span><span class="o">);</span>

<span class="n">상황</span> <span class="mi">1</span><span class="o">.</span> <span class="o">==</span> <span class="n">비교</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">address1</span> <span class="o">==</span> <span class="n">address2</span><span class="o">)</span>

<span class="n">상황</span> <span class="mi">2</span><span class="o">.</span> <span class="n">equals</span> <span class="n">비교</span><span class="o">,</span> <span class="nc">Address에</span> <span class="n">equals</span><span class="o">()</span> <span class="n">메소드</span> <span class="n">오버라이드</span> <span class="n">안함</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">address1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">address2</span><span class="o">))</span>

<span class="n">상황</span> <span class="mi">3</span><span class="o">.</span> <span class="n">equals</span> <span class="n">비교</span><span class="o">,</span> <span class="nc">Address에</span> <span class="n">equals</span><span class="o">()</span> <span class="n">메소드</span> <span class="n">오버라이드</span> <span class="n">함</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">address1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">address2</span><span class="o">))</span>
</code></pre></div></div>

<details>
<summary>정답 확인</summary>
<div>
    <p><br /></p>
    <h1>1. false</h1>
    <p><br /></p>
    <h1>2. false</h1>
    <p><br /></p>
    <h1>3. true</h1>
    <p><br /></p>
    <ol>
      <li>== 비교는 참조값을 비교하기 때문에 false가 나온다. <br /></li>
      <li>equals()의 기본은 == 비교이기 때문에 false가 나온다. <br /></li>
      <li>equals() 메소드를 재정의할 경우 내부 값이 같은지 판별하기 때문에 true가 나온다. <br /></li>
    </ol>

    <p><br /></p>
  </div>
</details>
<p><br /></p>

<p><strong>문제 2.</strong> 비슷한 기능을 가진 @MappedSuperclass와 @Embeddable의 차이점을 생각해보자.</p>

<details>
<summary>정답 확인</summary>
<div>
    <p><br /></p>

    <p>@MappedSuperclass는 상속 <br />
@Embeddable은 위임 <br /></p>

    <p><a href="#mappedsuperclass-vs-embeddable">자세한 설명</a>
<br /></p>

  </div>
</details>
<p><br /></p>]]></content><author><name>김경호</name></author><category term="JPA" /><category term="JPA" /><summary type="html"><![CDATA[]]></summary></entry></feed>