var store = [{
        "title": "[Git test]",
        "excerpt":"    Test 2   for git   $git commit -m \"Initial Commit\"  ","categories": ["Git & Github"],
        "tags": ["minimal mistakes","jekyll","blog","favicon","disqus","google analytics"],
        "url": "http://localhost:4000/git%20&%20github/gitTestPost/",
        "teaser": null
      },{
        "title": "[Markdown Basic Sytax]",
        "excerpt":"    GitHub에서 README 파일을 작성할 때나, 블로그에 포스팅을 하거나, 간단한 문서를 만들 때 가볍게 사용하는 문서작성 용도로 자주 사용된다. 그래서 오늘은 이 마크다운 언어에 대해서 알아보려고 한다.   0. 마크다운이란?             일반 텍스트 기반의 경량 마크업 언어   일반 텍스트로 서식이 있는 문서를 작성하는데 사용   일반 마크업 언어에 비해 문법이 쉽고 간단   HTML, 리치텍스트(RTF)등 서식 문서로 변환이 용이            응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 쓰임           0-1. 마크다운 에디터      마크다운 에디터는 메모장이나 아무 에디터를 사용해도 무방   단, 미리보기 기능에 따라 사용성에서 큰 차이   따라서 미리보기 기능을 제공하는 에디터 사용 추천(대부분의 IDE에서 (기본 or 확장기능으로) 제공하고 있기는 함.)            ex) VS Code       미리보기 웹사이트(Make a README)           1. 문법(Syntax)           제목 : title              #을 1~6개 사용하여 크기 조절(&lt;H1&gt; ~ &lt;H6&gt; 지원)       HR(Horizontal Rule, 수평선 구분자)와 결합해서 사용 가능           # 제목1 - H1 ## 제목2 - H2 ### 제목3 - H3 #### 제목4 - H4 ##### 제목5 = H5 ###### 제목6 - H6  // HR(Horizontal Rule, 수평선) 구분자와 결합해서 사용 제목 텍스트 1 ___           제목1 - H1       제목2 - H2       제목3 - H3       제목4 - H4       제목5 = H5       제목6 - H6              제목 텍스트 1                 줄바꿈 : Line Breaks              마크다운 문법에서 엔터를 써도 개행이 되지 않음                    엔터키 2번 : 단락 구분                       ’ ‘ : 공백 2번 입력 -&gt; 줄바꿈(개행                                                                                         : Tag로도 가능                                                   // 공백 2개 입력 X 안녕하세요. 김경호, 개발자입니다.  // 공백 2개 입력 안녕하세요. 김경호, 개발자입니다.  // &lt;br&gt;태그 안녕하세요.&lt;br&gt; 김경호, 개발자입니다.           안녕하세요. 김경호, 개발자입니다.       안녕하세요.  김경호, 개발자입니다.       안녕하세요.  김경호, 개발자입니다.            인용문 : BlockQuote              블럭인용문자(‘&gt;’) 사용           &gt; 첫번째 블록 &gt;&gt; 두번째 블록 &gt;&gt;&gt; 세번째 블록                  첫번째 블록                  두번째 블록                      세번쨰 블록                                     블록 안에 다른 마크다운 요소를 넣을 수 있음           &gt; 첫번째 블록 &gt; 1. 두번쨰 블록 &gt; + 세번째 블록                  첫번째 블록                  두번쨰 블록                        세번째 블록                         목록 : List              순서있는 목록 : 숫자와 마침표 사용           // 1. 2. 3. 이런식으로 해도 되지만, 순서대로 번호를 매겨서 표시됨. 1. 첫번째 아이템   1. 하위 아이템   4. 하위 아이템 1. 두번째 아이템 2. 세번쨰 아이템                  첫번째 아이템       하위 아이템       하위 아이템       두번째 아이템       세번쨰 아이템                  순서없는 목록 : (*, - , +) 사용, 혼합가능           + 첫번째 아이템   - 1-1 아이템   - 1-2 아이템   - 1-3 아이템 + 두번쨰 아이템   * 2-1 아이템   * 2-2 아이템 + 세번쨰 아이템   + 3-1 아이템     + 3-1-1 아이템   + 3-2 아이템                  첫번째 아이템                    1-1 아이템           1-2 아이템           1-3 아이템                       두번쨰 아이템                    2-1 아이템           2-2 아이템                       세번쨰 아이템                    3-1 아이템                            3-1-1 아이템                                   3-2 아이템                                        강조(글씨 꾸미기) : Emphasis              볼드, 이텔릭, 밑줄, 취소선 등 이용가능           *single asterisks 이텔릭체* _single underscores 이텔릭체_ **double asterisks 볼드체** __double underscores 볼드체__ ***tripple underscores 볼드+이텔릭체*** ___tripple underscores 볼드+이텔릭체___ ~~cancelline 취소선~~ **~~bold cancelline 볼드+취소선~~** &lt;u&gt;underline - 밑줄&lt;/u&gt;           single asterisks 이텔릭체  single underscores 이텔릭체  double asterisks 볼드체  double underscores 볼드체  tripple underscores 볼드+이텔릭체  tripple underscores 볼드+이텔릭체  cancelline 취소선  bold cancelline 볼드+취소선  underline - 밑줄                    구분선 : Contour              수평선(Horizontal Rule) 사용법           구분선1 - - - // --- : 제목 문법과 중복되므로 주의!  구분선1-1 ---  구분선1-2 ------------------------------  구분선2 ***  구분선2-1 * * *  구분선2-2 ************************************  구분선3 ___           구분선1         구분선1-1     ## 구분선1-2       구분선2     구분선2-1     구분선2-2         구분선3            코드 : Code            인라인(inline) 코드 &lt;img&gt; 태그를 사용하면 본문에 이미지를 삽입할 수 있습니다.       블록(block) 코드               ```bash     $ git push origin master     ```      ```python     print(\"hello world!\")     ```      ```java     public static void main(String[] args){       System.out.println(\"Hello, world\");     }     ```   $ git push origin master   print(\"hello world!\")   public static void main(String[] args){   System.out.println(\"Hello, world\"); }               표 : Table              본문에 테이블 삽입           |Column1(Left[Default])|Column2(Center)|Column3(Right)| |---|:---:|---:| // 표를 정렬하는 방법 |김경호|개발자|JAVA| |rudgh46|BackEnd|JAVA| |제|목표 도메인은|FullStack입니다.| |My|target Domain is|FullStack|                                      Column1(LeftDefault)           Column2(Center)           Column3(Right)                                           김경호           개발자           JAVA                             rudgh46           BackEnd           JAVA                             제           목표 도메인은           FullStack입니다.                             My           target Domain is           FullStack                                        링크 : Link              문서 작성 시, 특정 사이트를 링크할 때 사용           // [Title](link) : 일반적으로 사용되는 형식 [My GitHub](https://github.com/rudgh46)  // &lt;link Address&gt; : 자동 링크 사용 &lt;https://github.com/rudgh46&gt;  // [link keyword][id] : 참조 링크 사용 // [id] : URL \"Optional Title here Link : [Github][My Github Link] [My Github Link]: https://github.com/rudgh46 \"Go to rudgh46's Github\"           My GitHub       https://github.com/rudgh46       Link : [Github][githublink] [githubLink]: https://github.com/rudgh46 “Go to rudgh46’s Github” (이거 왜 안되징…)            이미지 삽입 : Image              본문에 이미지를 삽입       사이즈 조정 및 정렬은 HTML  Tag 사용           ![TEXT](https://imageurl) ![TEXT](./로컬이미지경로.확장자 \"이미지설명\") ![TEXT](data:image/svg+xml;base64,이미지데이터)  // 참조링크를 이용한 이미지 삽입 ![TEXT][ClassE] [ClassE](https://imageurl \"E클래스 이미지\")  // 이미지에 링크 걸기 ![TEXT](https://imageurl, \"이미지설명\")(LinkURL)  // HTML &lt;img&gt; Tag 사용, 크기 및 정렬 가능 &lt;img src=\"https://cdn.eyesmag.com/content/uploads/sliderImages/2021/02/24/the-new-mercedes-benz-c-class-2021-01-fcc19468-f66c-467a-870f-dc1c7aa29e84.jpg\" width=\"200px\"&gt;  &lt;p align=\"center\"&gt;&lt;img src=\"https://www.motorgraph.com/news/photo/202102/27134_86118_4323.jpg\" width=\"400px\"&gt;&lt;/p&gt;                         2. 장단점           장점              문법이 쉽고 직관적       지원 가능한 플랫폼과 프로그램이 다양       다양한 형태로 변환 가능       Text 형식으로 형상관리를 통한 변경이력관리가 용이       별도 도구 없이 편집가능       Text File이라서 용량이 적음                단점             아직까지 표준이 존재 X       Tool/Viewer에 따라 경과물이 다르게 출력           참고 사이트  ","categories": ["Markdown"],
        "tags": ["markdown","syntax","blog","favicon","disqus","google analytics"],
        "url": "http://localhost:4000/markdown/aboutMarkDown/",
        "teaser": null
      },{
        "title": "[Java 01. 기본 문법 및 응용 (Java의 특징, 변수, 데이터 타입)]",
        "excerpt":"    0. 자바의 특징           OOP is A.P.I.E ?                OOP(Object-Oriented-Programming = 객체지향 프로그래밍) is  Abstraction. Polymorphism. Inheritance. Encapsulation                 GC(Garbage Collection)                더 이상 사용하지 않는 메모리를 자동으로 정리하는 기능                  1. 변수           수학에서는 변하는 수 x     컴퓨터에서는 메모리 공간(그릇)     메모리 공간에 값(value)을 할당(assign) 후 사용     공간의 크기는 타입별로 달라짐      2. Type 이란?           데이터의 종류     Primitive Type (기본형)                미리 정해진 크기의 Memory Size로 표현         변수 자체에 값 저장                 Reference Type (참조형)                크기가 미리 정해질 수 없는 데이터의 표현         변수에는 실제 값을 참조할 수 있는 주소만 저장                          Primitive Type                                                       구분               Type               bit 수               값               Wrapper Class                                                               논리형               boolean                               true/false               Boolean                                         정수형               byte               8               -2^7 ~ 2^7-1 (-128 ~ 127)               Byte                                                         short               16               -2^15 ~ 2^15-1 (-32768 ~ 32767)               Short                                                         int               32               -2^31 ~ 2^31-1 (-2147483648 ~ 2147483647, 대략 20억)               Integer                                                         long               32               -2^31 ~ 2^31-1 (-9223372036854775808 ~ 9223372036854775807)               Long                                         실수형               float               32               float f = 0.1234567890123456789f; =&gt; 0.12345679               Float                                                         double               64               double d = 0.1234567890123456789; =&gt; 0.12345678901234568               Double                                         문자형               char               16               \\u0000 ~ \\uffff(0~2^16-1)               Character                                                      총 8개                                   Reference Type                           나머지 모든 데이터 타입(String, int[], Node와 같은 사용자 정의 타입 …)                           // 기본문제 int i1 = Integer.MAX_VALUE; int i2 = i1+1;  System.out.println(i2);  //실행결과 //overflow   3. 형 변환(Type Casting)           변수의 타입을 다른 타입으로 변환하는 것                char &lt;= =&gt; int                 Primitive는 Primitive끼리, Reference는 Reference기리 형 변환 가능                boolean은 다른 기본 타입과 호환되지 않음         기본 타입과 참조형의 형 변환을 위해서 Wrapper 클래스 활용                 형 변환 방법                형 변환 연산자(괄호) 사용                  double d = 100.5; int result = (int)d; // d = 100.5 // result = 100           타입의 표현 범위                byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double         char  -&gt; int …                 타입의 표현 범위가 커지는 방향으로 할당할 경우는 묵시적 형 변환 발생     명시적 형 변환은 값 손실이 발생할 수 있다.     묵시적 형 변환은 값 손실 걱정없이 JVM이 서비스 해줌      //묵시적 형 변환(값 손실 x)       //명시적 형 변환 (값 손실 o) byte b = 10;                    int i = 300; int i = (int)b;                 byte b = (byte)i; int i2 = b;   //기본문제 int i1 = Integer.MAX_VALUE; int i2 = i1 + 1; System.out.println(i2); // -2147483648  long l1 = i1 + 1; System.out.println(l1); // -2147483648  long l2 = (long)(i1 + 1); System.out.println(l2); // -2147483648  long l3 = (long(i1) + 1); System.out.println(l3); // 2147483648  int i3 = 1000000 * 1000000 / 100000; int i4 = 1000000 / 100000 * 100000; System.out.println(i3 + \" : \" + i4); // -7273 : 1000000 , 컴퓨터는 앞에서부터 계산하기 때문에    int k = 66; char c = (char)k; System.out.println(c); // B  c='A'; k=c; System.out.println(k); //65  int i = 10/3; System.out.println(i); //3  float f = 10/3; System.out.println(f); //3.0  float f2 = 10f / 3F; System.out.println(f2); //3.3333333  double d = 10d / 3D; System.out.println(d); //3.3333333333333335  System.out.println((10/3)*3); //9   Wrapper 클래스?      래퍼 클래스(Wrapper Class)는 산술연산을 위해 정의된 클래스가 아니므로 인스턴스에 저장된 값을 변경할 수 없다.  단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스 값만을 참고할 수 있다.  박싱 : 기본타입 -&gt; 래퍼클래스 / 언박싱 : 래퍼클래스 -&gt; 기본타입 (JDK 1.5부터는 컴파일러가 자동처리, 오토 박싱, 오토 언박싱)    Integer num = new Integer(17); //박싱 int n = num.intValue(); //언박싱 System.out.println(n);  Character ch = 'X'; // 오토박싱, Character ch = new Character('X') char c = ch; //오토언박싱, char c = ch.charValue(); System.out.println(c);  //실행결과 //17 //X  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-1/",
        "teaser": null
      },{
        "title": "[Java 01. 기본 문법 및 응용(연산자, 조건문)]",
        "excerpt":"    1. 연산자란?           어떤 기능을 수행하는 기호(+,-,*,/ …)              연산자의 종류와 우선순위 및 결합 방향                                                       연산기호               결합방향               우선순위                                                               (),.                                                                         ++ – +(부호) -(부호) ~ ! (type):형변환               &lt;-               높음                                         * / %               -&gt;                                                         +(덧셈) -(뺄셈)               -&gt;                                                         « » »&gt;               -&gt;                                                         &lt; &gt; &lt;= &gt;= instanceof               -&gt;                                                         == !=               -&gt;                                                         &amp;               -&gt;                                                         ^               -&gt;                                                         ㅣ               -&gt;                                                         &amp;&amp;               -&gt;                                                         ㅣㅣ               -&gt;                                                         ? :               -&gt;                                                         = *= /= %= += -= «= »= »&gt;= &amp;= ^= ㅣ=               &lt;-               낮음                                                        우선순위는 헷갈리기 쉬우니까 (소괄호) 이용하자                  산술 이항 연산자는 연산 전에 피 연산자의 타입을 일치시킨다.  byte b1 = 10; byte b2 = 20; byte b3 = b1 + b2; //Type mismatch: cannot convert from int to byte //피연산자의 크기가 4byte(int) 미만이면 int로 변경한 후 연산 진행  int i1 = 10; long l1 = 20; int i2 = i1 + l1; //Type mismatch: cannot convert from long to int //두 개의 피연산자 중 큰 타입으로 형 변환 후 연산 진행  float f1 = 10.0; float f2 = f1 + 20.0; //Type mismatch: cannot convert from double to float   int i = 10; System.out.println((i--)%2); //0 System.out.println(--i);     //8 System.out.println(i++);     //8 System.out.println(++(i-2)); //컴파일 에러 ++, --는 변수에만 사용할 수 있다.   비트 논리 연산자           2진수 형태로 변환 후 연산                                                       연산자               연산자 기능               결합방향                                                               &amp;               두 피 연산자의 비트 값이 모두 1인 경우만 1, 나머지는 0 (ex&gt; a&amp;b)               -&gt;                                         ㅣ               두 피 연산자의 비트 값이 모두 0인 경우만 0, 나머지는 1 (ex&gt; aㅣb)               -&gt;                                         ^               두 피 연산자의 비트 값이 서로 다르면 1, 같으면 0 (ex&gt; a^b)               -&gt;                                         ~               두 피 연산자의 모든 비트를 반전시킴 -&gt; 1의 보수 (ex&gt; ~a)               &lt;-                                                   a: 10진수 3 -&gt; 2진수 0 0 0 0 0 0 1 1 b: 10진수 5 -&gt; 2진수 0 0 0 0 0 1 0 1  a &amp; b : 0 0 0 0 0 0 0 1 a | b : 0 0 0 0 0 1 1 1 a ^ b : 0 0 0 0 0 1 1 0   비트 이동 연산자 (쉬프트 연산자)           *2, /2에 비해 속도가 빠름                                                       연산자               연산자 기능               결합방향                                                               «               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 왼쪽으로 이동하고 이동에 따른 빈 공간은 0으로 채움 (ex&gt; a«2)               -&gt;                                         »               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 오른쪽으로 이동하고 이동에 따른 빈 공간은 음수는 1, 양수는 0으로 채움 (ex&gt; a»2)               -&gt;                                         »&gt;               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 오른쪽으로 이동하고 이동에 따른 빈 공간은 0으로 채움 (ex&gt; a»&gt;2)               -&gt;                                                   a = 10; b = a &lt;&lt; 1   =&gt; *2와 동일 c = a &gt;&gt; 1   =&gt; /2와 동일   논리 연산자           논리 연산자                                                       연산자               연산자 기능               결합방향                                                               &amp;               두 개의 피 연산자 모두 true인 경우 true (ex&gt; a&gt;0 &amp; b&gt;0)               -&gt;                                         ㅣ               두 개의 피 연산자가 하나라도 true이면 true (ex&gt; a&gt;0 ㅣ b&lt;0)               -&gt;                                         !               단항 연산자로 피 연산자의 값이 false이면 true, true이면 false로 변경 (ex&gt; !a)               &lt;-                                         ^               두 피 연산자가 서로 다를 경우만 true, 같으면 false (ex&gt; true ^ false -&gt; true, true ^ true -&gt; false)               -&gt;                                                                           &amp;         T         F                             ㅣ         T         F                       T         T         F                             T         T         T                       F         F         F                             F         T         F                          Short Circuit 연산자                                                       연산자               연산자 기능               결합방향                                                               &amp;&amp;               &amp;와 동일한 의미이나 앞의 피 연산자가 false이면 뒤의 피 연산자를 검사하지 않는다. (ex&gt; a&gt;0 &amp;&amp; b&gt;0)               -&gt;                                         ㅣㅣ               ㅣ와 동일한 의미이나 앞의 피 연산자가 true이면 뒤의 피 연산자를 검사하지 않는다. (ex&gt; a&gt;0 ㅣㅣ b&gt;0)               -&gt;                                                   2. 조건문   if문           if(_____)                (논리형) boolean b;  (비교식) x&gt;=y  (Method Call) isEven()                           if문 예제      int a = 20; String grade = null;  if(a&gt;=6){                                 if(a&gt;=19)   grade = \"아동\";                            grade = \"성인\"; } else if(a&gt;=13){                            System.out.println(\"성인\");   grade = \"청소년\";                        else if(a&gt;=13) } else if(a&gt;=19){                            grade = \"청소년\";   grade = \"성인\";                          else if(a&gt;=6) } esle{                                      grade = \"아동\";   grade = \"유아\";                          else }                                            grade = \"유아\";  오류 코드           3항 연산자      int a =10; String str = null;  if(a&gt;=10){   str = \"10 이상\"; } else{   str = \"10 미만\"; }  3항 연산자 사용 str = a&gt;=10 ? \"10 이상\" : \"10 미만\";   switch문           switch(_____)                (정수호환) byte, short, char, int x;  (Enum) Day.MONDAY  (Class Object) Byte, Short, Character, Integer, String  (Method Call) getNumber()                           switch문 예제      switch(value) case 1: ...; case 2: ...; break; case 3: ...; case 4: ...; case 5: ...; break; default:  =&gt; ~부터 break 만나기 전 까지 실행  =&gt; value값이 case 조건에 없으면 default 실행   int month = 3; int day = -1; switch(month){   case 2:     day = 29; break;   case 4:   case 6:   case 9:   case 11:     day = 30; break;   default:     day = 31; }   etc. ★Random 수 활용★                           구분         코드         범위                                 Math.random()         double d = Math.random()         0.0 &lt;= d &lt; 1.0                                 double d = Math.random()*N         0.0 &lt;= d &lt; N.0                                 int i = (int)(Math.random()*N)         0 &lt;= i &lt;= N-1                                 int i = (int)(Math.random()*N)+1         1 &lt;= i &lt; N                       Random rand = new Random();                                           rand.nextInt(N)         int i = rand.nextInt(N)         0 &lt;= i &lt; N                                 int i = rand.nextInt(N)+1         1 &lt;= i &lt;= N                     주사위를 던져서 나올 수 있는 경우의 수(1~6) 구하기 (Random 이용)   int N = 6;  int num = (int)(Math.random()*N)+1; System.out.println(num);  Random rand = new Random(); num = rand.nextInt(N)+1; System.out.println(num);  num = rand.nextInt(100)%N+1; System.out.println(num);      주사위를 두 번 던져서 연속적으로 짝수 또는 홀수가 나오면 ‘A’를, 그렇지 않으면 ‘B’를 출력하는 코드   int N = 6; Random rand = new Random(); int num1 = rand.nextInt(N)+1; int num2 = rand.nextInt(N)+1; String result = null;  boolean isNum1Even = num1%2 == 0; boolean isNum2Even = num2%2 == 0;  result = isNum1Even == isNum2Even ? \"A\" : \"B\";  또는  result = (num1 + num2) % 2 == 0 ? \"A\" : \"B\";  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-2/",
        "teaser": null
      },{
        "title": "[Java 01. 기본 문법 및 응용(반복문, 배열)]",
        "excerpt":"    1. 반복문   for문           for(변수 초기화; 반복 조건; 증감식){실행문}                           실행 순서 : 1.변수 초기화 -&gt; 2. 반복 조건 체크 -&gt; 3. (반복 조건 true) 실행문 (break 있으면 바로 종료) -&gt; 4. 증감식                           //1부터 10까지 더하기 (for문) int sum = 0;  for(int i=0; i&lt;=10; i++){   sum+=i; } // 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10  //주사위를 100번 던진 결과의 합과 평균값 출력 (for문) int sum = 0; int cnt = 100; double avg = 0;  Random rand = new Random(); for(int i=0; i&lt;cnt; i++){   sum += rand.nextInt(6) + 1; } avg = 1.0*sum/cnt; //sum이 int형이므로 1.0을 곱해서 실수로 형 변환 System.out.printf(\"sum: %d, avg: %f%n\", sum, avg); //%d : 정수, %f : 실수, %n : 개행문자   while문           while(반복조건){실행문, 증감식}                           실행 순서 : 1. 반복 조건 체크 -&gt; 2. 실행문 -&gt; 3. 증감식 (break 있으면 바로 종료) -&gt; 4. 1번부터 다시 반복                           //1부터 10까지 더하기 (while문) int sum = 0; int i = 0;  while(i&lt;=10){   sum+=i;   i++; } //0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10  //주사위를 100번 던진 결과의 합과 평균값 출력 (while문) int sum = 0; int cnt = 100; double avg = 0; int i = 0;  Random rand = new Random(); while(i&lt;cnt){   sum+= rand.nextInt(6) + 1;   i++; } avg = 1.0*sum/cnt; //sum이 int형이므로 1.0을 곱해서 실수로 형 변환 System.out.printf(\"sum: %d, avg: %f%n\", sum, avg); //%d : 정수, %f : 실수, %n : 개행문자   for vs while           for  - 초기값, 조건식, 증감식의 위치가 명확  - 반복 회수 예측이 가능한 반복  - index의 증감 활용     while  - 예측 가변적인 반복  - index보다는 break, continue 활용      ///break, continue 활용                                     //출력 for(int i=1; i&lt;10; i++){                                    1   2   c   4   b   for(int j=1; j&lt;10; j++){                                  2   4   o   8   r     if(j==5) break;                                         3   6   n   12  e     if(j==3) continue;                                      4   8   t   16  a     System.out.print(i*j +\"\\t\");                            5   10  i   20  k   }                                                         6   12  n   24     System.out.println();                                   7   14  u   28 }                                                           8   16  e   32                                                             9   18      36  //outer 활용 outer: for(int i=1; i&lt;10; i++){                             //출력         for(int j=1; j&lt;10; j++){                            1 2 2 4 3 6 4 8 5 10 6 12 7 14 8 16 9 18          if(j==5) break outer;          if(j==3) continue outer;          System.out.print(i*j +\"\\t\");        }          System.out.println();       }           #찍기      for(int i=0; i&lt;5; i++){              for(int i=5; i&gt;0; i--){              for(int i=0; i&lt;5; i++){   for(int j=0; j&lt;=i j++){             for(int j=0; j&lt;i; j++){               for(int j=0; j&lt;i; j++){     System.out.print(\"#\");                System.out.print(\"#\");              System.out.print(\" \");   }System.out.println();              }System.out.println();                } }                                    }                                      for(int j=9-2*i; j&gt;0; j--){                                                                               System.out.print(\"#\");                                                                             }                                                                             System.out.println();                                                                           } //출력                                //출력                               //출력 #                                     #####                               ######### ##                                    ####                                 ####### ###                                   ###                                   ##### ####                                  ##                                     ### #####                                 #                                       #   2. 배열           배열(Array) 사용 이유                           동일한 타입의 변수를 여러개 사용하면?                            변수의 수 증가               코드의 길이 증가               반복문 적용 불가               변수의 수가 동적으로 결정될 경우, 사용 불가                                                           배열(Array)로 동일 타입 변수 묶어서 사용하기                           배열이란?                            동일한 타입의 데이터 0개 이상을 하나의 연속된 메모리 공간에서 관리하는 것               요소에 접근하는 속도가 매우 빠르다.               한번 생성하면 크기 변경 불가                                                           배열(Array) 만들기 #1                           타입 [] 변수명;           타입 변수명[];                            int[] points;               String[] names;                                   변수의 타입과 저장하는 데이터의 타입?                            int a =&gt; a의 타입? int               int [] arr =&gt; arr의 타입? int의 배열타입 (Reference형), arr이 저장하는 데이터 타입? int                                                  배열의 생성과 초기화                           생성                            new keyword와 함께 배열의 데이터 타입 및 크기 지정 : new data_type[length]                                    new int[3]; =&gt; int 타입의 자료 3개를 저장할수 있는 배열을 메모리에 생성                   points = new int[3]; 생성된 배열을 points라는 변수에 할당                   points는 메모리에 있는 배열을 가리키는 reference 타입 변수                                                                   초기화                            배열을 생성과 동시에 자료형에 대한 default 초기화 진행                                                                           자료형         기본값         비고                                 boolean         false                                 char         ‘\\u0000’         곰백문자                       byte, short, int         0                                 long         0L                                 float         0.0f                                 double         0.0                                 참조형 변수         null         아무것도 참조하지 않음                     배열의 사용          -배열은 index번호를 가지고 각 요소에 접근 가능              index 번호는 0부터 시작       배열의 길이 : 배열이름.length로 배열의 크기 조회 가능           int [] points = new int[3]; System.out.printf(\"배열의 크기: %d%n\", points.length); =&gt; 3  points[0] = 1; points[1] = 'A';    //묵시적 형 변환 //points[2] = 1.5;  //double 할당 불가 (배열이 int형이므로)  System.out.printf(\"0 번째 요소: %d%n\", points[0]); // 1 System.out.printf(\"1 번째 요소: %d%n\", points[1]); // 65 System.out.printf(\"2 번째 요소: %d%n\", points[2]); // 0   char[]을 이용해 String “KKH”의 각 문자를 저장하고 출력하는 코드   String str = \"KKH\"; char[] ch = new char[str.length()]; //배열의 길이는 str의 길이  for(int i=0; i&lt;ch.length; i++){   ch[i] = str.charAt(i); //문자열에서 문자를 하나씩 가져오기 }  for(int i=0; i&lt;ch.length; i++){   System.out.print(ch[i]); }   String “1234567890” 의 자리 별 수를 1차원 배열에 저장하고 배열을 순회해서 합 구하기   String str = \"1234567890\"; char[] nums = str.toCharArray(); //char 배열로 만들어줌 int sum = 0; for(int i=0; i&lt;nums.length; i++){   sum += num[i]-'0' } System.out.printf(\"sum: %d%n\", sum);           배열(Array) 만들기 #2                           생성과 동시에 할당                            int [] b = {1,3,5,6,8};               int [] c = new int[] {1,3,5,6,8};                                   선언 후 생성 시 초기화 주의                            int [] points;  points = {1,3,5,6,8}; // 컴파일 오류               int [] points;  points = new int[]{1,3,5,6,8}; // 선언할 때는 배열의 크기를 알 수 없을 때                                                   for-each문           가독성이 개선된 반복문으로, 배열 및 Collections에서 사용     index 대신 직접 요소(elements)에 접근하는 변수를 제공     naturally ready only(copied value)     : 사용     index를 사용하지 않아서 간편해졌지만 index를 사용 할 경우에는 사용 불가      int intArray[] = {1,3,5,7};                                   for(int i=0; i&lt;intArray.length; i++){} for(int x : intArray){                                          int x = intArray[i];   System.out.println(x);                  =                     System.out.println(x); }                                                             }  //순서 바꾸기 (swap) int intArray[] = {1,3,5,7}; int temp = intArray[1]; intArray[1] = intArray[2]; intArray[2] = temp;  for(int x : intArray){   System.out.println(x); }      Array is Immutable          최초 메모리 할당 이후, 변경할 수 없음     개별 요소는 다른 값으로 변경이 가능하나, 삭제할 수는 없음.     크기를 늘리거나 줄일 수 없음      배열 요소의 각 숫자가 몇번 사용 되었는지 숫자별로 사용 횟수 출력   int arr[] = {3,7,2,5,7,7,9,2,8,1,1,5,3}; int used[] = new int[10];  for(int num:arr){   used[num]++; //배열 숫자가 used 배열의 index로 활용 } System.out.println(Arrays.toString(used)); //배열 값 출력           2차원 배열(Array) 만들기 #1                           int Type 기준으로 4*3 배열 만들기                                          선언       생성       할당                       int [][] arr       arr = new int[4][3];       arr[0][2] = 3;                 int arr[][]                                 int []arr[]                                   2차원 배열 만들기 #2                           int Type 기준으로 4*3 배열과 값을 동시에 만들기           {}안에 , 와 {}을 이용해서 선언과 동시에 값을 할당                                          선언 생성 할당 동시에                       int [][] arr = {{0,1,2},{0,1,2},{0,1,2},{0,1,2}}                   2차원 배열 만들기 #3                           int Type 기준으로 4*? 배열 만들기           1차 배열만 생성 후, 필요에 따라 2차 배열을 생성함                                          1,2차 선언 / 1차 생성                       int [][] arr = new int[4][]                          2차 생성                       arr[1] = new int[2];                 arr[0] = new int[4];                 arr[2] = {1,2,3}; X           etc. ★배열 탐색★   X로 표시된 항목의 상하좌우 숫자의 합을 구하는 코드                                                            2       3       1       4                 1       X       3       2                 3       4       X       X                 X       4       1       5           int deltas[][] = { {-1,0},{1,0},{0,-1},{0,1}}  int sum = 0; for(int r = 0; r&lt;4; r++)   for(int c=0; c&lt;4; c++)     if(arr[r][c] == 'X'){       for(int d=0; d&lt;4; d++){         int nr = r + deltas[d][0];         int nc = c + deltas[d][1];         if(nr&gt;=0 &amp;&amp; nr&lt;4 &amp;&amp; nc&gt;=0 &amp;&amp; nc&lt;4 &amp;&amp; arr[nr][nc] != 'X'){           sum += arr[nr][nc] - '0';           arr[nr][nc] = '0';         }       }     } System.out.println(sum);  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-3/",
        "teaser": null
      }]
