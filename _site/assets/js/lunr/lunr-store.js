var store = [{
        "title": "[Git test]",
        "excerpt":"    Test 2   for git   $git commit -m \"Initial Commit\"  ","categories": ["Git & Github"],
        "tags": ["minimal mistakes","jekyll","blog","favicon","disqus","google analytics"],
        "url": "http://localhost:4000/git%20&%20github/gitTestPost/",
        "teaser": null
      },{
        "title": "[Markdown Basic Sytax]",
        "excerpt":"    GitHub에서 README 파일을 작성할 때나, 블로그에 포스팅을 하거나, 간단한 문서를 만들 때 가볍게 사용하는 문서작성 용도로 자주 사용된다. 그래서 오늘은 이 마크다운 언어에 대해서 알아보려고 한다.   0. 마크다운이란?             일반 텍스트 기반의 경량 마크업 언어   일반 텍스트로 서식이 있는 문서를 작성하는데 사용   일반 마크업 언어에 비해 문법이 쉽고 간단   HTML, 리치텍스트(RTF)등 서식 문서로 변환이 용이            응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 쓰임           0-1. 마크다운 에디터      마크다운 에디터는 메모장이나 아무 에디터를 사용해도 무방   단, 미리보기 기능에 따라 사용성에서 큰 차이   따라서 미리보기 기능을 제공하는 에디터 사용 추천(대부분의 IDE에서 (기본 or 확장기능으로) 제공하고 있기는 함.)            ex) VS Code       미리보기 웹사이트(Make a README)           1. 문법(Syntax)           제목 : title              #을 1~6개 사용하여 크기 조절(&lt;H1&gt; ~ &lt;H6&gt; 지원)       HR(Horizontal Rule, 수평선 구분자)와 결합해서 사용 가능           # 제목1 - H1 ## 제목2 - H2 ### 제목3 - H3 #### 제목4 - H4 ##### 제목5 = H5 ###### 제목6 - H6  // HR(Horizontal Rule, 수평선) 구분자와 결합해서 사용 제목 텍스트 1 ___           제목1 - H1       제목2 - H2       제목3 - H3       제목4 - H4       제목5 = H5       제목6 - H6              제목 텍스트 1                 줄바꿈 : Line Breaks              마크다운 문법에서 엔터를 써도 개행이 되지 않음                    엔터키 2번 : 단락 구분                       ’ ‘ : 공백 2번 입력 -&gt; 줄바꿈(개행                                                                                         : Tag로도 가능                                                   // 공백 2개 입력 X 안녕하세요. 김경호, 개발자입니다.  // 공백 2개 입력 안녕하세요. 김경호, 개발자입니다.  // &lt;br&gt;태그 안녕하세요.&lt;br&gt; 김경호, 개발자입니다.           안녕하세요. 김경호, 개발자입니다.       안녕하세요.  김경호, 개발자입니다.       안녕하세요.  김경호, 개발자입니다.            인용문 : BlockQuote              블럭인용문자(‘&gt;’) 사용           &gt; 첫번째 블록 &gt;&gt; 두번째 블록 &gt;&gt;&gt; 세번째 블록                  첫번째 블록                  두번째 블록                      세번쨰 블록                                     블록 안에 다른 마크다운 요소를 넣을 수 있음           &gt; 첫번째 블록 &gt; 1. 두번쨰 블록 &gt; + 세번째 블록                  첫번째 블록                  두번쨰 블록                        세번째 블록                         목록 : List              순서있는 목록 : 숫자와 마침표 사용           // 1. 2. 3. 이런식으로 해도 되지만, 순서대로 번호를 매겨서 표시됨. 1. 첫번째 아이템   1. 하위 아이템   4. 하위 아이템 1. 두번째 아이템 2. 세번쨰 아이템                  첫번째 아이템       하위 아이템       하위 아이템       두번째 아이템       세번쨰 아이템                  순서없는 목록 : (*, - , +) 사용, 혼합가능           + 첫번째 아이템   - 1-1 아이템   - 1-2 아이템   - 1-3 아이템 + 두번쨰 아이템   * 2-1 아이템   * 2-2 아이템 + 세번쨰 아이템   + 3-1 아이템     + 3-1-1 아이템   + 3-2 아이템                  첫번째 아이템                    1-1 아이템           1-2 아이템           1-3 아이템                       두번쨰 아이템                    2-1 아이템           2-2 아이템                       세번쨰 아이템                    3-1 아이템                            3-1-1 아이템                                   3-2 아이템                                        강조(글씨 꾸미기) : Emphasis              볼드, 이텔릭, 밑줄, 취소선 등 이용가능           *single asterisks 이텔릭체* _single underscores 이텔릭체_ **double asterisks 볼드체** __double underscores 볼드체__ ***tripple underscores 볼드+이텔릭체*** ___tripple underscores 볼드+이텔릭체___ ~~cancelline 취소선~~ **~~bold cancelline 볼드+취소선~~** &lt;u&gt;underline - 밑줄&lt;/u&gt;           single asterisks 이텔릭체  single underscores 이텔릭체  double asterisks 볼드체  double underscores 볼드체  tripple underscores 볼드+이텔릭체  tripple underscores 볼드+이텔릭체  cancelline 취소선  bold cancelline 볼드+취소선  underline - 밑줄                    구분선 : Contour              수평선(Horizontal Rule) 사용법           구분선1 - - - // --- : 제목 문법과 중복되므로 주의!  구분선1-1 ---  구분선1-2 ------------------------------  구분선2 ***  구분선2-1 * * *  구분선2-2 ************************************  구분선3 ___           구분선1         구분선1-1     ## 구분선1-2       구분선2     구분선2-1     구분선2-2         구분선3            코드 : Code            인라인(inline) 코드 &lt;img&gt; 태그를 사용하면 본문에 이미지를 삽입할 수 있습니다.       블록(block) 코드               ```bash     $ git push origin master     ```      ```python     print(\"hello world!\")     ```      ```java     public static void main(String[] args){       System.out.println(\"Hello, world\");     }     ```   $ git push origin master   print(\"hello world!\")   public static void main(String[] args){   System.out.println(\"Hello, world\"); }               표 : Table              본문에 테이블 삽입           |Column1(Left[Default])|Column2(Center)|Column3(Right)| |---|:---:|---:| // 표를 정렬하는 방법 |김경호|개발자|JAVA| |rudgh46|BackEnd|JAVA| |제|목표 도메인은|FullStack입니다.| |My|target Domain is|FullStack|                                      Column1(LeftDefault)           Column2(Center)           Column3(Right)                                           김경호           개발자           JAVA                             rudgh46           BackEnd           JAVA                             제           목표 도메인은           FullStack입니다.                             My           target Domain is           FullStack                                        링크 : Link              문서 작성 시, 특정 사이트를 링크할 때 사용           // [Title](link) : 일반적으로 사용되는 형식 [My GitHub](https://github.com/rudgh46)  // &lt;link Address&gt; : 자동 링크 사용 &lt;https://github.com/rudgh46&gt;  // [link keyword][id] : 참조 링크 사용 // [id] : URL \"Optional Title here Link : [Github][My Github Link] [My Github Link]: https://github.com/rudgh46 \"Go to rudgh46's Github\"           My GitHub       https://github.com/rudgh46       Link : [Github][githublink] [githubLink]: https://github.com/rudgh46 “Go to rudgh46’s Github” (이거 왜 안되징…)            이미지 삽입 : Image              본문에 이미지를 삽입       사이즈 조정 및 정렬은 HTML  Tag 사용           ![TEXT](https://imageurl) ![TEXT](./로컬이미지경로.확장자 \"이미지설명\") ![TEXT](data:image/svg+xml;base64,이미지데이터)  // 참조링크를 이용한 이미지 삽입 ![TEXT][ClassE] [ClassE](https://imageurl \"E클래스 이미지\")  // 이미지에 링크 걸기 ![TEXT](https://imageurl, \"이미지설명\")(LinkURL)  // HTML &lt;img&gt; Tag 사용, 크기 및 정렬 가능 &lt;img src=\"https://cdn.eyesmag.com/content/uploads/sliderImages/2021/02/24/the-new-mercedes-benz-c-class-2021-01-fcc19468-f66c-467a-870f-dc1c7aa29e84.jpg\" width=\"200px\"&gt;  &lt;p align=\"center\"&gt;&lt;img src=\"https://www.motorgraph.com/news/photo/202102/27134_86118_4323.jpg\" width=\"400px\"&gt;&lt;/p&gt;                         2. 장단점           장점              문법이 쉽고 직관적       지원 가능한 플랫폼과 프로그램이 다양       다양한 형태로 변환 가능       Text 형식으로 형상관리를 통한 변경이력관리가 용이       별도 도구 없이 편집가능       Text File이라서 용량이 적음                단점             아직까지 표준이 존재 X       Tool/Viewer에 따라 경과물이 다르게 출력           참고 사이트  ","categories": ["Markdown"],
        "tags": ["markdown","syntax","blog","favicon","disqus","google analytics"],
        "url": "http://localhost:4000/markdown/aboutMarkDown/",
        "teaser": null
      },{
        "title": "[Java] 01. 기본 문법 및 응용 (Java의 특징, 변수, 데이터 타입)",
        "excerpt":"    0. 자바의 특징           OOP is A.P.I.E ?                OOP(Object-Oriented-Programming = 객체지향 프로그래밍) is  Abstraction. Polymorphism. Inheritance. Encapsulation                 GC(Garbage Collection)                더 이상 사용하지 않는 메모리를 자동으로 정리하는 기능                  1. 변수           수학에서는 변하는 수 x     컴퓨터에서는 메모리 공간(그릇)     메모리 공간에 값(value)을 할당(assign) 후 사용     공간의 크기는 타입별로 달라짐      2. Type 이란?           데이터의 종류     Primitive Type (기본형)                미리 정해진 크기의 Memory Size로 표현         변수 자체에 값 저장                 Reference Type (참조형)                크기가 미리 정해질 수 없는 데이터의 표현         변수에는 실제 값을 참조할 수 있는 주소만 저장                          Primitive Type                                                       구분               Type               bit 수               값               Wrapper Class                                                               논리형               boolean                               true/false               Boolean                                         정수형               byte               8               -2^7 ~ 2^7-1 (-128 ~ 127)               Byte                                                         short               16               -2^15 ~ 2^15-1 (-32768 ~ 32767)               Short                                                         int               32               -2^31 ~ 2^31-1 (-2147483648 ~ 2147483647, 대략 20억)               Integer                                                         long               32               -2^31 ~ 2^31-1 (-9223372036854775808 ~ 9223372036854775807)               Long                                         실수형               float               32               float f = 0.1234567890123456789f; =&gt; 0.12345679               Float                                                         double               64               double d = 0.1234567890123456789; =&gt; 0.12345678901234568               Double                                         문자형               char               16               \\u0000 ~ \\uffff(0~2^16-1)               Character                                                      총 8개                                   Reference Type                           나머지 모든 데이터 타입(String, int[], Node와 같은 사용자 정의 타입 …)                           // 기본문제 int i1 = Integer.MAX_VALUE; int i2 = i1+1;  System.out.println(i2);  //실행결과 //overflow   3. 형 변환(Type Casting)           변수의 타입을 다른 타입으로 변환하는 것                char &lt;= =&gt; int                 Primitive는 Primitive끼리, Reference는 Reference기리 형 변환 가능                boolean은 다른 기본 타입과 호환되지 않음         기본 타입과 참조형의 형 변환을 위해서 Wrapper 클래스 활용                 형 변환 방법                형 변환 연산자(괄호) 사용                  double d = 100.5; int result = (int)d; // d = 100.5 // result = 100           타입의 표현 범위                byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double         char  -&gt; int …                 타입의 표현 범위가 커지는 방향으로 할당할 경우는 묵시적 형 변환 발생     명시적 형 변환은 값 손실이 발생할 수 있다.     묵시적 형 변환은 값 손실 걱정없이 JVM이 서비스 해줌      //묵시적 형 변환(값 손실 x)       //명시적 형 변환 (값 손실 o) byte b = 10;                    int i = 300; int i = (int)b;                 byte b = (byte)i; int i2 = b;   //기본문제 int i1 = Integer.MAX_VALUE; int i2 = i1 + 1; System.out.println(i2); // -2147483648  long l1 = i1 + 1; System.out.println(l1); // -2147483648  long l2 = (long)(i1 + 1); System.out.println(l2); // -2147483648  long l3 = (long(i1) + 1); System.out.println(l3); // 2147483648  int i3 = 1000000 * 1000000 / 100000; int i4 = 1000000 / 100000 * 100000; System.out.println(i3 + \" : \" + i4); // -7273 : 1000000 , 컴퓨터는 앞에서부터 계산하기 때문에    int k = 66; char c = (char)k; System.out.println(c); // B  c='A'; k=c; System.out.println(k); //65  int i = 10/3; System.out.println(i); //3  float f = 10/3; System.out.println(f); //3.0  float f2 = 10f / 3F; System.out.println(f2); //3.3333333  double d = 10d / 3D; System.out.println(d); //3.3333333333333335  System.out.println((10/3)*3); //9   Wrapper 클래스?      래퍼 클래스(Wrapper Class)는 산술연산을 위해 정의된 클래스가 아니므로 인스턴스에 저장된 값을 변경할 수 없다.  단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스 값만을 참고할 수 있다.  박싱 : 기본타입 -&gt; 래퍼클래스 / 언박싱 : 래퍼클래스 -&gt; 기본타입 (JDK 1.5부터는 컴파일러가 자동처리, 오토 박싱, 오토 언박싱)    Integer num = new Integer(17); //박싱 int n = num.intValue(); //언박싱 System.out.println(n);  Character ch = 'X'; // 오토박싱, Character ch = new Character('X') char c = ch; //오토언박싱, char c = ch.charValue(); System.out.println(c);  //실행결과 //17 //X  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-1/",
        "teaser": null
      },{
        "title": "[Java] 01. 기본 문법 및 응용(연산자, 조건문)",
        "excerpt":"    1. 연산자란?           어떤 기능을 수행하는 기호(+,-,*,/ …)              연산자의 종류와 우선순위 및 결합 방향                                                       연산기호               결합방향               우선순위                                                               (),.                                                                         ++ – +(부호) -(부호) ~ ! (type):형변환               &lt;-               높음                                         * / %               -&gt;                                                         +(덧셈) -(뺄셈)               -&gt;                                                         « » »&gt;               -&gt;                                                         &lt; &gt; &lt;= &gt;= instanceof               -&gt;                                                         == !=               -&gt;                                                         &amp;               -&gt;                                                         ^               -&gt;                                                         ㅣ               -&gt;                                                         &amp;&amp;               -&gt;                                                         ㅣㅣ               -&gt;                                                         ? :               -&gt;                                                         = *= /= %= += -= «= »= »&gt;= &amp;= ^= ㅣ=               &lt;-               낮음                                                        우선순위는 헷갈리기 쉬우니까 (소괄호) 이용하자                  산술 이항 연산자는 연산 전에 피 연산자의 타입을 일치시킨다.  byte b1 = 10; byte b2 = 20; byte b3 = b1 + b2; //Type mismatch: cannot convert from int to byte //피연산자의 크기가 4byte(int) 미만이면 int로 변경한 후 연산 진행  int i1 = 10; long l1 = 20; int i2 = i1 + l1; //Type mismatch: cannot convert from long to int //두 개의 피연산자 중 큰 타입으로 형 변환 후 연산 진행  float f1 = 10.0; float f2 = f1 + 20.0; //Type mismatch: cannot convert from double to float   int i = 10; System.out.println((i--)%2); //0 System.out.println(--i);     //8 System.out.println(i++);     //8 System.out.println(++(i-2)); //컴파일 에러 ++, --는 변수에만 사용할 수 있다.   비트 논리 연산자           2진수 형태로 변환 후 연산                                                       연산자               연산자 기능               결합방향                                                               &amp;               두 피 연산자의 비트 값이 모두 1인 경우만 1, 나머지는 0 (ex&gt; a&amp;b)               -&gt;                                         ㅣ               두 피 연산자의 비트 값이 모두 0인 경우만 0, 나머지는 1 (ex&gt; aㅣb)               -&gt;                                         ^               두 피 연산자의 비트 값이 서로 다르면 1, 같으면 0 (ex&gt; a^b)               -&gt;                                         ~               두 피 연산자의 모든 비트를 반전시킴 -&gt; 1의 보수 (ex&gt; ~a)               &lt;-                                                   a: 10진수 3 -&gt; 2진수 0 0 0 0 0 0 1 1 b: 10진수 5 -&gt; 2진수 0 0 0 0 0 1 0 1  a &amp; b : 0 0 0 0 0 0 0 1 a | b : 0 0 0 0 0 1 1 1 a ^ b : 0 0 0 0 0 1 1 0   비트 이동 연산자 (쉬프트 연산자)           *2, /2에 비해 속도가 빠름                                                       연산자               연산자 기능               결합방향                                                               «               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 왼쪽으로 이동하고 이동에 따른 빈 공간은 0으로 채움 (ex&gt; a«2)               -&gt;                                         »               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 오른쪽으로 이동하고 이동에 따른 빈 공간은 음수는 1, 양수는 0으로 채움 (ex&gt; a»2)               -&gt;                                         »&gt;               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 오른쪽으로 이동하고 이동에 따른 빈 공간은 0으로 채움 (ex&gt; a»&gt;2)               -&gt;                                                   a = 10; b = a &lt;&lt; 1   =&gt; *2와 동일 c = a &gt;&gt; 1   =&gt; /2와 동일   논리 연산자           논리 연산자                                                       연산자               연산자 기능               결합방향                                                               &amp;               두 개의 피 연산자 모두 true인 경우 true (ex&gt; a&gt;0 &amp; b&gt;0)               -&gt;                                         ㅣ               두 개의 피 연산자가 하나라도 true이면 true (ex&gt; a&gt;0 ㅣ b&lt;0)               -&gt;                                         !               단항 연산자로 피 연산자의 값이 false이면 true, true이면 false로 변경 (ex&gt; !a)               &lt;-                                         ^               두 피 연산자가 서로 다를 경우만 true, 같으면 false (ex&gt; true ^ false -&gt; true, true ^ true -&gt; false)               -&gt;                                                                           &amp;         T         F                             ㅣ         T         F                       T         T         F                             T         T         T                       F         F         F                             F         T         F                          Short Circuit 연산자                                                       연산자               연산자 기능               결합방향                                                               &amp;&amp;               &amp;와 동일한 의미이나 앞의 피 연산자가 false이면 뒤의 피 연산자를 검사하지 않는다. (ex&gt; a&gt;0 &amp;&amp; b&gt;0)               -&gt;                                         ㅣㅣ               ㅣ와 동일한 의미이나 앞의 피 연산자가 true이면 뒤의 피 연산자를 검사하지 않는다. (ex&gt; a&gt;0 ㅣㅣ b&gt;0)               -&gt;                                                   2. 조건문   if문           if(_____)                (논리형) boolean b;  (비교식) x&gt;=y  (Method Call) isEven()                           if문 예제      int a = 20; String grade = null;  if(a&gt;=6){                                 if(a&gt;=19)   grade = \"아동\";                            grade = \"성인\"; } else if(a&gt;=13){                            System.out.println(\"성인\");   grade = \"청소년\";                        else if(a&gt;=13) } else if(a&gt;=19){                            grade = \"청소년\";   grade = \"성인\";                          else if(a&gt;=6) } esle{                                      grade = \"아동\";   grade = \"유아\";                          else }                                            grade = \"유아\";  오류 코드           3항 연산자      int a =10; String str = null;  if(a&gt;=10){   str = \"10 이상\"; } else{   str = \"10 미만\"; }  3항 연산자 사용 str = a&gt;=10 ? \"10 이상\" : \"10 미만\";   switch문           switch(_____)                (정수호환) byte, short, char, int x;  (Enum) Day.MONDAY  (Class Object) Byte, Short, Character, Integer, String  (Method Call) getNumber()                           switch문 예제      switch(value) case 1: ...; case 2: ...; break; case 3: ...; case 4: ...; case 5: ...; break; default:  =&gt; ~부터 break 만나기 전 까지 실행  =&gt; value값이 case 조건에 없으면 default 실행   int month = 3; int day = -1; switch(month){   case 2:     day = 29; break;   case 4:   case 6:   case 9:   case 11:     day = 30; break;   default:     day = 31; }   etc. ★Random 수 활용★                           구분         코드         범위                                 Math.random()         double d = Math.random()         0.0 &lt;= d &lt; 1.0                                 double d = Math.random()*N         0.0 &lt;= d &lt; N.0                                 int i = (int)(Math.random()*N)         0 &lt;= i &lt;= N-1                                 int i = (int)(Math.random()*N)+1         1 &lt;= i &lt; N                       Random rand = new Random();                                           rand.nextInt(N)         int i = rand.nextInt(N)         0 &lt;= i &lt; N                                 int i = rand.nextInt(N)+1         1 &lt;= i &lt;= N                     주사위를 던져서 나올 수 있는 경우의 수(1~6) 구하기 (Random 이용)   int N = 6;  int num = (int)(Math.random()*N)+1; System.out.println(num);  Random rand = new Random(); num = rand.nextInt(N)+1; System.out.println(num);  num = rand.nextInt(100)%N+1; System.out.println(num);      주사위를 두 번 던져서 연속적으로 짝수 또는 홀수가 나오면 ‘A’를, 그렇지 않으면 ‘B’를 출력하는 코드   int N = 6; Random rand = new Random(); int num1 = rand.nextInt(N)+1; int num2 = rand.nextInt(N)+1; String result = null;  boolean isNum1Even = num1%2 == 0; boolean isNum2Even = num2%2 == 0;  result = isNum1Even == isNum2Even ? \"A\" : \"B\";  또는  result = (num1 + num2) % 2 == 0 ? \"A\" : \"B\";  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-2/",
        "teaser": null
      },{
        "title": "[Java] 01. 기본 문법 및 응용(반복문, 배열)",
        "excerpt":"    1. 반복문   for문           for(변수 초기화; 반복 조건; 증감식){실행문}                           실행 순서 : 1.변수 초기화 -&gt; 2. 반복 조건 체크 -&gt; 3. (반복 조건 true) 실행문 (break 있으면 바로 종료) -&gt; 4. 증감식                           //1부터 10까지 더하기 (for문) int sum = 0;  for(int i=0; i&lt;=10; i++){   sum+=i; } // 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10  //주사위를 100번 던진 결과의 합과 평균값 출력 (for문) int sum = 0; int cnt = 100; double avg = 0;  Random rand = new Random(); for(int i=0; i&lt;cnt; i++){   sum += rand.nextInt(6) + 1; } avg = 1.0*sum/cnt; //sum이 int형이므로 1.0을 곱해서 실수로 형 변환 System.out.printf(\"sum: %d, avg: %f%n\", sum, avg); //%d : 정수, %f : 실수, %n : 개행문자   while문           while(반복조건){실행문, 증감식}                           실행 순서 : 1. 반복 조건 체크 -&gt; 2. 실행문 -&gt; 3. 증감식 (break 있으면 바로 종료) -&gt; 4. 1번부터 다시 반복                           //1부터 10까지 더하기 (while문) int sum = 0; int i = 0;  while(i&lt;=10){   sum+=i;   i++; } //0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10  //주사위를 100번 던진 결과의 합과 평균값 출력 (while문) int sum = 0; int cnt = 100; double avg = 0; int i = 0;  Random rand = new Random(); while(i&lt;cnt){   sum+= rand.nextInt(6) + 1;   i++; } avg = 1.0*sum/cnt; //sum이 int형이므로 1.0을 곱해서 실수로 형 변환 System.out.printf(\"sum: %d, avg: %f%n\", sum, avg); //%d : 정수, %f : 실수, %n : 개행문자   for vs while           for  - 초기값, 조건식, 증감식의 위치가 명확  - 반복 회수 예측이 가능한 반복  - index의 증감 활용     while  - 예측 가변적인 반복  - index보다는 break, continue 활용      ///break, continue 활용                                     //출력 for(int i=1; i&lt;10; i++){                                    1   2   c   4   b   for(int j=1; j&lt;10; j++){                                  2   4   o   8   r     if(j==5) break;                                         3   6   n   12  e     if(j==3) continue;                                      4   8   t   16  a     System.out.print(i*j +\"\\t\");                            5   10  i   20  k   }                                                         6   12  n   24     System.out.println();                                   7   14  u   28 }                                                           8   16  e   32                                                             9   18      36  //outer 활용 outer: for(int i=1; i&lt;10; i++){                             //출력         for(int j=1; j&lt;10; j++){                            1 2 2 4 3 6 4 8 5 10 6 12 7 14 8 16 9 18          if(j==5) break outer;          if(j==3) continue outer;          System.out.print(i*j +\"\\t\");        }          System.out.println();       }           #찍기      for(int i=0; i&lt;5; i++){              for(int i=5; i&gt;0; i--){              for(int i=0; i&lt;5; i++){   for(int j=0; j&lt;=i j++){             for(int j=0; j&lt;i; j++){               for(int j=0; j&lt;i; j++){     System.out.print(\"#\");                System.out.print(\"#\");              System.out.print(\" \");   }System.out.println();              }System.out.println();                } }                                    }                                      for(int j=9-2*i; j&gt;0; j--){                                                                               System.out.print(\"#\");                                                                             }                                                                             System.out.println();                                                                           } //출력                                //출력                               //출력 #                                     #####                               ######### ##                                    ####                                 ####### ###                                   ###                                   ##### ####                                  ##                                     ### #####                                 #                                       #   2. 배열           배열(Array) 사용 이유                           동일한 타입의 변수를 여러개 사용하면?                            변수의 수 증가               코드의 길이 증가               반복문 적용 불가               변수의 수가 동적으로 결정될 경우, 사용 불가                                                           배열(Array)로 동일 타입 변수 묶어서 사용하기                           배열이란?                            동일한 타입의 데이터 0개 이상을 하나의 연속된 메모리 공간에서 관리하는 것               요소에 접근하는 속도가 매우 빠르다.               한번 생성하면 크기 변경 불가                                                           배열(Array) 만들기 #1                           타입 [] 변수명;           타입 변수명[];                            int[] points;               String[] names;                                   변수의 타입과 저장하는 데이터의 타입?                            int a =&gt; a의 타입? int               int [] arr =&gt; arr의 타입? int의 배열타입 (Reference형), arr이 저장하는 데이터 타입? int                                                  배열의 생성과 초기화                           생성                            new keyword와 함께 배열의 데이터 타입 및 크기 지정 : new data_type[length]                                    new int[3]; =&gt; int 타입의 자료 3개를 저장할수 있는 배열을 메모리에 생성                   points = new int[3]; 생성된 배열을 points라는 변수에 할당                   points는 메모리에 있는 배열을 가리키는 reference 타입 변수                                                                   초기화                            배열을 생성과 동시에 자료형에 대한 default 초기화 진행                                                                           자료형         기본값         비고                                 boolean         false                                 char         ‘\\u0000’         곰백문자                       byte, short, int         0                                 long         0L                                 float         0.0f                                 double         0.0                                 참조형 변수         null         아무것도 참조하지 않음                     배열의 사용          -배열은 index번호를 가지고 각 요소에 접근 가능              index 번호는 0부터 시작       배열의 길이 : 배열이름.length로 배열의 크기 조회 가능           int [] points = new int[3]; System.out.printf(\"배열의 크기: %d%n\", points.length); =&gt; 3  points[0] = 1; points[1] = 'A';    //묵시적 형 변환 //points[2] = 1.5;  //double 할당 불가 (배열이 int형이므로)  System.out.printf(\"0 번째 요소: %d%n\", points[0]); // 1 System.out.printf(\"1 번째 요소: %d%n\", points[1]); // 65 System.out.printf(\"2 번째 요소: %d%n\", points[2]); // 0   char[]을 이용해 String “KKH”의 각 문자를 저장하고 출력하는 코드   String str = \"KKH\"; char[] ch = new char[str.length()]; //배열의 길이는 str의 길이  for(int i=0; i&lt;ch.length; i++){   ch[i] = str.charAt(i); //문자열에서 문자를 하나씩 가져오기 }  for(int i=0; i&lt;ch.length; i++){   System.out.print(ch[i]); }   String “1234567890” 의 자리 별 수를 1차원 배열에 저장하고 배열을 순회해서 합 구하기   String str = \"1234567890\"; char[] nums = str.toCharArray(); //char 배열로 만들어줌 int sum = 0; for(int i=0; i&lt;nums.length; i++){   sum += num[i]-'0' } System.out.printf(\"sum: %d%n\", sum);           배열(Array) 만들기 #2                           생성과 동시에 할당                            int [] b = {1,3,5,6,8};               int [] c = new int[] {1,3,5,6,8};                                   선언 후 생성 시 초기화 주의                            int [] points;  points = {1,3,5,6,8}; // 컴파일 오류               int [] points;  points = new int[]{1,3,5,6,8}; // 선언할 때는 배열의 크기를 알 수 없을 때                                                   for-each문           가독성이 개선된 반복문으로, 배열 및 Collections에서 사용     index 대신 직접 요소(elements)에 접근하는 변수를 제공     naturally ready only(copied value)     : 사용     index를 사용하지 않아서 간편해졌지만 index를 사용 할 경우에는 사용 불가      int intArray[] = {1,3,5,7};                                   for(int i=0; i&lt;intArray.length; i++){} for(int x : intArray){                                          int x = intArray[i];   System.out.println(x);                  =                     System.out.println(x); }                                                             }  //순서 바꾸기 (swap) int intArray[] = {1,3,5,7}; int temp = intArray[1]; intArray[1] = intArray[2]; intArray[2] = temp;  for(int x : intArray){   System.out.println(x); }      Array is Immutable          최초 메모리 할당 이후, 변경할 수 없음     개별 요소는 다른 값으로 변경이 가능하나, 삭제할 수는 없음.     크기를 늘리거나 줄일 수 없음      배열 요소의 각 숫자가 몇번 사용 되었는지 숫자별로 사용 횟수 출력   int arr[] = {3,7,2,5,7,7,9,2,8,1,1,5,3}; int used[] = new int[10];  for(int num:arr){   used[num]++; //배열 숫자가 used 배열의 index로 활용 } System.out.println(Arrays.toString(used)); //배열 값 출력           2차원 배열(Array) 만들기 #1                           int Type 기준으로 4*3 배열 만들기                                          선언       생성       할당                       int [][] arr       arr = new int[4][3];       arr[0][2] = 3;                 int arr[][]                                 int []arr[]                                   2차원 배열 만들기 #2                           int Type 기준으로 4*3 배열과 값을 동시에 만들기           {}안에 , 와 {}을 이용해서 선언과 동시에 값을 할당                                          선언 생성 할당 동시에                       int [][] arr = {{0,1,2},{0,1,2},{0,1,2},{0,1,2}}                   2차원 배열 만들기 #3                           int Type 기준으로 4*? 배열 만들기           1차 배열만 생성 후, 필요에 따라 2차 배열을 생성함                                          1,2차 선언 / 1차 생성                       int [][] arr = new int[4][]                          2차 생성                       arr[1] = new int[2];                 arr[0] = new int[4];                 arr[2] = {1,2,3}; X           etc. ★배열 탐색★   X로 표시된 항목의 상하좌우 숫자의 합을 구하는 코드                                                            2       3       1       4                 1       X       3       2                 3       4       X       X                 X       4       1       5           int deltas[][] = { {-1,0},{1,0},{0,-1},{0,1}}  int sum = 0; for(int r = 0; r&lt;4; r++)   for(int c=0; c&lt;4; c++)     if(arr[r][c] == 'X'){       for(int d=0; d&lt;4; d++){         int nr = r + deltas[d][0];         int nc = c + deltas[d][1];         if(nr&gt;=0 &amp;&amp; nr&lt;4 &amp;&amp; nc&gt;=0 &amp;&amp; nc&lt;4 &amp;&amp; arr[nr][nc] != 'X'){           sum += arr[nr][nc] - '0';           arr[nr][nc] = '0';         }       }     } System.out.println(sum);  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-3/",
        "teaser": null
      },{
        "title": "[Java] 02. 기본 문법 및 응용 (Java의 클래스, 객체, 변수의 종류)",
        "excerpt":"    0. 객체지향 프로그래밍이란? (Object Oriented Programming)           객체란?                주체가 아닌 것, 주체가 활용하는 것                        우리 주변에 있는 모든 것으로 프로그래밍의 대상 : 사물, 개념, 논리 …                                     객체지향 프로그래밍                주변의 많은 것들을 객체화 해서 프로그래밍 하는것         객체지향은 객체를 많이 만드는 것을 추천한다?? YES!                 객체지향 프로그래밍의 장점                블록 형태의 모듈화된 프로그래밍                        신뢰성 높은 프로그래밍이 가능하다.             추가/수정/삭제가 용이하다.             재사용성이 높다.                                              현실 세계 객체, 클래스, 프로그램의 객체(instance, object)의 관계                현실의 객체가 갖는 속성과 기능은 추상화(abstraction)되어 클래스에 정의된다.         클래스는 구체화 되어 프로그램의 객체(instance, object)가 된다.                 실생활에서의 예) 붕어빵 틀 = Type, 붕어빵 = 객체                프로그램의 클래스와 객체                        클래스                                객체를 정의해 놓은 것 즉 객체의 설계도, 틀                 클래스는 직접 사용할 수 없고 직접 사용되는 객체를 만들기 위한 틀을 제공할 뿐                                         객체(instance, object)                                클래스를 데이터 타입으로 메모리에 생성된 것                                                                        &lt;클래스&gt;                                       &lt;객체&gt; - 객체를 정의해 놓은 것                         - 클래스를 구체화 한 것 - 객체를 생성할 때 사용     =&gt; 구체화 객체화     - 실제로 동작하는 것 - 데이터 타입                                  - 메모리에 생성된 데이터   &lt;현실세계&gt;    철수            영희          =&gt; 객체 이름: 철수      이름: 영희 나이: 40        나이: 38        =&gt; 상태, 속성 - 변수, 필드 배고픔: X       배고픔: X  먹는다          먹는다          =&gt; 기능, 행위 - 메서드, 함수 일한다          일한다  &lt;프로그래밍&gt; -추상화- Person                         =&gt; 클래스 String name: int age:                       =&gt; 멤버변수 boolean isHungry:  void eat()                     =&gt; 멤버메서드 void work()  -구체화-                       =&gt; 객체(메모리 어딘가에 존재해야 사용할 수 있다) Person p = new Person(); p.name = \"철수\"; p.age = 20; p.isHungry = false;  p.eat(); p.work();   추상화로 클래스 만들고 구체화로 객체 사용하기  Person 클래스 작성하기   Public class Person{   //멤버 변수 - 속성   String name;   int age;   boolean isHungry;    //멤버 메서드 - 동작   void eat(){     isHungry = false;     System.out.println(\"먹기\");   }   void work(){     isHungry = false;     System.out.println(\"일하기\");   }    public static void main(String[] args){     Person p1 = new Person();     p1.name = \"홍길동\";     p1.age = 10;     p1.eat();      Person p2 = new Person();     p2.name = \"장길산\"     p2.age = 3;     p2.work();   } } p1 과 p2는 같은 타입일 뿐, 데이터가 공유되거나 하지는 않는다.   객체 생성과 메모리         1. 변수      변수의 종류          타입에 따른 분류                                                       변수 종류               특징               비고                                                               Primitive Type               기본 8가지 type의 변수               int i, char c, float f…                                         Reference Type               나머지 모든 것(객체 참조)               String s, int[] a, Person p…                                                  선언 위치에 따른 분류                                                       종류               변수 종류               선언 위치                                                               멤버 변수               클래스 멤버변수               클래스 영역 (static keyword)                                                         인스턴스 멤버 변수               클래스 영역                                         지역 변수               지역 변수               함수 내부                                                         파라미터 변수               함수 선언부                                                   public class VariableType {   int instanceVariable; //인스턴스 멤버 변수   static int classVariable; //클래스 멤버 변수   public static void main(String[] args){//파라미터 변수     int localVariable = 10; //로컬변수     for(int i=0; i&lt;100; i++) {//로컬변수      System.out.println(i);     }   } }      인스턴스 멤버 변수의 특징          선언 위치 : 클래스{}영역에 선언     변수의 생성 : 객체가 만들어질 때 객체 별로 생성됨                생성 메모리 영역 : heap                 변수의 초기화 : 타입 별로 default 초기화     변수에 접근 : 객체 생성 후(메모리에 올린 후) 객체 이름(소속)으로 접근                객체를 만들 때 마다 객체 별로 생성 -&gt; 객체마다 고유한 상태(변수 값) 유지                  Person p1 = new Person(); p1.name = \"김경호\"; Person p2 = new Person(); p2.name = \"호경김\"; //////////////////////////////////// 여기까지 작성, 18일 2번째 5:22  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-4/",
        "teaser": null
      },{
        "title": "[JPA] 자바 ORM 표준 JPA 프로그래밍 - 기본편 (영속성 관리, 앤티티 매핑)",
        "excerpt":"    ##  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-1/",
        "teaser": null
      },{
        "title": "[CS] 기본이론_1",
        "excerpt":"    0. CS기본이론을 배워야 하는 이유           수년 경력을 지닌 경력자가 스택과 큐의 차이점을 설명할 수 없다면 무엇을 믿고 그 사람에게 일을 맡길 수 있을까?   모든 고급 개발 지식과 업무의 기본 근간은 알게 모르게 우리가 배웠던 CS 기본 지식으로 연결된다.   우리는 실무에서 스택과 큐를 직접 구현할 일은 거의 없지만 구현하려는 코드에 어떤 자료구조가 알맞은지, 어떤 알고리즘이나 자료구조를 선택해야 하는지에 대한 의사결정은 CS기본기에서 나온다고 해도 과언이 아니다.     CS 기본이론의 필요성                컴퓨터(시스템)에 대한 이해 (컴퓨터와 제대로 소통하기)         자료구조, 알고리즘 활용법(일의 효율을 높이기)         Coder에서 Developer로 성장         기업목적에 따른 기본적 CS지식이 필요                  1. 소프트웨어 공학           소프트웨어 개발 생명주기                계획 단계에서 유지보수 단계에 이르기까지 일어나는 일련의 절차                  정의단계 What                     타당성 분석 -&gt; 개발 계획 -&gt; 요구사항 분석          - 사용자의 요구사항 확인 및 타당성 검토 (계획, 요구분석)                                                          - 개발에 필요한 요구사항 명세화  개발 단계 How                      설계 -&gt; 개발 -&gt; 테스트                            - 코딩을 통한 프로그램 개발 (설계, 개발, 테스트)                                                       - 단위/통합/시스템/인수/설치 테스트  유지보수 단계 Change                   유지보수 -&gt; 폐기                                  - 시스템 운영 및 운영 중 발생한 문제점들에 대한 유지보수 (적용, 예방, 폐기)                                                         - 새로운 시스템 개발로 인한 기존 시스템 폐기           소프트웨어 개발 프로세스 정의                작업(task)순서의 집합 + 제약조건(일정, 예산, 자원)을 포함하는 일련의 활동                  좁은의미 : 사용자의 요구사항을 SW로 구현하기 위한 절차, 과정  넓은의미 : 사용자의 목적을 이루기 위한 기획, 프로젝트 관리 등을 포함한 절차, 과정, 방법  소프트웨어 개발 7단계 : 계획 - 요구분석 - 설계 - 구현 - 테스트 - 반영 - 유지보수           소프트웨어 프로세스 모델(1)                폭포수 모델         프로토타입 모델         나선형 모델         통합프로세스 모델                 소프트웨어 프로세스 모델(2)                애자일 프로세스 모델                        고객의 요구에 민첩하게 대응하고 그때그때 주어지는 문제를 풀어나가는 방법론                                              소프트웨어 아키텍처 정의                           소프트웨어 아키텍처                            소프트웨어에 대한 전체적인 구조               소프트웨어를 이루고 있는 여러 구성요소(서브시스템, 컴포넌트)               구성 요소들의 인터페이스 간의 상호작용 정의               시스템 설계와 개발 시 적용되는 원칙과 지침                                   소프트웨어 아키텍처의 구성                            구성 요소               구성 요소들 사이의 관계               구성 요소들이 외부에 드러내는 속성               구성 요소들과 주변 환경 사이의 관계               구성 요소들이 제공하는 인터페이스               구성 요소들의 협력 및 조립방법                                                           아키텍처 모델(1)                           데이터 중심형 모델                            주요 데이터가 repository에서 중앙 관리               repository와 여기에 접근하는 서브시스템으로 구성               데이터가 한군데에 모여 있기 때문에 데이터를 모순되지 않고 일관성 있게 관리 가능               새로운 서브시스템의 추가 용이               repository의 병목 현상 발생 가능               서브시스템과 repository 사이의 강한 결합 - repository 변경 시 서브시스템에 영향을 줌                                                  아키텍처 모델(2)                           Client-Server 모델                            네트워크를 이용하는 분산 시스템 형태               데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용               서버 :클라이언트(서브시스템)에 서비스 제공               클라이언트 : 서버가 제공하는 서비스를 요청(호출)하는 서브시스템                                                  아키텍처 모델(3)                           Layering 모델                            기능을 몇 개의 계층으로 나누어 배치               구성 : 하위 계층은 서버, 상위 계층은 클라이언트 역할                                                  아키텍처 모델(4)                           Model/View/Controller 모델                            같은 모델의 서브 시스템에 대하여 여러 뷰 서브시스템을 필요로 하는 시스템에 적합               장점                                    데이터를 화면에 표현(뷰)하는 디자인과 로직(모델)을 분리함으로써 느슨한 결합 가능                   구조 변경 요청 시 수정 용이                                               단점                                    기본 기능 설계로 인한 클래스 수의 증가로 복잡도 증가                   속도가 중요한 프로젝트에 부적합                                                                                   소프트웨어 공학 기출문제           소프트웨어 위기에 대해서 설명하시오.      답변 Point : 소프트웨어 위기에 대한 정형화된 답보다는 실제 사례를 들어서 설명하자  예시 : 2000년대 초반 많은 사람들이 이용했던 싸이월드가 이제는 사용되지 않는 것은 서비스에 대한 다양한 수요를 예측하지 못하고 반영하지 못한 대표적인 사례로 생각합니다. 소프트웨어 위기는 소프트웨어가 더 이상 사용자들의 요구를 충족할 수 없어서 사용자들로부터 외면받는 것을 이야기합니다.  * 소프트웨어 위기란? 소프트웨어 공학 초기에 사용되던 용어로 정돈된 주제가 되기 이전에 사용되었다. 이 용어는 급격한 컴퓨터 계산 용량과 문제의 복잡성이 급격히 증가함에 따라 발생하는 것을 서술하기 위하여 사용되었다. 본질적으로, 이는 정확하고 이해할 수 있고, 검증 가능한 컴퓨터 프로그램을 작성하는 것이 얼마나 어려운가를 뜻한다.           소프트웨어 공학이 필요한 이유는 무엇인지 설명하시오.      답변 Point : 소프트웨어 공학의 적용에 대해서 예시를 들어 설명하자, 소프트웨어들을 비교하면 설명이 쉽다.  예시 : 소프트웨어 공학은 소프트웨어의 개발, 운용, 유지보수 등의 단계를 체계적으로 다루는 학문이라고 합니다. 제가 생각하는 소프트웨어 공학은 **에서 진행했던 프로젝트에서 단기간에 원하는 목적으로 이루기 위해서 소프트웨어를 기획하고, 설계하고, 구현하고, 테스트하고, 보완하는 과정을 걸쳤는데 이 과정을 체계적으로 정리하고 이를 공유하는 과정이 소프트웨어 공학이 아닌가 생각합니다.           소프트웨어 개발 경험과 소프트웨어 개발 시 적용한 개발 방법론이 있다면 설명하시오.      답변 Point : 소프트웨어 개발의 경험을 생각해보면 1개 이상의 방법론이 적용된 것을 알 수 있다. 개발 시 고려한 개발방법론이 없더라도 개발했던 경험을 복기해서 가장 적절한 개발방법론을 적용하자  예시 : **에서 프로젝트를 진행하면서 린 개발 방법을 찾아서 적용했습니다. 린 개발 방법론의 가장 큰 특징인 낭비요소를 제거하고, 지속적인 개선과 수행속도의 향상과 더불어 품질을 효과적으로 개선하는 것인데 **의 프로젝트의 기간이 짧아 어려움을 겪었습니다. 초기 서비스에 대한 방향성을 자신할 수 없어서 지속적으로 서비스를 향상할 수 있는 방법론이 필요했고, 그래서 린 개발 방법론을 찾아서 적용하게 되었습니다. 경험이 많지 않아서 린 개발 방법론의 적용이 쉽지는 않았지만, 단기간에 프로젝트를 완성하는데는 도움이 되었습니다.           소프트웨어 프로젝트 진행 경험에 대해서 설명하시오.      답변 Point : 소프트웨어 진행 경험은 '무엇을 개발하였다' 라기 보단 '어떻게 개발하였다'라고 말하는 것이 필요하다. 그 안에는 개발방법론이나 소프트웨어 아키텍처를 들어서 설명하는 것이 필요하다.  예시 : 대학교 졸업을 위한 프로젝트로 빅데이터를 통한 관광정보 제공 서비스를 개발하였습니다. 관광정보에 대한 빅데이터를 수집하고 분석하여 이용자의 특성(연령, 성별, 지역)에 맞추어 관광정보를 제공하는 서비스를 개발하였습니다. 린(Lean)개발 방법론이 짦은 기간 개발에 적용하기에 적절하다고 하여 적용하였습니다.   2. 프로그래밍           객체지향(1)                객체지향 개요                        소프트웨어 객체는 현실 세계의 객체를 필드와 메서드로 모델링한 것             소프트웨어 객체는 상태를 필드(Field)로 정의하고, 동작을 메서드(Method)로 정의             필드는 객체 내부에 ‘선언된 변수’를 의미하고, 메서드는 객체 내부에 ‘정의된 동작’을 의미함                             절차지향                        일련의 동작을 순서에 맞추어 단계적으로 실행하도록 명령어를 나열             데이터를 정의하는 방법보다는 명령어의 순서와 흐름에 중점                             객체지향                        현실 세계를 객체 단위로 프로그래밍하여, 객체는 필드(데이터)와 메서드(코드)를 하나로 묶어 표현             프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소트프웨어 개발에 많이 사용             소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능                                              객체지향(2)                캡슐화(정보은닉)                        필드와 메서드를 하나의 캡슐처럼 포장해 세부 내용을 외부에서 알 수 없도록 감추는 것                             상속                        상위 객체를 상속받은 하위 객체가 상위 객체의 메서드와 필드를 사용하는 것                             다형성                        대입되는 객체에 따라서 메서드를 다르게 동작하도록 구현하는 기술             실행 도중 동일한 이름의 다양한 구현체 중에서 메서드를 선택 가능                                              Jave의 목적                Write Once Run Anywhere         Java는 platform independent하게 동작         Super Computer부터 Smart Card까지 한번 작성된 코드는 코드의 수정이 없이, 코드의 재컴파일 없이 실행가능                 Java 언어의 개발 목적                Program 개발을 쉽게 하였다         Compile환경이 아니라, Interpreted 환경이다.         한 개 이상의 thread를 사용할 수 있다.         동적으로 program을 변화시킬 수 있다.         Code 자체적으로 security를 보장해준다.                          JVM(Java Virtual Machine)                JVM은 System 마다, 그리고 운영체제 마다 다름                 Garbage Collection (GC)                Java는 프로그래머에게 메모리를 release(최적화)하게 하는 책임을 지우지 않음         GC는 Java Program의 life cycle 동안 자동적으로 동작하여 메모리의 부족을 제거                          Process의 개념                프로그램 - 저장장치에 저장되어 있는 정적인 상태         프로세스 - 실행을 위해 메모리에 올라온 동적인 상태         프로그램이 프로세스가 된다는 것은 운영체제로 부터 프로세스 제어 블록을 얻는다는 뜻         프로세스가 종료된다는 것은 해당 프로세스 제어 블록이 폐기된다는 뜻                 Thread의 개념                프로세스에서 실행 제어만 분리한 실행 단위(프로세스 실행부)         프로세서를 사용하는 기본 단위이며, 명령어를 독립적으로 실행할 수 있는 하나의 제어 흐름         같은 그룹의 스레드는 코드, 주소 공간, 운영체제의 자원(파일, 신호) 등을 공유                          멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법     멀티 프로세싱 : CPU를 여러 개 사용하여 여러 개의 Thread를 동시에 처리하는 작업 환경     CPU 멀티 Thread : 하드웨어적인 방법으로 하나의 CPU에서 여러 Thread를 동시에 처리하는 병렬 처리 기법     멀티 Thread : 운영체제가 소프트웨어적으로 프로세스를 작은 단위의 Thread로 분할하여 운영하는 기법              병행성(concurrency) 문제                두 개 이상의 Thread가 어떤 객체에 있는 하나의 데이터에 접근하게 되는 경우         서로 다른 두 스택에서 실행되는 메소드가 객체에 있는 동일한 객체에 대한 getter/setter 메소드를 호출하게 되는 경우         Thread는 자신이 잠시 중단된 적이(interrupt) 있다는 것을 기억할 수가 없음                 Thread에서의 동기화                다중 Thread 환경에서 한번에 하나의 쓰레드 만이 공유 데이터를 접근할 수 있도록 제어하는 것         여러 Thread가 동시에 실행되는 다중 Thread에서 데이터를 공유하기 위해서는 어떤 Thread가 다른 Thread의 상태와 행동 들을 고려                          형상관리 (1)                정의 : SW개발 및 유지보수 과정에서 발생하는 변경 사항들을 관리하기 위해 개발된 일련의 활동 (소프트웨어 개발의 전 단계에 적용되는 활동으로, 유지보수 단계에서 수행)         목적 : 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증함                 주요 기능 : 버전관리, 리비전 관리, 소스관리, 소스코드 관리              형상관리(2)                종류 : SVN, git, Mercurial, Bazaar 등, 주로 SVN과 git 사용         SVN : 소규모 시스템 적합         git : 대규모 시스템 적합                          빌드도구                소스코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 생성하는 프로그램(프로젝트를 진행하며 시간이 지남에 따라 라이브러리의 버전을 자동으로 동기화)         ANT : XML 기반 빌드 스크립트 개발, 명확한 빌드 절차 정의가 필요         MAVEN : 프로젝트에 필요한 모든 종속성(Dependency)를 리스트의 형태로 관리, 전자정부 프레임원크         Gradle : ANT와 MAVEN의 단점을 보완한 오픈소스 기반의 Build 자동화 도구, 안드로이드 스튜디오                  프로그래밍 기출문제           JAVA와 C의 차이를 설명하시오.      답변 Point : 절차지향 vs 객체지향 / 하드웨어 최적화 vs 하드웨어 독립적 등의 여러 관점에서 비교 설명하자.  예시 : C언어는 아두이노를 활용한 IoT 수업에 사용하였었고, 자바는 안드로이드 어플 제작할 때 사용했습니다. 하드웨어를 제어할 때 C언어가 적합한 언어라고 생각합니다. 자바를 사용할 때에는 다양한 유형의 데이터를 정의와 데이터 간의 관계를 설정, 사용자의 동작을 정의, 구현하는 과정을 거쳤는데, 실제 업무와 유사하여 규모 있는 프로젝트를 개발할 때 자바가 적합했던 언어였습니다.  또한, 개발 환경에 있어서도 윈도우 환경에서 개발한 프로그램을 그대로 리눅스 기반으로 알고 있는 안드로이드 환경에서 동작하는 것을 통해서 하드웨어 독립적으로 운영이 가능한 것이 C언어와 차이라고 할 수 있습니다.           JVM 가비지컬렉션 동작 과정을 설명하시오.      답변 Point : 가비지 컬렉션은 메모리와 연관된다. 소프트웨어 개발 경험 중 메모리 부족 현상을 겪은 경험이 있으면, 경험을 토대로 설명하자.  예시 : 가비지컬렉션은 JVM에서 메모리 관리를 하는 방법으로 더 이상 사용하지 않는 메모리에 대해서 수집해서 스스로 동작해서 사용을 해제하는 기능입니다. C언어를 사용할 때에는 코드에서 메모리의 할당과 함께 해제를 같이 처리해주었는데, 자바에서는 직접 해제하는 기능은 없었고, 사용하지 않는 메모리에 대해서는 메모리의 참조변수에 null을 대입해서 참조변수와 연결된 메모리가 더 이상 사용하지 않음을 JVM에 알려주는 것만으로 메모리해제 요청을 하였습니다.           JAVA에 적용된 OOP에 대해서 설명하시오.      답변 Point : 실제 작업한 사례를 통해서 설명하자. 설계한 객체와 클래스를 비교해서 설명  예시 : [관광정보 제공 서비스 프로젝트 개발] * 서비스에서 제공되는 주요 정보인 관광지/ 식당/ 호텔 등을 객체로 정의 * 관광지를 모델링 한 것을 객체/ 모델링한 관광지를 자바의 코드로 정의한 것은 클래스 * 각 클래스에 실제 관광지 값을 대입하여 메모리에 올린 것은 인스턴스  - 주요 모델링한 정보 : 관광지 이름/ 관광지 주소/ 관광지 위경도/ 관광지 길 탐색 기능  - 클래스에서는 관광지의 이름은 PLACE_NAME의 String 타입으로 정의  - 관광지 위/경도는 PLACE_LAT, PLACE_LNG의 double 타입으로 정의  - 길을 탐색하는 기능은 navigate 라는 메소드로 구현  - 객체는 실 세계를 모델링 한 것이면 클래스는 모델링 한 것을 실제 코드로 구현한 것           형상관리 활용 경험을 설명하시오.      답변 Point : 형상관리 경험이 있다면, 형상관리 경험을 이야기, 경험이 없다면, 회사에서 제공하는 서비스나 소프트웨어를 대상으로 필요성을 설명  예시 : 저는 4명의 팀원과 함께 프로젝트를 진행하였습니다. 이중에 2명은 라이브러리를 개발하고 1명은 서버 측을 1명은 사용자 화면 및 동작을 개발하였습니다. 동시에 같이 개발하면서 서로의 코드를 참조하고, 확인을 위해 SVN을 이용해서 형상관리를 진행하였습니다.  SVN을 활용한 형상관리를 하면서 코드 작업 후 업데이트할 때 오류가 있는 코드를 업데이트 하거나, 업데이트 시 정확한 코멘트를 남기지 않아서 애를 먹었던 경험도 있습니다. 초반에는 혼란을 겪었지만, 수시로 베이스 라인 변경과 통제를 통해 형상관리 프로젝트를 체계적으로 관리할 수 있었습니다.   3. 웹&amp;모바일 서비스           웹 서비스(1)                기존의 웹                        HTTP, HTML, URL과 같은 기술을 통해 인터넷에 분산되어 있는 정보 자원들에 대하여 표준화된 접근과 정보 표현 방법                             웹 서비스                        ‘XML’과 ‘인터넷 프로토콜’을 통해 ‘표준화된 방식으로 상호작용’             새로운 기술이라기 보다는 컴포넌트, 인터넷, XML등의 기술을 새로운 개념으로 적용하는 방법론             기본적인 표준 인프라가 구축되어 있는 경우에는 그것을 바탕으로 무궁무진한 활용이 가능                             웹서비스의 특징                        플랫폼에 독립적             동적인 기능(Dynamic Function)             비용 효율적             기존 시스템(Legacy System)에 적용                                              웹 서비스 동작 흐름              웹 서버              정적페이지와 동적 웹페이지                정적 웹페이지                        컴퓨터에 저장된 텍스트 파일 그대로 보는것             HTML                             동적 웹페이지                        저장된 내용을 다른 변수로 가공 처리하여 보는 것             PHP, ASP, JSP                                              클라이언트 - 서버                클라이언트-서버 모델 기반                        서버 : 서비스 정보들을 보관하고 이를 제공해주는 컴퓨터             클라이언트 : 사용자가 서버에서 제공하는 정보를 받는 컴퓨터                             서버 프로그램                        호스트 컴퓨터에 서버 역할을 수행             아파치 또는 IIS등 웹 서버 프로그램             FTP 서비스의 경우 FTP 서버 프로그램                             클라이언트 프로그램                        사용자가 서버에 접속하여 서비스 이용             Chrome, Explorer와 같은 웹 브라우저 프로그램/ FTP 클라이언트 프로그램 필요                                              웹 서버의 구성 예시                윈도우 서버 환경 구축 예시                        Window Server + TOMCAT + JSP + (Oracle)                             리눅스 서버 환경 구축 예시                        리눅스 Server + APACHE + TOMCAT + JSP + (My SQL)                                              모바일 서비스                시스템 소프트웨어                        모바일 운영체제(OS) : 모바일 단말기용 시스템 소프트웨어                             애플리케이션                        다운로드 애플리케이션 (사용자가 직접 다운로드 하여 실행)             모바일 웹 브라우저 (모바일 기기에서 실행되는 웹브라우저)             내장 애플리케이션 (모바일 운영체제에 직접 구현된 프로그램)                             모바일 운영체제(OS)                        휴대폰에서 PC의 운영체제와 같은 역할을 수행             스마트폰의 프로세서, 메모리, 화면 등의 하드웨어를 관리하고 운영             모바일 애플리케이션이 실행되는 소프트웨어 플랫폼 역할             공개형(Open) 모바일 운영체제가 대세                                              모바일 앱 vs 모바일 웹 vs 하이브리드 앱                모바일 앱                        디바이스에 최적화             플랫폼 전용 언어로 개발함             안드로이드 -java / Kotlin             아이폰 - Object-C / Swift                             하이브리드 앱                        유지보수의 편의성             하이브리드 앱 전용 언어로 개발함             React Native             Flutter             XAMARIN             IONIC                             모바일 웹(앱)                        모바일 웹가 모바일 앱의 호환             유지보수의 편의성             모바일 웹을 앱으로 제젝             HTML5 / CSS3 기반의 모바일 웹 개발 후 WebView에서 제공                                      웹&amp;모바일 기출문제           AJAX가 무엇인지 예를 들어서 설명하시오.      답변 Point : 기술적인 접근보다는 서비스를 예시로 설명하자. 쉽게 접할 수 있는 사례를 찾아서 설명한다.  예시 : AJAX는 비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법으로 주로 회원가입 시 아이디 중복검사나 비밀번호 유효성 검사 등에 사용합니다. 웹 페이지는 화면을 이동할 때 마다 화면의 컨텐츠를 다시 가져와서 표시하는데, 웹 서비스 중에는 현재의 화면을 그대로 둔 채로 특정 영역의 데이터를 추가/ 삭제/ 변경 등의 기능을 쓸 때 AJAX을 활용합니다. AJAX를 사용하면 화면 전체를 재 로딩함으로 발생하는 트래픽의 증가도 필요한 영역의 적은 데이터만 통신함으로 트래픽을 줄이는 효과도 있습니다.           웹 브라우저 검색창에서 키워드를 입력하면 결과가 나오는 과정을 설명하시오.      답변 Point : 웹 서버의 흐름을 생각하고, 키워드를 입력 받아 웹서버에서 처리해서 반환하는 과정을 도식화해서 설명  예시 : 웹 브라우저에 검색 창에 키워드를 입력하면 웹 사이트의 검색창에 정의된 form의 method(get/post)의 방식으로 action에 기록된 서버로 검색 키워드를 전송하게 됩니다. 서버는 검색 키워드를 전송 받으면 검색 키워드와 관련하여 구현된 비즈니스 로직을 실행시키고, 그 결과를 HTML로 구성하여 다시 웹 브라우저로 전송합니다. 웹 브라우저는 서버로 부터 새로운 HTML이 오면 결과를 화면에 보여지게 합니다.  ","categories": ["CS"],
        "tags": ["CS"],
        "url": "http://localhost:4000/cs/CS_Basic_1/",
        "teaser": null
      },{
        "title": "[CS] 기본이론_2",
        "excerpt":"    1. 자료구조           자료구조의 분류                정의                        자료를 효율적으로 표현하고 처리할 수 있도록 정리하는것                             자료의 분류                        단순구조 (정수, 실수, 문자, 문자열 등의 기본 자료형)             선형구조 (자료들 사이의 관계가 1:1관계/ 순차 리스트, 연결 리스트, 스택, 큐, 데크 등)             비선형구조 (자료들 사이의 관계가 1:다, 또는 다:다 관계/트리, 그레프 등)             파일 구조 (서로 관련있는 필드로 구성된 레코드 집합인 파일에 대한 구조, 순차파일, 색인파일, 직접파일 등)                                              순차 자료구조                순차 자료구조의 개념                        구현할 자료들을 논리적 순서로 메모리에 연속 저장하는 구현 방식             논리적인 순서와 물리적인 순서가 항상 일치해야 함             C프로그래밍에서 순차 자료구조의 구현 방식 제공하는 프로그램 기법은 배열                                              선형리스트                리스트                        자료를 구조화 하는 가장 기본적인 방법은 나열하는 것                             선형 리스트                        순서 리스트             자료들 간에 순서를 갖는 리스트                                              연결자료구조                자료의 논리적인 순서와 물리적인 순서가 불일치                        각 원소에 저장되어 있는 다음 원소의 주소에 의해 순서가 연결되는 방식             물리적인 순서를 맞추기 위한 오버헤드가 발생하지 않음                             연결리스트의 종류                        연결하는 방식에 따라 단순 연결 리스트와 원형 연결 리스트, 이중 연결             리스트, 이중 원형 연결 리스트                                              연결리스트                단순 연결 리스트                        단순 연결리스트의 개념                                노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가짐                 연결 리스트, 선형 연결 리스트, 단순 연결 선형 리스트                                                         원형 연결 리스트                        단순 연결 리스트에서 마지막 노드가 리스트의 첫 번째 노드와 연결된 리스트             단순 연결 리스트의 마지막 노드의 링크 필드에 첫 번째 노드 연결             링크를 따라 계속 순회하면 이전 노드에 접근 가능                             이중 연결 리스트                        양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트                                              순차 자료구조와 연결 자료구조의 비교                     구분       순차 자료구조       연결 자료구조                       메모리 저장 방식       메모리의 저장 시작 위치부터 빈자리 없이 자료를   순서대로 연속하여 저장, 논리적 순서와 물리적 순서가 일치       메모리에 저장된 물리적 위치가 순서와 상관없이   링크에 의해서 논리적인 순서를 표현하는 구현 방식                 연산 특징       삽입, 삭제 연산 후 자료가 순서대로 연속하여 저장   변경된 논리적인 순서와 물리적 순서가 일치       삽입, 삭제 연산을 하여 논리적인 순서가 변경되어도,   링크 정보만 변경되고, 물리적인 순서가 변경되지 않음                 프로그램 기법       배열을 이용       포인터를 이용                   스택                스택의 정의                        접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 형태의 자료구조             스택에 저장된 원소는 top으로 정한 곳에서만 접근 가능             Top의 위치에서만 원소를 삽입하므로, 먼저 삽입한 원소는 밑에 쌓이고, 나중에 삽입한 원소는 위에 쌓이는 구조             마지막에 삽입(Last-In)한 원소는 맨 위에 쌓여있다가 가장 먼저 삭제(First-Out)됨             후입선출 구조(LIFO, Last-In-First-Out)                                              큐                큐의 정의                        스택과 비슷한 삽입과 삭제의 위치가 제한되어 있는 유한 순서 리스트             큐는 뒤에서는 삽입만 하고, 앞에서는 삭제만 할 수 있는 구조             삽입한 순서대로 원소가 나열되어 가장 먼저 삽입(First-In)한 원소는 맨 앞에 있다가 가장 먼저 삭제(First-Out)됨             선입선출 구조(FIFO, First-In-First-Out)                                              스택과 큐의 연산 비교                             삽입연산               삭제연산                               자료구조       연산자       삽입위치       연산자       삭제위치                 스택       PUSH       TOP       POP       TOP                 큐       enQueue       rear       deQueue       front                   데크(Deque : Double-ended queue)                데크의 정의                        큐 두 개 중 하나를 좌우로 뒤집어서 붙인 구조             큐의 양쪽 끝에서 삽입 연산과 삭제 연산을 수행할 수 있도록 확장한 자료구조                                              트리                트리(tree)의 정의                        원소들 간에 1:n 관계를 가지는 비선형 자료구조             원소들 간에 계층관계를 가지는 계층형 자료구조 (Hierarchical Data Structure)             상위 원소에서 하위 원소로 내려가면서 확장되는 트리 모양의 구조                                              이진트리                이진트리의 정의                        트리의 모든 노드의 차수를 2 이하로 제한하여 전체 트리의 차수가 2 이하가 되도록 정의             이진트리의 모든 노드는 왼쪽 자식 노드와 오른쪽 자식 노드만 가짐             부모 노드와 자식 노드 수와의 관계 -&gt; 1:2             공백 노드도 자식 노드로 취급             0&lt;= 노드의 차수 &lt;= 2                             이진트리의 종류                        포화 이진트리 Full Binary Tree                                모든 레벨에 노드가 포화상태로 차 있는 이진트리                                         완전 이진트리 Complete Binary Tree                                높이가 h이고 노드 수가 n개일 때 (단, n &lt; 2h+1-1), 노드 위치가 포화 이진트리에서의 노드 1번부터 n번까지의 위치와 완전히 일치하는 이진트리                                         편향 이진트리 Skewed Binary Tree                                높이가 h일 때 h+1개의 노드를 가지면서 모든 노드가 왼쪽이나 오른쪽 중 한 방향으로만 서브 트리를 가지고 있는 트리                                                                          그래프                그래프의 정의                        연결되어 있는 원소 사이의 다:다 관계를 표현하는 자료구조                             그래프 G                        객체를 나타내는 정점(vertex)과 객체를 연결하는 간선(edge)의 집합             G = (V,E)             V 는 그래프에 있는 정점들의 집합             E는 정점을 연결하는 간선들의 집합                             그래프의 종류                        무방향 그래프(undirected graph)                                두 정점을 연결하는 간선에 방향이 없는 그래프                                         방향 그래프(directed graph), 다이그래프(digraph)                                간선에 방향이 있는 그래프                                         완전 그래프(complete graph)                                각 정점에서 다른 모든 정점을 연결하여 최대로 많은 간선 수를 가진 그래프                                         부분 그래프(subgraph)                                원래의 그래프에서 정점이나 간선을 일부만 제외하여 만든 그래프                                         가중 그래프(weight graph), 네트워크(network)                                정점을 연결하는 간선에 가중치(weight)를 할당한 그래프                                                                          알고리즘                알고리즘의 정의                        문제해결 방법을 추상화 하여 단계적 절차를 논리적으로 기술해 놓은 명세서                             알고리즘의 조건                        입력 : 알고리즘 수행에 필요한 자료가 외부에서 입력으로 제공             출력 : 알고리즘 수행 후 하나 이상의 결과를 출력             명확성 : 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어들은 명확하게 정의되어야 함             유한성 : 알고리즘은 수행 뒤에 반드시 종료             효과성 : 알고리즘의 모든 명령어들은 기본적이며 실행이 가능해야 함                             알고리즘 표현방법                        자연어를 이용한 서술적 표현 방법             순서도(Flow chart)를 이용한 도식화 표현 방법             프로그래밍 언어를 이용한 구체화 방법             가상코드(Pseudo-code)를 이용한 추상화 방법                             알고리즘 성능기준                        정확성 : 올바른 자료 입력 시 유한한 시간 내에 올바른 결과 출력 여부             명확성 : 알고리즘이 얼마나 이해하기 쉽고 명확하게 작성되었는가             수행량 : 일반적인 연산 제외, 알고리즘 특성 나타내는 중요 연산 모두 분석             메모리 사용량 : 알고리즘 연산시 메모리의 사용량             최적성 : 가장 중요한 요소로 최적화 된 성능을 가져야 함                                     정렬                정렬의 정의                        순서 없이 배열된 자료를 작은 것부터 큰 것 순서인 오름차순(Ascending)이나 큰 것부터 작은 것 순서인 내림차순(Descending)으로 재배열하는 것             키(Key) - 자료를 정렬하는데 사용하는 기준이 되는 특정 값                             정렬의 종류                        선택 정렬(selection sort)                                전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식으로 정렬                                         버블 정렬(bubble sort)                                인접한 두 개의 원소를 비교하여 자리를 교환하는 방식                                         퀵 정렬(quick sort)                                정렬할 전체 원소에 대해서 정렬을 수행하지 않고, 기준 값을 중심으로 왼쪽 부분 집합과 오른쪽 부분 집합으로 분할하여 정렬하는 방법                                         삽입 정렬(insert sort)                                정렬되어있는 부분집합에 정렬할 새로운 원소의 위치를 찾아 삽입하는 방법                                                                 검색(search)                검색의 정의                        컴퓨터에 저장한 자료 중에서 원하는 항목을 찾는 작업             탐색 키를 가진 항목을 찾는 것                             탐색 키(search key)                        자료를 구별하여 인식할 수 있는 키                             삽입/삭제 작업에서의 검색                        원소를 삽입하거나 삭제할 위치를 찾기 위해서 검색 연산 수행                             수행 위치에 따른 분류                        내부 검색 : 메모리 내의 자료에 대해서 검색 수행             외부 검색 : 보조 기억 장치에 있는 자료에 대해서 검색 수행                             검색 방식에 따른 분류                        비교 검색 방식 : 검색 대상의 키를 비교하여 검색, 순차검색, 이진검색, 트리검색             계산 검색 방식 : 계수적인 성질을 이용한 계산으로 검색, 해싱                             순차 검색(sequential search), 선형 검색(linear search)                        일렬로 된 자료를 처음부터 마지막까지 순서대로 검색하는 방법                             색인 순차 검색(index sequential search)                        정렬되어 있는 자료에 대한 인덱스 테이블(index)을 추가로 사용하여 탐색 효율을 높인 검색 방법                             이진 검색, 이분 검색, 보간 검색                        자료의 가운데에 있는 항목을 키 값과 비교하여 다음 검색 위치를 결정하여 검색을 계속하는 방법                             이진트리 검색                        이진 탐색 트리를 사용한 검색 방법                             해싱                        산술적인 연산을 이용하여 키가 있는 위치를 계산하여 바로 찾아가는 계산 검색 방식             검색 방법                                키 값에 대해서 해시 함수를 계산하여 주소를 구하고, 구한 주소에 해당하는 해시 테이블로 바로 이동                                                                  2. 데이터베이스           데이터의 분류                정형 데이터                        구조화된 데이터, 즉 미리 정해진 구조에 따라 저장된 데이터   예) 엑셀의 스프레드시트, 데이터베이스의 테이블                             반정형 데이터                        구조에 따라 저장된 데이터이지만 데이터 내용 안에 구조에 대한 설명이 함께 존재             구조를 파악하는 파싱(parsing) 과정이 필요   예) HTML, XML, JSON 문서나 웹 로그, 센서 데이터                             비정형 데이터                        정해진 구조가 없이 저장된 데이터   예) 소셜 데이터의 텍스트, 영상, 이미지, 워드나 PDF 문서와 같은 멀티미디어 데이터                                              데이터베이스 관리시스템의 정의                1세대                        네트워크 DBMS(그래프 형태), 계층 DBMS(트리 형태)                             2세대 (관계 DBMS)                        데이터베이스를 테이블 형태로 구성                                오라클, MS SQL 서버, MySQL                                                         3세대 (객체지향 DBMS, 객체관계 DBMS)                        객체지향 DBMS : 객체를 이용해 데이터베이스를 구성                                오투(O2), 온투스(ONTOS), 젬스톤(GemStone)                                         객체관계 DBMS : 객체 DBMS + 관계 DBMS                             4세대 (NoSQL/NewSQL DBMS)                        NoSQL DBMS : 비정형 데이터를 처리하는데 적합하고 확장성이 뛰어남                                몽고디비(MongoDB), 카산드라(Cassandra)                                         NewSQL DBMS : 관계 DBMS의 장점 + NoSQL의 확장성 및 유연성                                구글 스패너(Spanner), 볼트DB(VoltDB), 누오DB(NuoDB)                                                                          데이터베이스 용어                스키마(schema) == 테이블(Table)                        데이터베이스에 저장되는 데이터 구조와 제약조건을 정의한 것                             인스턴스(instance)                        스키마에 따라 데이터베이스에 실제로 저장된 값                             데이터 독립성(data independency)                        하위 스키마를 변경하더라도 상위 스키마가 영향을 받지 않는 특성             논리적 데이터 독립성                                개념 스키마가 변경되어도 외부 스키마는 영향을 받지 않음                                         물리적 데이터 독립성                                내부 스키마가 변경되어도 개념 스키마는 영향을 받지 않음                                                                          데이터베이스 언어                데이터 정의어(DDL; Data Definition Language)                        스키마를 정의하거나, 수정 또는 삭제하기 위해 사용             CREATE, ALTER, DROP, RENAME, TRUNCATE                             데이터 조작어(DML; Data Manipulation Language)                        데이터의 삽입, 삭제, 수정, 검색 등의 처리를 요구하기 위해 사용             절차적 데이터 조작어와 비절차적 데이터 조작어로 구분             SELECT, INSERT, UPDATE, DELETE                             데이터 제어어(DCL; Data Control Language)                        내부적으로 필요한 규칙이나 기법을 정의하기 위해 사용             GRANT, REVOKE                                              View의 정의                관계 데이터베이스의 데이터베이스 언어 SQL에서 하나 이상의 테이블(또는 다른 뷰)에서 원하는 모든 데이터를 선택하여, 그들을 사용자 정의하여 나타낸 것         데이터를 실제로 저장하지 않고 논리적으로만 존재하는 테이블이지만, 일반 테이블과 동일한 방법으로 사용함                          데이터베이스 인덱스                인덱스의 정의                        데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조             인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성             고속의 검색 동작 뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공                                              관계 데이터 모델 키(Key)                릴레이션에서 투플들을 유일하게 구별하는 속성 또는 속성들의 집합                 키의 특성                유일성(uniqueness) : 하나의 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야 함         최소성(minimality) : 꼭 필요한 최소한의 속성들로만 키를 구성함                 키의 종류                슈퍼키(super key) : 유일성을 만족하는 속성 또는 속성들의 집합, 고객아이디, (고객아이디, 고객이름)         후보키(candidate key) : 유일성과 최소성을 만족하는 속성 또는 속성들의 집합, 고객아이디, (고객이름, 주소) 등         기본키(primary key) : 후보키 중에서 기본적으로 사용하기 위해 선택한 키, 고객아이디         대체키(alternate key) : 기본키로 선택되지 못한 후보키         외래키(foreign key) : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합                          제약조건                무결성 제약조건(integrity constraint)                        데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙             무결성 : 데이터를 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것                             개체 무결성 제약조건(entity integrity constraint)                        기본키를 구성하는 모든 속성은 널 값을 가질 수 없는 규칙                             참조 무결성 제약조건(referential integrity constraint)                        외래키는 참조할 수 없는 값을 가질 수 없는 규칙                                      데이터베이스 기출문제           View에 대해 설명하시오.      답변 Point : View 사용 경험을 예를 들어서 설명하자  예시 : 관광정보 정보서비스 제공 프로젝트를 개발할 때 제공되는 정보에는 관광정보에 관광 후기 / 사진정보 등의 여러 정보를 제공해야 했는데, 하나의 쿼리로 데이터를 불러오는 것이 쉽지 않아서 관광정보의 목록을 보여주는 View와 관광지의 정보를 보여주는 View를 만들어서 사용하였습니다.           인덱스에 대해 설명하시오.      답변 Point : 인덱스 사용 경험을 예를 들어서 설명하자. 인덱스를 사용할 때와 사용하지 않을 때의 결과를 비교해서 설명하자.  예시 : 관광정보를 제공하는 서비스를 개발하면서 관광정보에 대한 사용자 후기 정보를 크롤링해서 수집했습니다. 관광정보의 후기 정보의 수집건수가 만 건 이상이 수집되면서 조회속도와 검색 속도가 많이 늦어졌습니다. 이 부분을 해결하기 위해서 검색의 대상이 되는 필드에 대해서 인덱스를 설정하여 속도를 향상하였습니다.    3. 컴퓨터구조           폰노이만 구조                개요                        CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조             폰노이만 구조의 가장 큰 특징은 저장장치에서 바로 실행할 수 없고 메모리로 가지고 올라와야 실행이 가능함                                메모리 관리가 중요한 이슈                                                                          컴퓨터 시스템 구성요소                프로세서(Processor)                        운영체제와 가장 밀접한 하드웨어로 각 부분의 동작 제어 및 연산 수행                             버스(Bus)                        프로세서를 포함한 각 장치 간 또는 서브시스템을 서로 연결하여 정보(데이터)를 주고받을 수 있게 해주는 통로                             레지스터(Register)                        프로세서에 위치한 고속 메모리로 프로세서가 바로 사용할 수 있는 데이터 저장                             메모리(Memory)                        메모리 계층 구조는 1950년 ~ 1960년대 메인 메모리의 높은 가격으로 인해 제안된 방법으로, 다양한 레벨의 메모리를 연결하여 비용, 속도, 용량, 접근 시간 등을 상호 보완                             주변장치                        컴퓨터의 기능을 향상시키기 위한 추가 장비                                              운영체제 아키텍쳐                모놀리식 커널                        모든 컴포넌트 커널에 포함             호출 기능만으로 다른 구성 요소와 통신 가능             컴퓨터 시스템에 제한 없이 접근             높은 성능             오류나 악성 코드에 취약                             마이크로커널                        소수의 서비스만 제공             커널 규모 감소, 규모 확장성 향상             구성 요소를 낮은 수준의 권한으로 커널 외부에서 실행             확장성, 이식성, 규모 확장성 향상             모듈 간의 통신이 많아 성능 감소                                              커널                프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모아 놓은 것         단일형 구조 커널                        모듈 간의 통신 비용이 줄어들어 효율적인 운영이 가능                             계층형 구조 커널                        비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들고 계층 간의 통신을 통해 운영체제를 구현하는 방식                             마이크로 구조 커널                        프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공             커널의 각 모듈은 세분화되어 존재하고 모듈 간의 정보교환은 프로세스 간 통신을 이용하여 이루어짐                                              가상머신                가상머신의 정의                        운영체제와 응용 프로그램 사이에서 작동하는 프로그램             가상머신을 설치하면 응용 프로그램이 모두 동일한 환경에서 작동하는 것처럼 보임             자바는 유닉스와 윈도우에서 작동하는 다양한 가상머신을 만들어 배포하는데 이를 자바 가상머신 JavaVirtual Machine, JVM 이라고 함                                              시스템의 주요개념                캐시                        고속 메모리             캐시 적중(cache hit) - 참조하는 정보가 캐시 메모리에 있는 경우             캐시 실패(cache miss) - 참조하는 정보가 메모리에 없는 경우             메모리 참조의 상당수가 캐시 적중되어야 성능 향상 가능             캐시의 예 - L1과 L2 프로세서 캐시             메인 메모리의 일정 부분을 할당해 2차 저장소의 데이터를 캐시하는데 활용                             버퍼                        장치들 사이 혹은 다른 속도로 동작하는 프로세스들 사이에서 데이터를 전송할 때 일시적으로 데이터를 보관하는 저장영역             소프트웨어와 하드웨어 장치들이 데이터를 비동기적으로 전송하게 함으로써 시스템 성능 향상                             스풀링                        한 프로세스와 저속 또는 버퍼가 제한된 입출력 장치 사이에 디스크와 같은 중간 매개체를 두는 기술                             폴링                        CPU가 직접 입출력장치에서 데이터를 가져오거나 내보내는 방식             CPU가 입출력장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 데이터를 처리             CPU가 명령어 해석과 실행이라는 본래 역할 외에 모든 입출력까지 관여해야 하므로 작업 효율이 떨어짐                             인터럽트                        입출력 관리자가 대신 입출력을 해주는 방식             CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영함으로써 시스템의 효율을 높임             데이터의 입출력이 이루어지는 동안 CPU가 다른 작업을 할 수 있음                             인터럽트의 종류                        외부 인터럽트 : 입출력장치로부터 오는 인터럽트뿐 아니라 전원 이상이나 기계적인 오류 때문에 발생하는 인터럽트를 포함             내부 인터럽트 : 프로세스의 잘못이나 예상치 못한 문제 때문에 발생하는 인터럽트             시그널 : 사용자가 직접 발생시키는 인터럽트                                              리눅스 커널                리눅스 커널의 역할                        기본적으로 인터럽트 또는 시스템 콜에 의해 수행됨             모든 작업에 우선하여 동작하는 프로그램             CPU, 메모리, 하드디스크 등의 하드웨어 자원을 제어하여 운영체제의 기본적인 기능을 사용자에게 제공                                프로세스 스케줄링                 기억장치 관리                 파일 시스템 관리                 네트워크 관리                 시스템 콜 인터페이스                 오퍼레이터 콘솔 및 인터페이스 기능                 멀티 프로그래밍 지원                 파일시스템 서비스                 입출력 서비스 등                                         명령 인터프리터(interpreter) 부분은 커널에 내장되어 있지 않으며, 다른 사용자 프로그램과 똑같이 애플리케이션(application) 프로그램으로 독립되어 있음                                      4. 네트워크           TCP/IP                TCP/IP의 시작                        네트워크는 서로 다른 기종의 컴퓨터로 구성되어 있어 각 네트워크 간에 공통으로 사용할 수 있는 프로토콜이 필요             인터넷에서 컴퓨터 간의 통신이 가능하도록 표준화하여 채택한 국제표준통신규약             네트워크와 네트워크를 연결하는 데 사용하는 프로토콜인 TCP/IP는 ‘전송 제어 프로토콜(TCP;Transmission Control Protocol)’과 ‘인터넷 프로토콜(IP; Internet Protocol)’을 의미             인터넷에서 사용하는 응용 프로그램은 대부분 이 TCP/IP 프로토콜을 이용하여 데이터를 교환                             TCP/IP의 구조                        응용 계층 - FTP, 텔넷, SMTP, DNS, DHCP             전송 계층 - TCP, TDP -&gt; 포트 주소             네트워크 계층 - IP, ARP, ICMP -&gt; IP 주소             네트워크 접속 계층 - PPP, SLIP -&gt; 물리 주소             물리주소                                물리 주소(MAC 주소)는 링크 주소 또는 통신망에서 정의된 노드의 주소, 이더넷 네트워크 인터페이스 카드(NIC) 6바이트(48비트) 주소 등을 말한다.                                         인터넷 주소                                인터넷에서는 기존 물리 주소와는 별도로 각 호스트를 식별할 수 있는 유일한 주소를 지정해야 한다.                                         포트주소                                수신지 컴퓨터까지 전송하려면 IP 주소와 물리 주소가 필요하다.                 인터넷 통신의 최종 목적은 한 프로세스가 다른 프로세스와 통신할 수 있도록 하는 것이다.                                                         TCP/IP의 이해                        프로토콜의 필요성                                네트워크는 서로 다른 기종의 컴퓨터로 구성되어 있어 각 네트워크 간에 공통으로 사용할 수 있는 프로토콜의 필요성이 대두                                         프로토콜의 정의                                컴퓨터 간의 통신이 가능하도록 표준화 하여 채택한 통신규약                                         TCP/IP의 정의                                네트워크와 네트워크를 연결하는 데 사용하는 프로토콜인 TCP/IP는 ‘전송 제어 프로토콜(TCP;Transmission Control Protocol)’과 ‘인터넷 프로토콜(IP; Internet Protocol)’을 의미                 인터넷에서 사용하는 응용 프로그램은 대부분 이 TCP/IP 프로토콜을 이용하여 데이터를 교환                                         TCP/IP vs OSI 7                                                     유사점       차이점                       1. 계층 모델이다       1. TCP/IP 모델의 응용 프로그램 계층은   OSI 계층 모델의 표현 계층과 세션 계층은 포함한다.                 2. 응용 프로그램 계층       2. TCP/IP 모델의 네트워크 액세스 계층은 OSI 계층 모델의 데이터 링크 계층과 물리 계층을 포함한다.                 3. 트랜스 포트 계층/ 네트워크 계층과 호환되는 계층       3. TCP/IP 프로토콜은 인터넷 표준                 4. 패킷 스위칭 기술 기반                           TCP/IP 주소                IP Address                        인터넷에 연결된 모든 컴퓨터에는 고유의 주소가 부여             현재 사용하는 IP 주소 체계는 IP ver.4이다.             일반 우편 주소를 시, 동, 번지 등으로 구분하는 것처럼 IP 주소도 네트워크 주소(Net ID)와 호스트 주소(Host ID)로 구분             IP 주소를 효율적으로 배정하려고 클래스라는 개념 도입             클래스에는 A,B,C,D,E 다섯 종류                                Class A : NET ID (1 Byte) + HOST ID (3 Byte)                 Class B : NET ID (2 Byte) + HOST ID (2 Byte)                 Class C : NET ID (3 Byte) + HOST ID (1 Byte)                 Class D : MULTICAST ADDRESS (4 Byte)                 Class E : RESERVED (4 Byte)                                                                 IPv4 vs IPv6                     구분       IPv4       IPv6                       주소 길이       32비트       128비트                 표시 방법       8비스씩 4부분 10진수 표시   ex) 203.252.53.55       16비트 8부분 16진수로 표시   ex) 2002:0221:ABCD:DCBA:0000:FFFF:4002                 주소 개수       약 43억개       2^128개 (약 43억x43억x43억x43억)                 주소할당 방식       A,B,C,D 등의 클래스 단위 비순차 할당       네트워크 규모, 단말기수에 따라 순차할당                 브로드캐스트 주소       있음       없음(대신, 로컬범위 내에서 모든 노드에 대한 멀티캐스트 주소 사용                 헤더 크기       가변       고정                 QoS 제공       미흡       제공                 보안       IPSec 프로토콜 별도 설치       IPSec 자체 지원                 서비스 품질       제한적 품질 보장 (Type of Service에 의한 서비스 품질 일부 지원)       확장된 품질 보장 (트래픽 클래스, 플로우 레이블에 의한 서비스 품질 지원)                 Plug &amp; Play       불가(DHCP 이용 시 가능)       가능                   Routing                패킷의 전송 경로를 지정         전송 경로 결정시 고려 사항                        공평 원칙 : 다른 패킷의 우선 처리를 위해 다른 패킷이 손해를 보면 안됨             효율 원칙 : 전체 네트워크의 효율성에 대해 고려해야 함                             Routing algorithm                        간결성과 시스템 및 네트워크 자원의 최소 사용             라우팅 정보의 안정성과 견고성             라우터간의 라우팅 테이블의 빠른 갱신             네트워크 환경 변화에 따른 갱신                             Static Routing vs Dynamic Routing                        정적 라우팅(Static Routing)                                패킷 전송이 이루어지기 전에 경로 정보를 라우터가 미리 저장하여 중개                 단점 : 경로 정보의 갱신이 어려우므로, 네트워크 변화/ 네트워크 혼잡도 대처 부족                                         동적 라우팅(Dynamic Routing)                                라우터의 경로 정보가 네트워크 상황에 따라 적절히 조절됨                 단점 : 경로 정보의 수집과 관리로 인한 성능 저하                                                         Router                        라우터(Router)는 서로 구조가 다른 망을 연결할 수 있어 근거리 통신망(LAN)과 대도시 통신말(MAN), 광대역 통신망(WAN)을 연결하는 데 사용                                              HTTP 프로토콜                정의                        HTTP(Hypertext Transfer Protocol)는 웹의 기본 통신 프로토콜이다.                                프로토콜이란 상호 간에 정의한 규칙을 의미하며 특정 기기 간에 데이터를 주고받기 위해 정의되었다.                                         웹에서 브라우저와 서버 간에 데이터를 주고받기 위한 방식                             특징                        HTTP 프로토콜은 상태가 없는(stateless) 프로토콜이다.             여기서 상태가 없다 라는 말은 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 뜻             좀 더 쉽게 말해서 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다는 뜻             이러한 특징으로 서버는 세션과 같은 별도의 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있는 성능 상의 이점이 생김             HTTP 프로토콜은 일반적으로 TCP/IP 통신 위에서 동작하며 기본 포트는 80번이다.                             HTTP Request &amp; HTTP Response                        요청과 응답을 이해하기 위해서는 클라이언트(Client)와 서버(Server)를 이해해야 한다.             클라이언트란 요청을 보내는 쪽을 의미하며 일반적으로 웹 관점에서는 브라우저를 의미             서버란 요청을 받는 쪽을 의미하며 일반적으로 데이터를 보내주는 원격지의 컴퓨터를 의미                                              URL                URL의 정의                        서버에 자원을 요청하기 위해 입력하는 영문 주소             숫자로 되어 있는 IP 주소보다는 기억하기 쉽기 때문에 사용                             URL 구조                        http://www.domain.com:1234/path/to/resource?a=b&amp;x=y                                http : protocol                 www.domain.com : host                 1234 : port                 path/to/resource : resource path                 ?a=b&amp;x=y : query                                                                          HTTP 요청메소드                요청한 URL을 이용하여 서버에 특정 데이터를 요청         요청하는 데이터에 특정 동작을 수행하고 싶으면 HTTP 요청 메서드(Http Request Methods)를 이용         HTTP 요청 메소드                        GET : 존재하는 자원에 대한 요청             POST : 새로운 자원을 생성             PUT : 존재하는 자원에 대한 변경             DELETE : 존재하는 자원에 대한 삭제                             이와 같이 데이터에 대한 조회, 생성, 변경, 삭제 동작을 HTTP 요청 메서드로 정의         기타 요청 메서드                        HEAD : 서버 헤더 정보를 획듯. GET과 비슷하나 Response Body를 반환하지 않음             OPTIONS : 서버 옵션들을 확인하기 위한 요청. CORS에서 사용                                              HTTP 상태코드                HTTP 상태코드(HTTP Status Code)                        서버에서 설정해주는 응답(Response) 정보                             2xx - 성공                        200번 대의 사애 코드는 대부분 성공을 의미한다.             200 : GET 요청에 대한 성공             204 : No Content. 성공했으나 응답 본문에 데이터가 없음             205 : Reset Content. 성공했으나 클라이언트의 화면을 새로고침 하도록 권고             206 : Partial Content. 성공했으나 일부 범위의 데이터만 반환                             3xx - 리다이렉션                        300번 대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우이다.             301 : Moved Permanently, 요청한 자원이 새 URL에 존재             303 : See Other, 요청한 자원이 임시 주소에 존재             304 : Not Modified, 요청한 자원이 변경되지 않았으므로 클라이언트에서 캐싱된 자원을 사용하도록 권고. ETag와 같은 정보를 활용하여 변경 여부를 확인                             4xx - 클라이언트 에러                        400번 대의 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우로 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생.             400 : Bad Request, 잘못된 요청             401 : Unauthorized, 권한 없이 요청. Authorization 헤더가 잘못된 경우             403 : Foribidden, 서버에서 해당 자원에 대한 접근 금지             405 : Method Not Allowed, 허용되지 않은 요청 메서드             409 : Conflict, 최신 자원이 아닌데 업데이트 하는 경우. ex) 파일 업로드 시 버전 충돌                             5xx - 서버에러                        500번 대의 상태 코드는 서버 쪽에서 오류가 난 경우이다.             501 : Not Implemented, 요청한 동작에 대해 서버가 수행할 수 없는 경우             503 : Service Unavailable, 서버가 과부하 또는 유지 보수로 내려간 경우                                      네트워크 기출문제           https://www.test.com 이라면 어떻게 동작하는지 설명하시오.      답변 Point : 네트워크 관점에서 동작을 설명하자. 예시 : 이용자가 웹 브라우저에서 www.test.com을 주소창에 입력하면, 웹 브라우저에서는 www.test.com 도메인에 대한 실제 IP ADDRESS를 .RP 프로토콜을 이용해서 DNS에 조회하게 됩니다. 그 이후에 실제 IP ADDRESS를 이용해서 서버의 80 포트를 통해서 서비스를 제공하는 웹 서버에 해당 도메인에 대한 웹 컨텐츠를 요청합니다. 웹 서버는 웹 브라우저를 위한 별도의 포트에 소켓을 개설하고, 그 소켓은 웹 브라우저와 연결됩니다. 웹 서버는 요청 받은 컨텐츠를 웹 브라우저로 보내게 됩니다.           IPv4와 IPv6에 대해서 비교 설명하시오.      답변 Point : IPv4와 IPv6에 대해서 비교 설명하자. 예시 : IPv4가 확장성과 용량 면에서 그 한계가 드러나면서 인터넷 요구 사항의 폭증을 수용하기 위해서 IPv6가 개발되었습니다. IPv6는 IPv4에 비해 다음과 같은 개선점이 있습니다.  1. 패킷을 단편화하지 않고 효율적인 라우팅을 제공함 2. 시간 지연에 민감한 패킷을 구분하는 기본적인 QoS(Quality of Service)를 제공 3. NAT를 없앰으로써 주소 공간을 32비트에서 128비트로 확장 4. 네트워크 레이어 보안을 내장하고 있음 (IPsec) 5. 손쉬운 네트워크 관리를 위한 스테이트리스 주소 자동 구성하고 처리 오버헤드가 줄어든 개선된 헤더 구조를 가지고 있습니다.  ","categories": ["CS"],
        "tags": ["CS"],
        "url": "http://localhost:4000/cs/CS_Basic_2/",
        "teaser": null
      },{
        "title": "[CS] 기본이론_3",
        "excerpt":"    1. 보안           서비스 거부 공격(DoS)                취약점 공격형                        Boink, Bonk, TearDrop 공격             프로토콜의 오류 제어 로직을 악용해 시스템 자원을 고갈시키는 방식                             랜드 공격                        패킷을 전송할 때 출발지 IP 주소와 목적지 IP 주소의 값을 똑같이 만들어서 공격 대상에게 보내는 것                             자원 고갈 공격형                        죽음의 핑 공격 - 시스템을 파괴하는 데 가장 흔히 쓰인 초기의 DoS 공격             네트워크에서 패킷을 전송하기 적당한 크기로 잘라서 보내는 특성을 이용한 공격                             SYN 플러딩 공격                        네트워크에서 서비스를 제공하는 시스템에 걸려있는 사용자 수 제한을 이용한 공격             존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 제공받지 못하게 함.                             HTTP GET 플러딩 공격                        공격 대상 시스템에 TCP 3-웨이 핸드셰이킹 과정으로 정상 접속한 뒤             HTTP의 GET 메소드로 특정 페이지를 무한대로 실행하는 공격                             스머프 공격                        ICMP 패킷과 네트워크에 존재하는 임의의 시스템으로 패킷을 확장해             서비스 거부 공격을 수행하는 것으로, 네트워크 공격에 많이 사용힘.                             메일 폭탄 공격                        메일이 폭주하여 디스크 공간을 가득 채우면 받아야 할 메일을 받을 수 없음             스팸 메일을 서비스 거부 공격으로 분류                                              분산 서비스 거부 공격(DDoS)                분산 서비스 거부 공격의 기본 구성                        공격자(attacker) : 공격을 주도하는 해커 컴퓨터             마스터(master) : 공격자에게 직접 명령을 받는 시스템으로 여러 대의 에이전트를 관리             핸들러(handler) 프로그램 : 마스터 시스템의 역할을 수행하는 프로그램             에이전트(agent) : 직접 공격을 가하는 시스템             데몬(daemon) 프로그램 : 에이전트 시스템의 역할을 수행하는 프로그램                                              스니핑                스니핑 공격                        데이터 속에서 정보를 찾는 것으로 공격 시 아무것도 하지 않고 조용히 있는 것만으로도 충분하여 수동적 공격이라 함.             스니핑 공격자는 가지지 말아야 할 정보까지 모두 볼 수 있어야 하므로 랜 카드의 프러미스큐어스(promiscuous) 모드를 이용해 데이터 링크 계층과 네트워크 계층의 정보를 이용한 필터링을 해제함                             스니핑 공격의 종류                        스위치 재밍 공격                                스위치가 MAC 주소 테이블을 기반으로 포트에 패킷을 스위칭할 때 정상적인 스위칭 기능을 마비시키는 공격                 고가의 스위치는 MAC 테이블의 캐시와 연산자가 쓰는 캐시가 독립적으로 나뉘어 있어 스위치 재밍 공격이 통하지 않음                                         SPAN 포트 태밍 공격                                스위치 포트 미러링(port mirroring) 기능을 이용한 공격                                         포트 미러링                                각 포트에 전송되는 데이터를 미러링 하는 포트에도 똑같이 보내는 것으로 침입 탐지 시스템이나                 네트워크 모니터링 또는 로그 시스템을 설치할 때 많이 사용                                                                 스푸핑                스푸핑 공격의 종류                        ARP 스푸핑 공격                                ARP 스푸핑은 MAC 주소를 속이는 것                 로컬에서 통신하는 서버와 클라이언트의 IP 주소에 대한 데이터 링크 계층의 MAC 주소를 공격자의 MAC 주소로 속여 클라이언트에서 서버로 가는 패킷이나 서버에서 클라이언트로 가는 패킷이 공격자에게 향하게 하여 랜의 통신 흐름을 왜곡하는 공격                                         IP 스푸핑 공격                                트러스트 관계(신뢰 관계)를 맺고 있는 서버와 클라이언트를 확인한 후 클라이언트에 서비스 거부 공격을 하여 연결을 끊은 뒤 클라이언트의 IP 주소를 확보한 공격자는 실제 클라이언트처럼 패스워드 없이 서버에 접근하는 기법                                         ICMP 리다이렉트 공격                                네트워크 계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라고 알려 패킷의 흐름을 바꾸는 공격                                         DNS 스푸핑 공격                                실제 DNS 서버보다 빨리 DNS response 패킷을 보내어 공격 대상이 잘못된 IP 주소로 웹 접속을 하도록 유도하는 공격                                                                 세션하이재킹                세션하이재킹의 정의                        세션 가로채기라는 뜻             세션은 사용자와 컴퓨터 또는 두 컴퓨터 간의 활성화된 상태             세션 하이재킹은 두 시스템 간의 연결이 활성화된 상태, 즉 로그인된 상태를 가로채는 것                                     보안 프로토콜                SSL                        SSL은 방대한 인터넷 상거래의 안전을 위해 사용되는 프로토콜                             SSL 세션 vs 접속                        SSL은 HTTP 1.0과 함께 사용되도록 설계             HTTP 1.0은 보통 다수 접속을 병렬로 유지             SSL 세션 설정은 비용이 소요             공개키 연산이 필요             SSL 세션이 이미 존재할 때 효율적으로 새로운 SSL 접속을 구현하는 프로토콜 포함                             IPSec                        IPSec은 네트워크 계층에 존재             IPSec은 응용프로그램으로부터 자유             IPSec은 복잡한 프로토콜                                “너무 과도하게 기술적”                 별로 필요하지 않은 기능이 과도하게 많음.                                         결함 보유                                몇 가지 심각한 보안상 결함을 보유                                         상호운용성에 심각한 도전                                표준을 갖고 있는 목적에 부합하지 않음!                                         복잡성(반복적으로 강조)                             SSL vs IPSec 비교                        IPSec                                네트워크 계층에 존재(OS의 일부)                 암호화, 무결성, 인증 등을 포함하고 있음.                 과도하게 복잡(심각한 결말 포함)                                         SSL(IEEE 표준 TLS)                                소켓 계층(Session/Presentation/Application)(사용자 영역의 일부)                 암호화, 무결성, 인증 등을 포함하고 있음.                 간단한 규격                                                                  2. 4차 산업혁명 관련 기술           4차 산업혁명                4차 산업혁명이란 무엇인가                        파괴적 기술과 역사적 산업혁명의 전개             AI 기술을 핵심동인으로 상품,서비스의 생산,유통,소비 전 과정에서 모든것이 연결되고 지능화                                              4차 산업혁명의 주요기술                기술 맵                        6대 디지털화 기술                                IoT 사물인터넷 : 사물들의 초연결                 LBS : 공간정보의 디지털화                 클라우드 : 빅데이터의 공간                 빅데이터 : 가치 있는 거대한 데이터                 IoB(웨어러블) : 인간과 스마트기기의 융합                 플랫폼 : 인간의 융합 촉진 연결망                                         6대 아날로그화 기술                                서비스 디자인 : 인간을 위한 서비스 제공                                                                                                         3D 프린터                         로봇 : 가상의 정보를 물질화                                                                                                 증강 가상 현실 : 가상정보를 현실 경험화                 블록체인 핀테크 : 분산화된 신뢰와 거래                 게임화 : O2O의 동기부여                 플랫폼 : 반복되는 공통역량의 공유                                                                          IoT-Bigdata-AI                기술 맵                        개념                                                                                                                        IoT                         Mobile : 모든 기계,인간으로부터 데이터 수집                                                                                                 Cloud &amp; Big Data : 정보처리능력 고도화로 데이터 축적,분석 강화                                                                                                         A.I.                         새로운 가치 : 기계가 데이터로 빠르게 학습하여 새로운 지능정보 가치 창출                                                                                                                         특징 -만물의 데이터화                                실시간 반응                 자율 진화                                                         적용 사례 : 아마존                        데이터 수집(IoT) : 고객의 구매정보 데이터 수집             저장 &amp; 분석(CLOUD/ BIG DATA) : 구매 패턴 빅 데이터화             가치창출(A.I) : 인공지능으로 예상 구매 물품 예상                                                                                     최적화(기술융합) : 발주전 배송 서비스                     유통과 물류 비용 감소                                                                                                              IoT(Internet of Thing)                센서 기반 디바이스로부터 데이터/정보추출         확장성있는 유무선 네트워크를 통해 안정적 전송         효과적 분석을 통한 자동화, 지능형 서비스 구현                                 Sensor       Device       Network Security       Standards       Service                       고성능화   소형화   다기능화   저전력화       OPEN H/W   OPEN S/W       저전력화   장거리 통신   낮은 비용   안정성/보안       공유   안정적   표준화       OPEN API   Cloud Service   Application                   빅데이터                빅데이터의 특성                        속도 : 데이터가 생성되고, 저장되며, 가공되어 표시되는 속도가 빠름도             크기 : 데이터의 물리적인 크기가 매우 큼             다양성 : 데이터의 형태 유무와, 연산가능 여부에 따라 나누어지는 데이터들이 매우 다양             빅데이터의 공통적 속성 3V = 속도(Velocity), 크기(Volume), 다양성(Variety) 최근에는 정확성(Veracity)과 가변성(variability), 가치(Value), 시각화(Visualization)등의 속성이 추가                                                     구분       전통적 데이터       빅데이터                       데이터 원천       전통적 정보 서비스       일상화된 정보 서비스                 목적       업무와 효율성       사회적 소통, 자기표현, 사회 기반 서비스                 생성 주체       정부 및 기업 등 조직       개인 및 시스템                 데이터 유형       정형 데이터   조직 내부 데이터(고객 정보, 거래 정보, 등)   주로 비공개 데이터       비정형 데이터   (비디오 스트림, 이미지 오디오, 소셜 네트워크 등 사용자 데이터, 센서 데이터, 응용프로그램 데이터 등)                 데이터 특징       데이터 증가량 관리 가능   신뢰성 높은 핵심 데이터       기하급수로 양적 증가   쓰레기 데이터 비중 높음   문맥 정보 등 다양한 데이터                 데이터 보유       정부, 기업 등 대부분 조직       인터넷 서비스 기업(구글, 아마존 등)   포털(네이터, 다음 등)   이동 통신사(SKT,KT 등)   디바이스 생산회사(삼성, 애플 등)                 데이터 플랫폼       정형 데이터를 생산, 저장, 분석, 처리 할 수 있는 전통적 플랫폼       비정형 대량 데이터를 생산, 저장, 분석, 처리할 수 있는 새로운 플랫폼                   빅데이터 장단점                장점                        의사결정의 정확도를 높일 수 있다.             가까운 미래를 예측하고 새로운 기회를 창출 할 수 있다.             고객에 관한 통찰력을 향상 시킬 수 있다.                             단점                        프라이버시             예측이 완벽하지 않다.                                     빅데이터 관점                소스로서 빅데이터는 대용량 자료나 문제해결 및 분석을 위한 원천자료를 의미         분석으로서 빅데이터는 자료의 분석과 해석에서 어떠한 의미를 도출하는 과정         시각화로서 빅데이터는 데이터의 시각화나 시각화 이전 현상을 구조화하거나 패턴화하는 것         문화로서 빅데이터는 문화를 발견하고 이해하고 예측하는 도구를 의미                 빅데이터 분석과정                빅데이터 분석과정에서 가장 우선되어야 하는 것은?                        where : 데이터를 어디로부터 가져오는가             why : 데이터 분석 결과가 왜 필요한가             who : 누구를 위해 사용할 것인가                                     빅데이터 처리과정                데이터소스 -&gt; 수집 -&gt; 저장 -&gt; 처리 -&gt; 분석 -&gt; 표현                          AI                인공지능의 중요성                        최근 들어 인공지능이 중요한 화두로 떠오른 데에는 빅데이터로 대변되는 데이터양의 폭발적인 증가가 한몫 함             기존에 보유하고 있던 데이터는 물론, 사물인터넷으로 수집된 데이터까지 분석하여 비즈니스에 활용하고자 하는 요구가 많아 짐             범용성 : 하나의 기술을 여러 용도로 다양한 산업에 사용할 수 있음을 의미함             최근에는 인공지능의 범용성이 높아짐             기존에는 IT 산업에만 인공지능 기술이 적용되었다면, 최근에는 제조, 금융, 의료 등 전 산업에 적용되고 있는 추세                             인공지능 서비스 개발 과정                        데이터 수집 : 사용자 문의, 다른 회사와의 협업             데이터 저장 및 처리 : 저장 및처리 장치 이용, 클라우드 서비스 이용             프로그램 제작 : AI 알고리즘 활용, 패턴 분석 및 제작             서비스 배포 : 클라우드 서비스 활용                             AI 서비스 개발을 위한 기술                        데이터 수집에 필요한 사물인터넷 기술             데이터를 전송하기 위한 5G 기술             데이터를 저장하고 처리하기 위한 클라우드 기술             패턴 분석을 위한 인공지능 기술                                              블록체인                블록체인은 제 3자 도움 없이 타인과의 거래를 가능하게 하고, 그 거래를 기록한 장부 시스템을 유지하는 기술개념         블록체인에 관한 다양한 정의                        TCP/IP와 같은 기술 프로토콜 계층             거래 데이터베이스, 모든 거래들의 탈중앙화된 공공장부             거래 목록으로 이루어진 블록들의 체인으로, 거래들의 순차적 장부이다.             새로운 형태의 정보기술로, 지구적 스케일의 조직 시스템이자 인프라로서 자기점검능력과 통제력을 가지는 탈중앙화된 시스템             자기결정과 책임을 가지는 디지털 노마드를 성장시키는 기반환경                             주요기능                        거래 승인과 함께 거래 정보가 공유되는 플랫폼             암호화 기술을 통해 구현된 안전한 데이터 저장소             서로 신뢰가 없는 주체들을 연결시켜주는 통로                             주요 매커니즘                        거래의 유효성 검증             거래내역이 분산 및 공유             암호화되어 저장                             How it work                        거래요청 -&gt; 거래정보가 네트워크 참여자들로 전파 -&gt; 거래 유효성 검증 -&gt; 거래정보 담긴 블록 생성 -&gt; 블록체인에 블록 연결 -&gt; 거래승인 완료                             블록체인 확장분야 8C                        Currency : 비트코인과 같이 다양한 목적의 파생 및 지능형 화폐들이 등장할 수 있다.             Contract : 일정 조건을 만족시키면 자동으로 거래가 실행되도록 하는 것으로 소유권 이전이나 상속,증여 등에 사용될 수 있다.             Cross border : 국제 송금 서비스 등의 국제 금융거래를 획기적으로 개선할 수 있으며 효율적으로 거래를 가능하도록 한다.             Community : OPA를 활용하여 기존 상품권, 로열티 포인트 등을 블록체인에 기입하고 관리할 수 있다.             Common Record : 블록체인은 공공기록을 관리하기에 적합하고 효율적인 기술로 활용될 것으로 전망된다.             Consensus : 발행된 토큰을 유권자에게 나눠주고 정책이나 후보에게 토큰을 다시 보내는 방식으로 투표가 가능하다.             Contents : 디지털아트, 웹툰 등의 저작권을 증명하는것이 가능하여 새로운 콘텐츠 시장의 등장도 가능하다. (NFT)             Co-Ownership : 집, 자동차 등의 소유권 등록 후 이용시간과 범위 등 세부적인 수준으로 공유할 수 있다.                                              클라우드                클라우드로 인한 변화                        클라우드 컴퓨팅은 이제 단순히 기술 트렌드가 아니라 이미 우리 생활 속에 깊숙이 들어온 것             네이버 N드라이브나 드롭박스 등의 퍼스널 클라우드는 동기화 기술의 발전과 더불어 언제 어느 곳에서나 문서를 편집하고 공유                             엣지 컴퓨팅                        센서와 디바이스에서 쏟아지는 데이터를 네트워크 엣지에서 먼저 선별한 후, 중요한 데이터만을 서버로 내보내는 기술             특징                                엣지 컴퓨팅은 클라우드 컴퓨팅의 단점인 안전성, 즉시성, 효율성을 극복할 수 있는 대안                 자율주행 자동차(네트워크 지연이나 데이터 전송 오류로 인한 사고 예방)                 항공엔진 및 드론(산업기계 자체가 중앙 서버와 원거리에 있는 연결의 문제 해결)                 스마트 팩토리(대규모의 센서 데이터에 대한 효율적 처리가 필요) 등에 적용                                                         클라우드 컴퓨팅 vs 엣지 컴퓨팅                        클라우드 컴퓨팅은 ‘클라우드 데이터 센터’에 아웃소싱 준 형태라면, 엣지 컴퓨팅은 클라우드에 위임했던 작업을 ‘엣지’에서 한 차례 추린 후 데이터 센터로 전달하는 방식                             클라우드의 구분                        하이브리드 클라우드                                퍼블릭 클라우드와 프라이빗 클라우드의 결합 모델                 퍼블릭 프라이빗 클라우드의 장접을 모아 클라우드가 줄 수 있는 혜택을 최대한 제공하는 유형                                         오픈스택(OpenStack)                                클라우드 환경에서 컴퓨팅 자원과 스토리지 인프라를 셋업하고 구동하기 위해 사용하는 오픈소스 소프트웨어 프로젝트의 집합                                                                          5G                이동통신의 환경변화                        초고속                                2020년까지 개인당 매월 생성하는 데이터 양이 15년 대비 6.6배 증가 예상                 이 중 비디오 사용량이 전체 모바일 데이터 트래픽의 75% 차지                                         저지연                                자율 주행 차량이 매일 동안 4,000GB 데이터 생성 운전자와 차량을 안전하게 유지하기 위해 밀리 초 단위 의사 결정 필수                                         초연결                                2020년까지 모바일 사용자수는 15년 48억에서 55억으로 증가 예상                 모바일 기기 및 연결은 기기 85억개와 M2M 연결 31억개를 포함해 2020년까지 79억개(15년)에서 116억개로 증가 전망                                                         공식명칭                        5G 이동통신은 3GPP*에서 기술 표준화에 대한 논의가 시작되었으며 ITU**에서는 IMT-2020이라는 공식 명칭                             5G 네트워크의 기술적 특징                        최대 전송속도 향상             다수 기기 연결             초저지연 실시간 서비스                             5G 서비스 영역                        초고속                                4K/8K UHD                 홀로그램                 VR,AR                                         저지연                                실시간 통신 및 촉감 인터넷                 로봇 실시간 원격 조종                 커넥티드 카 (V2X)                                         초연결                                시설, 환경 원격 감시 및 제어                 스마트 빌딩/도시                 사물인터넷                                                                  4차 산업혁명 관련 기출문제           빅테이터 활용 방안에 대해서 설명하시오.      답변 Point : 지원한 회사의 서비스 (가능하다면 차세대 전력 서비스)에 적용하여 설명하자. 지원한 회사에 대한 정확한 분석이 필요  예시 : ex.카카오 모빌리티 카카오 모빌리티는 오랜 기간 동안 카카오택시 등의 서비스로 다양한 종류의 빅데이터를 수집했습니다. 그리고 빅데이터를 기반으로 하는 다양한 서비스를 제공하고 있습니다. 제가 그 서비스에 하나를 더한다면, 카카오택시를 운행하는 기사님들의 이동경로 빅데이터를 활용해서 기사식당과 같은 로컬 맛집을 제공하고 싶습니다.           인공지능 기술은 회사의 사업에 적용해서 설명하시오.      답변 Point : 회사의 사업분야 중에서 인공지능이 필요로 하는 영역이나 반복적인 연산과 판단이 필요한 분야를 제안하자.  예시 : ex. 우아한 형제들 우아한 형제들이 제공하는 배달의 민족 어플에서 사용자의 주문내역과 날씨 등의 환경을 분석해서 사용자에게 음식을 추천하는 서비스를 제공합니다. 가령, 고객이 치킨을 지속적으로 주문을 했다면 치킨의 종류를 분석하여 고객이 한 종류의 치킨을 주로 시킨다면 다른 브랜드의 유사한 치킨이 나왔을 때 추천해주거나, 고객이 새로운 유형의 치킨을 시킨다면 새로운 유형의 치킨이 나올 때 추천하는 등의 배달메뉴 추천 서비스를 인공지능 기술을 활용하여 제공할 수 있습니다.           실생활에서 볼 수 있는 사물인터넷 기술에 대해서 설명하시오.      답변 Point : 거창한 기술이 아닌, 주변에서 기술요소들을 찾자. 사물인터넷은 교통분야, 방제분야, 상하수 처리분야 등에서 활용되고 있다. 구체적으로 답변하는 것이 필요하다.  예시 : 사물인터넷은 모든 사물에 인터넷을 연결하여 정보를 수집하고 수집된 정보를 기반으로 다양한 서비스를 제공하는 것으로 이해하고 있습니다. 주변 환경에서도 가깝게 찾는다면, 면접 보러 가는 길에 적용된 IoT 기술의 두 가지 사례를 얘기해보겠습니다.  집 근처에의 하천 길에는 하천의 수위를 측정하는 센서와 하천의 수위를 모니터링 하는 CCTV가 있습니다. 이렇게 수집된 정보는 재난방지 시스템에 연동되는 것으로 알고 있습니다.  두 번째로는 버스는 타고 면접장까지 이동할 때, 정류장에는 버스의 이동을 탐지하는 센서와 카메라가 있어 버스 안에서도 버스의 위치를 파악하고, 버스 내부를 모니터링 하는 CCTV가 이러한 정보들도 수집되는 것으로 알고 있습니다.           4차 산업혁명의 핵심 기술들을 은행에서 어떻게 활용해야 하는가?      답변 Point : 4차 산업혁명의 대표적인 기술은 IoT - 빅데이터 - AI가 큰 줄기를 가지고 있다. 이 줄기 기반으로 확장해서 설명할 수 있다. 은행에서 (또는 기업에서) 활용할 수 있는 방법을 제시하자.  예시 : 은행은 신규상품을 개발하기 위해서 자사 및 계열사의 고객정보나 SNS 등을 통해 수집된 데이터, 기후,재난과 같은 사회,자연 현상과 관련된 데이터 등 다양하고 광대한 정보를 활용할 수 있습니다. 특히 신규 개발상품의 적절한 가격을 책정하는 데(예: 보험 상품의 효율 책정)에 사용할 수 있습니다.   Final. 기본 이론 5가지 WRAP - UP           소프트웨어 공학                소프트웨어 개발 주기         프로세스                        정의             모델(5가지)                             아키텍쳐                        정의             모델(4가지)                                              프로그래밍                프로그래밍 언어종류         객체지향                        개요 및 특징             객체지향 언어(Java)                             데이터 분석 주요언어         인공지능 주요언어         IoT 사물인터넷         형상관리         디자인 패턴         리팩토리                          웹/모바일 서비스                웹서비스         웹서버                        웹페이지             클라이언트 서버             웹서버 종류 (6가지)             웹서버 구성             웹기술                             모바일 서비스                        모바일 앱             모바일 웹             하이브리드 앱                                              데이터베이스                데이터 분류         DB관리시스템         DB 용어         DB 언어         View 정의         Index 정의         데이터 모델링                        개념, 절차, 구성             관계데이터 모델             논리적데이터 모델                             정규화                          네트워크                OSI7 layer         TCP/IP         Routing                 ","categories": ["CS"],
        "tags": ["CS"],
        "url": "http://localhost:4000/cs/CS_Basic_3/",
        "teaser": null
      },{
        "title": "[JPA] 자바 ORM 표준 JPA 프로그래밍 - 기본편 (연관관계 매핑 기초, 다양한 연관관계 매핑)",
        "excerpt":"    ##  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-2/",
        "teaser": null
      },{
        "title": "[JPA] 자바 ORM 표준 JPA 프로그래밍 - 기본편 (고급매핑, 프록시와 연관관계 관리)",
        "excerpt":"    고급매핑   1. 상속관계 매핑           관계형 데이터베이스는 상속 관계 X (객체는 상속관계가 있음)     슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사     상속관계 매핑 : 객체의 상속 구조와 DB의 슈퍼타입, 서브타입 관계를 매핑              슈퍼타입 논리 모델을 실제 물리 모델로 구현하는 방법                각각 테이블로 변환 -&gt; 조인 전략                         앨범 데이터를 추가하면 ITEM과 ALBUM에 insert가 된다. (즉, insert 2번)             ITEM 테이블의 DTYPE를 통해 어느 테이블과 조인할지 구분 가능                             통합 테이블로 변환 -&gt; 단일 테이블 전략                         DTYPE을 통해 Album, Movie, Book중 무엇인지 구분 가능                             서브타입 테이블로 변환 -&gt; 구현 클래스마다 테이블 전략                          주요 어노테이션                @Inheritance(strategy = InheritanceType.XXX)                        JOINED : 조인전략             SINGLE_TABLE : 단일 테이블 전략             TABLE_PER_CLASS : 구현 클래스마다 테이블 전략                             @DiscriminatorColumn(name=“DTYPE”)         @DiscriminatorValue(“XXX”)                  @Entity @Inheritance(strategy = InheritanceType.JOINED) //JOINED를 SINGLE_TABLE로 바꾸면 단일 테이블 전략 @DiscriminatorColumn  // (name = \"DIS_TYPE)을 적으면 컬럼명 바꾸기 가능 //단일 테이블 전략은 @DiscriminatorColumn 안써도 자동으로 DTYPE 생성됨(한 테이블에 들어가있기때문에 DTYPE이 없으면 뭔지 알수없다.) public abstract class Item {      @Id @GeneratedValue     private Long id;      private String name;     private int price; }           JPA의 장점 : 조인 테이블 전략으로 개발하다가 단일 테이블 전략으로 바꿔야 할 경우 @Inheritance 어노테이션만 수정하면 된다      @Entity @DiscriminatorValue(\"A\") public class Album extends Item{      private String artist; }   public class JpaMain {      public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");          EntityManager em = emf.createEntityManager();          EntityTransaction tx = em.getTransaction();         tx.begin();          try {             Movie movie = new Movie();             movie.setDirector(\"aaaa\");             movie.setActor(\"bbbb\");             movie.setName(\"바람\");             movie.setPrice(10000);              em.persist(movie);//(조인 전략 사용시 insert 두번, 단일테이블 전략 사용시 insert 한번)              em.flush();             em.clear(); //영속성 컨텍스트 제거, 1차 캐시 비움              Movie findMovie = em.find(Movie.class, movie.getId()); //실행시 콘솔에 쿼리가 나온다. (조인 전략은 조인 사용)             System.out.println(\"findMovie = \" + findMovie);              tx.commit();         }catch (Exception e){             tx.rollback();         }finally {             em.close();         }         emf.close();     } }   조인 전략 실행결과      ITEM 테이블과 MOVIE 테이블의 ID는 똑같다. (ITEM의 ID는 PK, MOVIE의 ID는 PK,FK)   DTYPE의 M은 Movie (@DiscriminatorValue을 사용)             장점                테이블 정규화         외래 키 참조 무결성 제약조건 활용가능 (ITEM_ID 사용, 설계가 깔끔해짐)         저장공간 효율화 (정규화가 되어있기 때문에)                 단점                조회시 조인을 많이 사용, 성능 저하 (조인을 잘 하면 성능저하 크게 발생 안함, 저장공간이 효율화 되어있기 때문에 오히려 성능이 잘 나올수도 있다)         조회 쿼리가 복잡함         데이터 저장시 INSERT SQL 2번 호출                          조인전략이 정석이라고 생각하면 된다.     객체와도 잘 맞고 정규화도 되고 깔끔하게 설계 가능     단일 테이블에 비해서는 복잡하다      단일 테이블 전략 실행결과                장점                조인이 필요 없으므로 일반적으로 조회 성능이 빠름         조회 쿼리가 단순함                 단점                자식 엔티티가 매핑한 컬럼은 모두 null 허용 (데이터 무결성 입장애서는 애매한게 있다)         단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다. (웬만해서는 임계점을 넘을 경우가 거의 없다.)                  구현 클래스마다 테이블 전략 결과      ITEM 테이블은 안만들어진다.   구분할 필요가 없기 때문에 DTYPE도 안만들어진다.   쿼리도 심플하게 들어가서 좋은것 같지만 데이터를 찾을때 큰 문제 발생.   ex) ITEM_ID만 알 경우, 모든 테이블에서 찾아서(select시 union 사용) 매우 비효율적이다.            이 전략은 DB 설계자와 ORM 전문가 둘 다 추천 X     장점                서브 타입을 명확하게 구분해서 처리할 때 효과적         not null 제약조건 사용 가능                 단점                여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)         자식 테이블을 통합해서 쿼리하기 어려움                          테이블이 묶이는게 없기 때문에 전부 다 조회해야함     새로운 타입을 추가할때 변경할게 굉장히 많아진다.     이 전략을 사용할 경우 먼 미래에 언젠가는 큰 후회를 한다.      언제 뭘 사용할까?           보통 조인 전략을 선택, 엄청 단순하고 확장할 일도 없을 경우 단일테이블 전략 선택      2. Mapped Superclass - 매핑 정보 상속           공통 매핑 정보가 필요할 때 사용(id, name)      ex) 객체 입장에서 id, name 필드가 계속 나올 때, 클래스 만들때 마다 id, name 필드를 생성하기 귀찮으니까 부모 클래스에 두고 속성만 상속해서 사용하고 싶은경우   DB는 완전히 다른데, 객체 입장에서 속성만 상속받아서 쓰고싶은 경우   즉, 귀찮아서 귀찮음을 줄일 때 사용      ex) 모든 테이블에서 누가, 언제 등록, 수정했는지에 대한 정보가 항상 있어야 할 경우   /* private String createdBy; private LocalDateTime createdDate; private String lastModifiedBy; private LocalDateTime lastModifiedDate; MappedSuperclass를 사용하지 않으면 이 코드를 모든 테이블에 작성해야한다.*/ //MappedSuperclass를 사용하면 상속받아서 사용할 수 있다. @MappedSuperclass //매핑 정보만 받는 부모 클래스 public abstract class BaseEntity {      //@Column(name = \"INSERT_MEMBER\") 컬럼 이름 변경시 사용     private String createdBy;     private LocalDateTime createdDate;     private String lastModifiedBy;     private LocalDateTime lastModifiedDate;      //getter setter 생략 }   @Entity public class Member extends BaseEntity{      @Id @GeneratedValue     @Column(name = \"MEMEBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username; }   //JpaMain의 try 내부 코드 try {              Member member = new Member();             member.setUsername(\"user1\");             member.setCreatedBy(\"kim\");             member.setCreatedDate(LocalDateTime.now());              em.persist(member);              tx.commit();      }            상속관계 매핑 X     엔티티 X, 테이블과 매핑 X(속성만 내려주는애)     부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공     조회, 검색 불가 (em.find(BaseEntity.class) 불가능)     직접 생성해서 사용할 일이 없으므로 추상 클래스 권장              테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할     주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용     참고 : @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능 (JPA에서 extends를 사용할때)              실무에서 BaseEntity를 만들어서 활용하면 편리하다.      프록시와 연관관계 관리   1. 프록시           프록시 사용 이유?                Memeber 테이블과 Team 테이블이 연관관계를 가질 때, 프록시를 사용하지 않아서 지연로딩을 사용할 수 없다면 Member를 JPA를 통해 조회할 때 연관관계인 Team까지 함께 조회된다.   여기서 문제가 되는 이유는 Member만 필요한데 연관관계인 Team까지 다 불러와서 메모리에 올라와있기 때문에 리소스 낭비가 생긴다.   만약 프록시를 사용하여 지연로딩이 가능해지면 Team을 지연로딩으로 처리하고(Team은 불러오지 않게 됨) Member만 불러올 수 있게된다.   이 과정에서 Team을 불러오지 않기 때문에 리소스의 낭비를 조금이라도 줄일 수 있다. 이러한 지연로딩이라는 기술을 가능케 하는게 프록시이다.                          프록시의 기초                em.find() vs em.getReference();                        em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회 (쿼리가 나감)             em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회 (쿼리가 안나감)                                                 프록시 특징 1                실제 클래스를 상속 받아서 만들어짐         실제 클래스와 겉 모양이 같다.         사용하는 입장에서는 진짜 객체인지 프롤시 객체인지 구분하지 않고 사용하면 됨 (이론상)         프록시 객체는 실제 객체의 참조(target)를 보관         프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출                              프록시 객체의 초기화         try{     // Member findMember = em.find(Member.class, member.getId()); //쿼리 나감     Member findMember = em.getReference(Member.class, member.getId()); //getReference를 호출하는 시점에는 쿼리 안나감     System.out.println(\"findMember = \" + findMember.getClass()); // 출력결과 : hellojpa.Member$HibernateProxy$odcVHpjy  (Hibernate가 강제로 만든 가짜 클래스(프록시))     System.out.println(\"findMember.id = \" + findMember.getId()); // 아직 쿼리 안나감, Reference를 찾을때 getId를 넣었기 때문에 즉, 이미 값이 있기 때문에 쿼리가 안나감     System.out.println(\"findMember.username = \" + findMember.getUsername()); // 쿼리 나감, findMember에 값을 채워야 하기 때문에 쿼리가 나간다.     System.out.println(\"findMember.username = \" + findMember.getUsername()); // 한번 더 호출 시, 바로 위에서 이미 초기화 되어있기 때문에 값만 출력됨 }           프록시 특징 2                프록시 객체는 처음 사용할 때 한 번만 초기화         프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능         프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함(==비교 실패, 대신 instance of 사용)         영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환         영속성 컨텍스트의 도움을 받을 수 없는 준 영속 상태일 때, 프록시를 초기화하면 문제 발생 (Hibernate는 org.hibernate.LazyInitializationException 예외를 터트림)                  Member findMember = em.getReference(Member.class, member.getId()); System.out.println(\"before findMember = \" + findMember.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$odcVHpjy System.out.println(\"findMember.username = \" + findMember.getUsername()); System.out.println(\"after findMember = \" + findMember.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$odcVHpjy // 교체되는것이 아니라 프록시는 유지가 되고 내부의 타겟에만 값이 채워지는것이다. //========================================================================================================================== Member member1 = new Member(); member1.setUsername(\"member1\"); em.persist(member1); Member member2 = new Member(); member1.setUsername(\"member2\"); em.persist(member2);  Member m1 = em.find(Member.class, member1.getId()); Member m2 = em.getReference(Member.class, member2.getId());  System.out.println(\"m1 == m2: \" + (m1.getClass() == m2.getClass())); //false가 나온다. logic(m1,m2); //비즈니스 로직에서는 메소드로 파라미터만 넘어오기 때문에 프록시가 넘어오는지 실제로 넘어오는지 모르기 때문에 == 비교를 하면 안된다. //ex private static void logic(Member m1, Member m2){     //System.out.println(\"m1 == m2: \" + (m1.getClass() == m2.getClass()));     System.out.println(\"m1 == m2: \" + (m1 instanceof Member)); //true     System.out.println(\"m1 == m2: \" + (m2 instanceof Member)); //true } //========================================================================================================================== Member m1 = em.find(Member.class, member1.getId()); System.out.println(\"m1 = \" + m1.getClass()); //출력결과 : hellojpa.Member  Member reference = em.getReference(Member.class, member1.getId()); System.out.println(\"reference = \" + reference.getClass()); //출력결과 : hellojpa.Member /* Reference를 했는데 프록시로 안나오는 이유 1. member를 이미 영속성 컨텍스트에 올려놨는데 굳이 프록시로 가져와봐야 이점이 없다. 2. JPA에서는 동일한 트랜잭션 내에서 엔티티의 동일성을 보장하기 때문에 타입 비교를 하면 true로 나온다. */ //========================================================================================================================== Member m1 = em.getReference(Member.class, member1.getId()); System.out.println(\"m1 = \" + m1.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB  Member reference = em.getReference(Member.class, member1.getId()); System.out.println(\"reference = \" + reference.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB  System.out.println(\"m1 == reference: \" + (m1 == reference)); // true /* 같은 프록시가 반환된 이유? 동일한 트랜잭션 내에서 엔티티의 동일성 보장 */ //========================================================================================================================== Member refMember = em.getReference(Member.class, member1.getId()); System.out.println(\"refMember = \" + refMember.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB  Member findMember = em.find(Member.class, member1.getId()); //실제 조회를 하기 때문에 쿼리 나감 System.out.println(\"findMember = \" + findMember.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB  System.out.println(\"refMember == findMember: \" + (refMember == findMember)); // true /* find에서도 프록시가 반환된 이유? 동일한 트랜잭션 내에서 엔티티의 동일성 보장 */ //=========================================================================================================================== Member refMember = em.getReference(Member.class, member1.getId()); System.out.println(\"refMember = \" + refMember.getClass()); //프록시  //em.close //영속성 컨텍스트 종료 em.detach(refMember); //영속성 컨텍스트 관리 안함 //em.clear //영속성 컨텍스트가 초기화 되므로 똑같이 에러가 발생  refMember.getUsername(); //위의 3가지 모두 org.hibernate.LazyInitializationException 에러 발생 System.out.println(\"refMember = \" + refMember.getUsername());           프록시든 아니든 개발에 문제가 없게 개발해야 된다.     실무에서 org.hibernate.LazyInitializationException이 많이 발생하므로 주의하자.              프록시 확인                프록시 인스턴스의 초기화 여부 확인                        PersistenceUnitUtil.isLoaded(Object entity)                             프록시 클래스 확인 방법                        entity.getClass().getName() 출력(..javasist.. or HibernateProxy…)                             프록시 강제 초기화                        org.hibernate.Hibernate.initialize(entity);                             참고 : JPA 표준은 강제 초기화 없음   강제 호출 : member.getName();                  Member refMember = em.getReference(Member.class, member1.getId()); System.out.println(\"refMember = \" + refMember.getClass()); //프록시  System.out.println(\"isLoaded = \" + emf.getPersistenceUnitUtil().isLoaded(refMember)); //출력 결과 : false  refMember.getUsername(); //강제 초기화 System.out.println(\"isLoaded = \" + emf.getPersistenceUnitUtil().isLoaded(refMember)); //출력 결과 : true  Hibernate.initialize(refMember); //강제 초기화   2. 즉시 로딩과 지연 로딩           지연로딩 LAZY를 사용해서 프록시로 조회          @Entity public class Member {      @Id @GeneratedValue     @Column(name = \"MEMEBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username;      @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name = \"TEAM_ID\")     private Team team; }  JpaMain의 try 내부 try{     Member m = em.find(Member.class, member1.getId());//Member만 가져옴     System.out.println(\"m = \" + m.getTeam().getClass()); // 프록시로 나옴     m.getTeam().getName(); //이때 TEAM에 대한 쿼리가 나옴, 초기화 }           Member와 Team을 자주 함께 사용한다면?                LAZY를 사용하면 Member 따로 Team 따로 쿼리가 각각 나가서 성능상 손해를 본다.         즉시 로딩 EAGER를 사용해서 함께 조회                      @Entity public class Member {      @Id @GeneratedValue     @Column(name = \"MEMEBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username;      @ManyToOne(fetch = FetchType.EAGER)     @JoinColumn(name = \"TEAM_ID\")     private Team team; }  JpaMain의 try 내부 try{     Member m = em.find(Member.class, member1.getId()); //조회를 할대 join을 사용해서 한방에 쿼리를 날림     System.out.println(\"m = \" + m.getTeam().getClass()); // 프록시가 아닌 hellojpa.Team가 나옴     System.out.println(\"teamName = \" + m.getTeam().getName()); //teamA }           프록시와 즉시로딩 주의                가급적 지연 로딩만 사용(실무에서는 즉시 로딩 사용하면 안됨)         즉시 로딩을 적용하면 예상하지 못한 SQL이 발생                        테이블이 여러개면 join도 여러개 나와서 성능이 저하되고 쿼리도 엄청 길게 나온다.                             즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.                        JPQL로 Member 조회할 경우, Member에 Team이 EAGER로 설정되어 있으면 Team도 같이 가져온다             최초 쿼리가 1개 나가고 추가로 N개의 쿼리가 나간다                             @ManyToOne, @OneToOne은 기본이 즉시 로딩 -&gt; LAZY로 설정하자         @OneToMany, @ManyToMany는 기본이 지연 로딩                          실무에서는?                모든 연관관계에 지연 로딩으로 설정         실무에서 즉시 로딩 사용하지 말것!         JPQL fetch join 사용 (데이터가 채워지기 때문에 루프를 돌려서 값을 출력해서 추가적인 쿼리가 안나간다.)         엔티티 그래프 기능 사용 (추후에 배울 내용)         배치사이즈 활용 (추후에 배울 내용)                  3. 영속성 전이(CASCADE)와 고아 객체           영속성 전이 : CASCADE                특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때         예 : 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장                          주의                영속성 전이는 연관관계 매핑하는 것과 아무 관련이 없다.         엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐이다.                          CASCADE의 종류                ALL : 모두 적용 (라이프사이클 전부 맞출 때)         PERSIST : 영속 (저장할때만 라이프사이클 맞출 때)         REMOVE : 삭제         MERGE : 병합         REFRESH : REFRESH         DETACH : DETACH                          쓰면 안되는 경우                소유자가 둘 이상일 때         완전히 종속적이지 않을 때         라이프사이클이 다를 때                  @Entity public class Parent {      @Id     @GeneratedValue     private Long id;      private String name;      @OneToMany(mappedBy = \"parent\", cascade = CascadeType.ALL, orphanRemoval = true)     private List&lt;Child&gt; childList = new ArrayList&lt;&gt;();      public void addChild(Child child){         childList.add(child);         child.setParent(this);     } }  @Entity public class Child {      @Id     @GeneratedValue     private Long id;      private String name;      @ManyToOne     @JoinColumn(name = \"parent_id\")     private Parent parent; }  JpaMain의 try 내부 try{     Child child1 = new Child();     Child child2 = new Child();      Parent parent = new Parent();     parent.addChild(child1);     parent.addChild(child2);      em.persist(parent); //Parent의 CascadeType.All 때문에 child도 같이 persist된다. }           고아객체                고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제         orphanRemoval = true (조심히 사용할것)         Parent parent1 = em.find(Parent.class, id);   parent1.getChildren().remove(0);   자식 엔티티를 컬렉션에서 제거         DELETE FROM CHILD WHERE ID=? 쿼리가 나간다                          주의                참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능         참조하는 곳이 하나일 때 사용해야함         특정 엔티티가 개인 소유할 때 사용         @OneToOne, @OneToMany만 가능         참고 : 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께 제거된다. 이것은 CascadeType.REMOVE처럼 동작한다.                          영속성 전이 + 고아객체, 생명주기                CascadeType.All + orphanRemoval=true         스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거         두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음         도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용                  etc. 에러   Cannot drop \"ITEM\" because \"FKF1UERPNMN49VL1SPBBPLGXAUN, FKABGE9EQALSPCEJIJ53RAT7PJH\" depends on it; SQL statement: drop table item [90107-200] 테이블을 드랍할 때 이런 오류가 발생 할 경우 pom.xml에서 hibernate 버전을 5.4.13.Final로 바꾸기 H2 데이터베이스 버전을 1.4.200로 바꾸기(재설치)   Quiz   문제 1. 조인 전략, 단일 테이블 전략보다 구현 클래스마다 테이블 전략을 사용하는게 더 편하고 좋다?    정답 확인             X        구현 클래스마다 테이블 전략은 DB 설계자와 ORM 전문가 둘 다 추천하지 않는 방법이다. 여러 테이블을 함께 조회할 경우 UNION을 사용하기 때문에 성능이 느리다.            문제 2. @MappedSuperclass 사용한 BaseEntity는 DB테이블로 만들어진다?    정답 확인             X        부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공해주는 역할만 하기 때문에 테이블이 만들어지지 않는다.            문제 3. 아래 코드의 출력결과는?   1. em.find(Member.class, m.getId())   em.flush(); em.clear();   2. em.getReference(Member.class, m.getId())   System.out.println(“1==2 : “ + 1==2);    정답 확인             false        em.find() 이후 member 객체는 영속성 컨텍스트로 관리된다. 그리고 한 트랙잭션안에서 이 객체의 동일함을 보장한다.   그러나 clear는 영속성으로 관리하던 모든 객체를 다 삭제하게 된다.   그리고 난 뒤 다시 DB의 정보를 기반으로 member 를 생성하게 되면 이전에 관리하던 member와는 관계 없는 객체가 된다.           ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-3/",
        "teaser": null
      },{
        "title": "[JPA] 자바 ORM 표준 JPA 프로그래밍 - 기본편 (값 타입)",
        "excerpt":"    값 타입   1. 기본값 타입           JPA의 데이터 타입 분류                엔티티 타입                        @Entity로 정의하는 객체             데이터가 변해도 식별자로 지속해서 추적 가능             예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능                             값 타입                        int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체             식별자가 없고 값만 있으므로 변경시 추적 불가             예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체                                              값 타입 분류                기본값 타입                        자바 기본 타입(int, double)             래퍼 클래스(Integer, Long)             String                             임베디드 타입(embedded type, 복합 값 타입)         컬렉션 값 타입(collection value type)                          기본값 타입                예 : String name, int age         생명 주기를 엔티티에 의존                        예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제                             값 타입은 공유하면 안됨                        예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨                                     참고 : 자바의 기본 타입은 절대 공유되지 않는다.                int, double 같은 기본 타입(primitive type)은 절대 공유되지 않음         기본 타입은 항상 값을 복사함         Integer 같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경 자체가 불가능                  public static void main(String[] args){     int a = 10;     int b = a;      b = 20;     //기본 타입 공유 테스트     System.out.println(\"a = \" + a); // a = 10     System.out.println(\"b = \" + b); // b = 20 }   2. 임베디드 타입           임베디드 타입(복합 값 타입)                새로운 값 타입을 직접 정의할 수 있음         JPA는 임베디드 타입(embedded type)이라 함         주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함         int, String과 같은 값 타입 (엔티티 아님)                          예제                회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다. =&gt; 너무 번잡하다.            회원 엔티티는 이름, 근무 기간, 집 주소를 가진다. =&gt; 이런식으로 묶어낼 수 있는게 임베디드 타입이다.             쉽게 말해서 Period, Address 클래스를 새로 만들었다고 생각하면 된다.                          임베디드 타입 사용법                @Embeddable : 값 타입을 정의하는 곳에 표시         @Embedded : 값 타입을 사용하는 곳에 표시 (둘 중 하나만 넣고 생략 가능)         기본 생성자 필수                          임베디드 타입의 장점                재사용         높은 응집도         Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음         임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함                          임베디드 타입과 테이블 매핑                DB 입장에서는 값타입을 쓰든 안 쓰든, 임베디드 타입을 쓰든 안 쓰든 회원 테이블은 똑같다. 매핑만 해주면 된다.            임베디드 타입은 엔티티의 값일 뿐이다.         임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.         객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능         잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음                  @Embeddable public class Period {      private LocalDateTime startDate;     private LocalDateTime endDate; }  @Embeddable public class Address {      private String city;     private String street;     private String zipcode;      public Address() {     }      public Address(String city, String street, String zipcode) {         this.city = city;         this.street = street;         this.zipcode = zipcode;     } }  @Entity public class Member {     @Id     @GeneratedValue     @Column(name = \"MEMBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username;      //기간 Period     @Embedded     private Period workPeriod;      //주소     @Embedded     private Address homeAddress }  JpaMain의 try 내부 try{     Member member = new Member();     member.setUsername(\"hello\");     member.setHomeAddress(new Address(\"city\",\"street\",\"10000\"));     member.setWorkPeriod(new Period());      em.persist(member); }           임베디드 타입과 연관관계         @Embeddable public class Address {      private String city;     private String street;     @Column(name = \"ZIPCODE\") //이름 설정도 가능     private String zipcode;      private Member member; //임베디드 안에 엔티티도 들어올 수 있다.      public Address() {     }      public Address(String city, String street, String zipcode) {         this.city = city;         this.street = street;         this.zipcode = zipcode;     } }           @AttributeOverride : 속성 재정의                한 엔티티에서 같은 값 타입을 사용하면?         컬럼 명이 중복됨         @AttributeOverrides, @AttributeOverride 를 사용해서 컬럼 명 속성을 재정의                  @Entity public class Member {     @Id     @GeneratedValue     @Column(name = \"MEMBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username;      //기간 Period     @Embedded     private Period workPeriod;      //주소     @Embedded     private Address homeAddress;      //주소  //   @Embedded  //   private Address homeAddress; // 중복 때문에 에러가 난다.      @Embedded     @AttributeOverrides({             @AttributeOverride(name=\"city\",                     column=@Column(name = \"WORK_CITY\")),             @AttributeOverride(name=\"street\",                     column=@Column(name = \"WORK_STREET\")),             @AttributeOverride(name=\"zipcode\",                     column=@Column(name = \"WORK_ZIPCODE\"))     })     private Address workaddress; }           임베디드 타입과 null                임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null                  @MappedSuperclass vs @Embeddable           @MappedSuperclass                Entity로 정의하는 것이고 여러 Entity에 공통적으로 적용해야 할 때 사용할 수 있다.         상속이다.         상속은 다중상속도 안되고 객체지향 설계상 유연성이 떨어진다.                 @Embeddable + @Embedded                Value 타입으로 정의하는 것이고 비슷한 속성을 가지는 애트리뷰트를 하나의 값으로 만들어 재사용성을 높일수 있는 방법이다.         위임이다.         JPQL을 사용할 때에는 엔티티에서 embedded type까지 쿼리하기 위해서 type을 명시해야 하는 불편함이 존재한다.                        예) 위임 사용: select u from User u where u.timestamped.createdDate &gt; ?             예) 상속 사용 : select u from User u where u.createdDate &gt; ?                                     대부분의 상황에서는 embedded type을 사용하는 것이 좋겠지만 단순한 데이터를 다룰 때에는 단순한 방식(@MappedSuperclass)을 선택하여 처리하는 것이 더 나은 경우도 있다.     @MappedSuperclass를 사용하는 경우                수정시간, 등록시간, 수정자, 등록자 처럼 대부분의 엔티티들이 공통으로 사용하는 속성들을 다룰때 사용한다.                  참고1   참고2   3. 값 타입과 불변 객체           값 타입은 복잡한 객체 세상은 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.              값 타입 공유 참조                임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함         부작용(side effect) 발생                             회원 1과 회원 2가 같은 주소를 볼 경우, city를 NewCity로 바꾸면 회원1과 회원2도 같이 NewCity로 바뀐다     의도적으로 쓰려면 값 타입을 쓰면 안되고 엔티티를 써야한다.      try{       Address address = new Address(\"city\", \"street\", \"10000\");        Member member = new Member();       member.setUsername(\"member1\");       member.setAddress(address);       em.persist(member);        Member member2 = new Member();       member2.setUsername(\"member2\");       member2.setAddress(address);       em.persist(member2);        member.getAddress().setCity(\"newCity\"); //member만 바뀌는게 아니라 member2까지 같이 바뀐다. (이런 버그는 잡아내기 어렵다.) }           값 타입 복사                값 타입의 실제 인스턴스인 값을 공유하는 것은 위험         대신 값(인스턴스)를 복사해서 사용                     try {              Address address = new Address(\"city\", \"street\", \"10000\");              Member member = new Member();             member.setUsername(\"member1\");             member.setAddress(address);             em.persist(member);              Address copyAddress = new Address(address.getCity(), address.getStreet(), address.getZipcode()); //copy             Member member2 = new Member();             member2.setUsername(\"member2\");             member2.setAddress(copyAddress);             em.persist(member2);              member.getAddress().setCity(\"newCity\"); //member2는 copyAddress로 저장했기 때문에 member2는 안바뀌고 member만 바뀐다. }           객체 타입의 한계                항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.         문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다.         자바 기본 타입에 값을 대입하면 값을 복사한다.         객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.                        누군가 실수로 복사하지 않고 직접 대입하는 경우는 컴파일러 레벨에서 막을 방법이 없다.                             객체의 공유 참조는 피할 수 없다.                  기본타입(primitive type) int a = 10; int b = a; //기본 타입은 값을 복사 b = 4; //a 값은 10으로 유지  객체 타입 Address a = new Address(\"Old\"); Address b = a; //객체 타입은 참조를 전달 b.setCity(\"New\"); //a와 b는 같은 인스턴스를 가르킨다. 따라서 a, b 둘 다 바뀐다.           불변 객체                객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단         값 타입은 불변 객체(immutable object)로 설계해야함         불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체         생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨 (setter를 private로 만들어도 됨)         참고 : Integer, String은 자바가 제공하는 대표적인 불변 객체                          불변이라는 작은 제약으로 큰 재앙을 막을 수 있다.              값을 바꾸고 싶다면?      Address newAddress = new Address(\"NewCity\", address.getStreet(), address.getZipcode()); member.setAddress(newAddress); //위 코드처럼 완전히 새로 만들어서 바꿔야한다.           값 타입은 side effect를 대비해서 불변으로 만드는걸 추천한다.      4. 값 타입의 비교           값 타입 : 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야함     동일성(identity) 비교 : 인스턴스의 참조 값을 비교, == 사용     동등성(equivalence) 비교 : 인스턴스의 값을 비교, equals() 사용     값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야함     값 타입의 equals() 메소드를 적절하게 재정의(주로 모든 필드 사용)      int a = 10; int b = 10; //a == b true Address address1 = new Address(\"city\", \"street\", \"10000\"); Address address2 = new Address(\"city\", \"street\", \"10000\"); //address1 == address2 false //address1.equals(address2) false (equals 오버라이드 전) //address1.equals(address2) true (equals 오버라이드 후) //Java에서는 ==비교시 참조값을 비교하기 때문에 false가 나온다.   5. 값 타입 컬렉션              값 타입을 하나 이상 저장할 때 사용     @ElementCollection, @CollectionTable 사용     데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.     컬렉션을 저장하기 위한 별도의 테이블이 필요함              값 타입 컬렉션 사용                값 타입 저장         값 타입 조회                        값 타입 컬렉션도 지연 로딩 전략 사용                             값 타입 수정         참고 : 값 타입 컬렉션은 영속성 전이(Cascade) + 고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.                        값 타입 컬렉션도 값 타입이기 때문에 라이프사이클이 member에 의존한다                                      Member      @ElementCollection     @CollectionTable(name = \"FAVORITE_FOOD\", joinColumns =     @JoinColumn(name = \"MEMBER_ID\"))     @Column(name = \"FOOD_NAME\")     private Set&lt;String&gt; favoriteFoods = new HashSet&lt;&gt;();      @ElementCollection     @CollectionTable(name = \"ADDRESS\", joinColumns =     @JoinColumn(name = \"MEMBER_ID\"))     private List&lt;Address&gt; addressHistory = new ArrayList&lt;&gt;();  JpaMain의 try 내부  try {              // 저장 예제             Member member = new Member();             member.setUsername(\"member1\");             member.setHomeAddress(new Address(\"homeCity\", \"street\", \"10000\"));              member.getFavoriteFoods().add(\"치킨\");             member.getFavoriteFoods().add(\"족발\");             member.getFavoriteFoods().add(\"피자\");              member.getAddressHistory().add(new Address(\"old1\", \"street\", \"10000\"));             member.getAddressHistory().add(new Address(\"old2\", \"street\", \"10000\"));              em.persist(member);              // 조회 예제             em.flush();             em.clear(); //깔끔한 상태에서 조회하기 위해 clear 해준다              Member findMember = em.find(Member.class, member.getId()); //쿼리를 보면 Member만 가져온다. 즉, 컬렉션은 지연로딩 사용              List&lt;Address&gt; addressHistory = findMember.getAddressHistory();             for (Address address : addressHistory) {                 System.out.println(\"address = \" + address.getCity()); //지연로딩이기 때문에 이때 쿼리가 나감             }              //수정 예제             //homeCity -&gt; newCity //            findMember.getHomeAddress().setCity(\"newCity\"); //immutable 해야하기 때문에 이런식으로 변경하면 절대 안된다.              Address a = findMember.getHomeAddress();             findMember.setHomeAddress(new Address(\"newCity\", a.getStreet(), a.getZipcode())); //이런식으로 완전히 교체를 해줘야한다.              //치킨 -&gt; 한식             //단순 String이기 때문에 remove로 지우고 add로 추가해야한다.             //String은 업데이트가 없다.             findMember.getFavoriteFoods().remove(\"치킨\");             findMember.getFavoriteFoods().add(\"한식\");              //old1 -&gt; newCity1             findMember.getAddressHistory().remove(new Address(\"old1\", \"street\", \"10000\"));             //remove의 기본 동작은 equals로 대상을 찾는다. 즉, equals, hashcode를 안넣으면 지워지지 않고 값이 계속 들어가게 된다.             findMember.getAddressHistory().add(new Address(\"newCity1\", \"street\", \"10000\"));             // 출력 결과 : MEMBER_ID를 기준으로 ADDRESS 테이블의 모든 컬럼이 delete가 되고 기존의 테이터인 old2와 새로운 데이터인 newCity1이 insert가 된다.             // 결론 : 쓰면안됨 }           값 타입 컬렉션의 제약사항                값 타입은 엔티티와 다르게 식별자 개념이 없다.         값은 변경하면 추적이 어렵다.         값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. (실무에서는 사용하면 안된다.)         값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야함 : null 입력 X, 중복 저장 X                          값 타입 컬렉션 대안                실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려 (실무에서 많이 쓰임)         일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용         영속성 전이(Cascade) + 고아 객체 제거를 사용해서 값 타입 컬렉션 처럼 사용         EX) AddressEntity                          값타입 컬렉션은 언제쓰이나?                엄청 단순할때 사용 (업데이트 필요 없을 때, 추적할 필요 없을 때)                  AddressEntity      @Id @GeneratedValue     private Long id;      public AddressEntity() {     }      public AddressEntity(Address address) {         this.address = address;     }      private Address address;      public AddressEntity(String city, String street, String zipcode) {         this.address = new Address(city, street, zipcode);     }  Member      @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)     @JoinColumn(name = \"MEMBER_ID\")     private List&lt;AddressEntity&gt; addressHistory = new ArrayList&lt;&gt;();            정리                엔티티 타입의 특징                        식별자 O             생명 주기 관리             공유                             값 타입 특징                        식별자 X             생명 주기를 엔티티에 의존             공유하지 않는 것이 안전(복사해서 사용)             불변 객체로 만드는 것이 안전                                              값 타입은 정말 값 타입이라 판단 될 때만 사용     엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨     식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것은 값 타입이 아닌 엔티티      Quiz   문제 1. 다음 코드의 상황별 출력 결과를 쓰시오.   Address address1 = new Address(\"city\", \"street\", \"10000\"); Address address2 = new Address(\"city\", \"street\", \"10000\");  상황 1. == 비교 System.out.println(address1 == address2)  상황 2. equals 비교, Address에 equals() 메소드 오버라이드 안함 System.out.println(address1.equals(address2))  상황 3. equals 비교, Address에 equals() 메소드 오버라이드 함 System.out.println(address1.equals(address2))    정답 확인             1. false             2. false             3. true                    == 비교는 참조값을 비교하기 때문에 false가 나온다.         equals()의 기본은 == 비교이기 때문에 false가 나온다.         equals() 메소드를 재정의할 경우 내부 값이 같은지 판별하기 때문에 true가 나온다.                        문제 2. 비슷한 기능을 가진 @MappedSuperclass와 @Embeddable의 차이점을 생각해보자.    정답 확인              @MappedSuperclass는 상속   @Embeddable은 위임         자세한 설명            ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-4/",
        "teaser": null
      },{
        "title": "[JPA] 자바 ORM 표준 JPA 프로그래밍 - 기본편 (객체지향 쿼리 언어1 - 기본 문법)",
        "excerpt":"    객체지향 쿼리 언어 - 기본 문법   0. 객체지향 쿼리 언어 소개           JPA는 다양한 쿼리 방법을 지원한다.                JPQL : 실무에서는 대부분 JPQL로 해결 가능         JPA Criteria         QueryDSL         네이티브 SQL         JDBC API 직접 사용, MyBatis, SpringJdbcTemplate                          JPQL 소개                가장 단순한 조회 방법                        EntityManager.find()             객체 그래프 탐색(a.getB().getC())                             ex) 나이가 18살 이상인 회원을 모두 검색하고 싶다면?                        단순히 하나를 찍어서 가져올수 있는것이 아니다.                                              JPQL                JPA를 사용하면 엔티티 객체를 중심으로 개발         문제는 검색 쿼리         검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색         모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능         애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요         위에 언급된 문제들을 해결하기 위해 JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공         SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원         JPQL은 엔티티 객체를 대상으로 쿼리         SQL은 데이터베이스 테이블을 대상으로 쿼리         테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리         SQL을 추상화해서 특정 데이터베이스 SQL에 의존X         JPQL을 한마디로 정의하면 객체지향 SQL         JPQL은 단순 문자이기 때문에 동적 쿼리를 만들기 매우 어렵다.                  //간단한 JPQL의 예 List&lt;Member&gt; result = em.createQuery(                     \"select m From Member m where m.age &gt; 18\",                     Member.class ).getResultList();  //실행된 SQL select     m.id as id,     m.age as age,     m.USERNAME as USERNAME,     m.TEAM_ID as TEAM_ID from     Member m where     m.age&gt;18           Criteria 소개                문자가 아닌 자바코드로 JPQL을 작성할 수 있음         쿼리문에서 오타를 내도 컴파일 시점에서 잡아준다         JPQL 빌더 역할         JPA 공식 기능         단점 : 너무 복잡하고 실용성이 없다.                        유지보수가 어려움             sql 같지가 않음             디버깅을 못함                             Criteria 대신에 QueryDSL 사용 권장                  //Criteria 사용 준비 CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class); //루트 클래스 (조회를 시작할 클래스) Root&lt;Member&gt; m = query.from(Member.class); //쿼리 생성 CriteriaQuery&lt;Member&gt; cq = query.select(m).where(cb.equal(m.get(\"username\"), \"kim\")); List&lt;Member&gt; resultList = em.createQuery(cq).getResultList();           QueryDSL 소개                문자가 아닌 자바코드로 JPQL을 작성할 수 있음         JPQL 빌더 역할         컴파일 시점에 문법 오류를 찾을 수 있음         동적쿼리 작성 편리함         단순하고 쉬움         실무 사용 권장                  //JPQL //select m from Member m where m.age &gt; 18 JPAFactoryQuery query = new JPAQueryFactory(em); QMember m = QMember.member; List&lt;Member&gt; list =         query.selectFrom(m)                 .where(m.age.gt(18))                 .orderBy(m.name.desc())                 .fetch();           네이티브 SQL 소개                JPA가 제공하는 SQL을 직접 사용하는 기능         JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능         예) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트                  em.createNativeQuery(\"select MEMBER_ID, city, street, zipcode, USERNAME from MEMBER\").getResultList();           JDBC 직접 사용, SpringJdbcTemplate 등                JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, MyBatis 등을 함께 사용 가능         단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요         예) JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시                  1. JPQL(Java Persistence Query Language)   기본 문법과 기능           JPQL 소개                JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다.         JPQL은 SQL을 추상화해서 특정데이터베이스 SQL에 의존하지 않는다.         JPQL은 결국 SQL로 변환된다.                          JPQL 문법                select m from Member as m where m.age &gt; 18 (Member는 테이블이 아닌 엔티티)         엔티티와 속성은 대소문자 구문 O (Member, age)         JPQL 키워드는 대소문자 구분 X (SELECET, FROM, where)         엔티티 이름 사용, 테이블 이름이 아님(Member)         별칭은 필수(m) (as는 생략 가능)                  select_문 :: =   select_절   from_절   [where_절]   [groupby_절]   [having_절]   [orderby_절] update_문 :: = update_절 [where_절] delete_문 :: = delete_절 [where_절]           집합과 정렬                GROUP BY, HAVING 다 똑같이 사용하면 된다.                  select   COUNT(m), //회원수   SUM(m.age), //나이 합   AVG(m.age), //평균 나이   MAX(m.age), //최대 나이   MIN(m.age) //최소 나이 from Member m           TypeQuery, Query                TypeQuery : 반환 타입이 명확할 때 사용         Query : 반환 타입이 명확하지 않을 때 사용                  TypedQuery&lt;Member&gt; query =     em.createQuery(\"SELECT m FROM Member m\", Member.class);  Query query =     em.createQuery(\"SELECT m.username, m.age from Member m\"); //username은 String, age는 int라서 타입을 명기할 수 없다.           결과 조회 API                query.getResultList() : 결과가 하나 이상일 때, 리스트 반환                        결과가 없으면 빈 리스트 반환                             query.getStringResult() : 결과가 정확히 하나, 단일 객체 반환                        결과가 없으면 : javax.persistence.NoResultException                                Spring Data JPA에서는 null을 반환                                         둘 이상이면 : javax.persistence.NonUniqueResultException                                              파라미터 바인딩 - 이름 기준, 위치 기준      //이름 기준 SELECT m FROM Member m where m.username=:username query.setParameter(\"username\", usernameParam);  //위치 기준, 순서가 밀릴 가능성이 있으므로 쓰지 말자. SELECT m FROM Member m where m.username=?1 query.setParameter(1, usernameParam);  //-----------------------------------------------  TypedQuery&lt;Member&gt; query = em.createQuery(\"SELECT m FROM Member m where m.username = :username\", Member.class); query.setParameter(\"username\", \"member1\"); Member singleResult = query.getSingleResult();  위에처럼 쓰는것 보다 아래처럼 쓰는게 편하고 좋다.  Member result = em.createQuery(\"select m from Member m where m.username = :username\", Member.class)       .setParameter(\"username\", \"member\")       .getSingleResult(); System.out.println(\"result = \" + result.getUsername());  결과 : result = member1   프로젝션(SELECT)           프로젝션                SELECT 절에 조회할 대상을 지정하는것         프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 데이터 타입)                        관계형 데이터베이스는 select 에 스칼라 타입만 선택할 수 있다.                             SELECT m FROM Member m -&gt; 엔티티 프로젝션         SELECT m.team FROM Member m -&gt; 엔티티 프로젝션                        Member에 연관된 team을 가져옴             join이 사용된다.             join이 사용되면 성능에 어떠한 영향을 미치는지 알 수 없기때문에 최대한 sql문과 비슷하게 써야한다. (join을 최대한 명시)             ex) (SELECT t FROM Member m join m.team t, Team.class)                             SELECT m.address FROM Member m -&gt; 임베디드 타입 프로젝션                        어디 소속인지 확실하게 적어야함 (m.address)                             SELECT m.username, m.age FROM Member m -&gt; 스칼라 타입 프로젝션         DISTINCT로 중복 제거                  Member member = new Member(); member.setUsername(\"member1\"); member.setAge(10); em.persist(member);  em.flush(); em.clear(); //영속성 컨텍스트 비우기  List&lt;Member&gt; result = em.createQuery(\"select m from Member m\", Member.class)           .getResultList(); //엔티티 프로젝션을 하면 select 절이 몇개가 나오든 영속성 컨텍스트에서 관리된다.  Member findMember = result.get(0); findMember.setAge(20); //바뀌면 영속성 컨텍스트에서 관리 되는것이고 안바뀌면 관리가 안되는것이다.           프로젝션 - 여러 값 조회                SELECT m.username, m.age FROM Member m                                 Query 타입으로 조회                                                     Object[] 타입으로 조회                                                     new 명령어로 조회                                단순 값을 DTO로 바로 조회   SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m                 패키지 명을 포함한 전체 클래스 명 입력                 순서와 타입이 일치하는 생성자 필요                                                                  // 1. List resultList = em.createQuery(\"select m.username, m.age from Member m\")           .getResultList();  Object o = resultList.get(0); Object[] result = (Object[]) o; System.out.println(result[0]); //Member1 System.out.println(result[1]); //10  // 2. List&lt;Object[]&gt; resultList = em.createQuery(\"select m.username, m.age from Member m\")           .getResultList();  Object[] result = resultList.get(0); System.out.println(result[0]); //Member1 System.out.println(result[1]); //10  // 3. 제일 깔끔한 방법, 많이 사용 List&lt;Object[]&gt; resultList = em.createQuery(\"select new jpql.MemberDTO(m.username, m.age) from Member m, MemberDTO.class\")           .getResultList(); //MemberDTO에 생성자 만들어야함, 생성자를 통해 호출됨  MemberDTO memberDTO = result.get(0); System.out.println(memberDTO.getUsername()); System.out.println(memberDTO.getAge());   페이징           페이징 API                JPA는 페이징을 다음 두 API로 추상화         setFirstResult(int startPosition) : 조회 시작 위치         setMaxResult(int maxResult) : 조회할 데이터 수                  //페이징 쿼리 for(int i=0; i&lt;100; i++){   Member member = new Member();   member.setUsername(\"member\"+i);   member.setAge(i);   em.persist(member); }  em.flush(); em.clear();  List&lt;Member&gt; resultList = em.createQuery(\"select m from Member m order by m.age desc\", Member.class)     .setFirstResult(1)     .setMaxResults(10)     .getResultList(); // username, age = member98 ~ 89   페이징 API - MySQL 방언 SELECT     M.ID AS ID,     M.AGE AS AGE,     M.TEAM_ID AS TEAM_ID,     M.NAME AS NAME FROM     MEMBER M ORDER BY     M.NAME DESC LIMIT ?, ?  페이징 API - Oracle 방언 SELECT * FROM     ( SELECT ROW_.*, ROWNUM ROWNUM_     FROM         ( SELECT             M.ID AS ID,             M.AGE AS AGE,             M.TEAM_ID AS TEAM_ID,             M.NAME AS NAME         FROM MEMBER M         ORDER BY M.NAME         ) ROW_     WHERE ROWNUM &lt;= ?     ) WHERE ROWNUM_ &gt; ?   조인           조인                조인은 엔티티 중심으로 동작         내부 조인 : team이 없으면 데이터가 아예 안나옴                        SELECT m FROM Member m[INNER] JOIN m.team t                             외부 조인 : team이 없으면 team은 null로 나오고 Member가 조회됨                        SELECT m FROM Member m LEFT [OUTER] JOIN m.team t                             세타 조인 : 연관관계가 아예 없는것을 조회할때 사용                        SELECT count(m) FROM Member m, Team t WHERE m.username = t.name                                              조인 - ON절                ON절을 활용한 조인(JPA 2.1부터 지원)                                                        조인 대상 필터링                                                                         연관관계가 없는 엔티티 외부 조인(하이버네이트 5.1부터)                                                                  1. 조인 대상 필터링 예) 회원과 팀을 조인하면서, 팀 이름이 A인 팀만 조인 JPQL : SELECT m,t FROM Member m LEFT JOIN m.team t on t.name = 'A'  SQL : SELECT m.*,t.* FROM Member m LEFT JOIN Team t.ON m.TEAM_ID=t.id and t.name='A'  2.연관관계가 없는 엔티티 외부 조인 예) 회원의 이름과 팀의 이름이 같은 대상 외부 조인 JPQL : SELECT m,t FROM Member m LEFT JOIN Team t on m.username = t.name  SQL: SELECT m.*, t.* FROM Member m LEFT JOIN Team t ON m.username = t.name    Quiz   문제 1. 다음 예제들의 성공 여부를 쓰시오.   예제 1. select o.member.team         from Order o  예제 2. select t.members from Team  예제 3. select t.members.username from Team t  예제 4. select m.username from Team t join t.members m    정답 확인             1. 성공             2. 성공             3. 실패             4. 성공              실패 이유 : 컬렉션에서는 더 들어가면 안된다. 명시적 조인을 통해 별칭을 얻어야한다.                   ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-5/",
        "teaser": null
      },{
        "title": "[Daily Contents] 앱? 웹? 어떤 플랫폼으로 개발할까?",
        "excerpt":"    웹? 앱? 고민된다면 우리 서비스의 특징과 우리 팀의 역량을 살펴보자!   플랫폼 고민  - 모바일? 웹? 하나만? 같이? 모바일은 IOS? 안드로이드? 크로스 플랫폼?   웹의 특징   장점      브라우저만 있으면 어디서든 접속 가능            모바일 앱은 배포하기 위해 마켓에 등록해야함       모바일 앱의 사용자는 다운받고 실행받아야하는 불편함           웹 페이지가 업데이트된 후 배포 속도가 빠름            모바일 앱은 사용자마다 배포되는 때가 다름           플랫폼 환경에 제약이 없음            모바일 앱과 다르게 안드로이드, ios 등 따로 개발할 필요가 없음           단점      모든 것을 다운받아야하기 때문에 속도가 느림 (페이지 전환되는 느낌)   UI 사용성이 앱보다 좋지 않음   연결 위해서 URL 입력해야함   모바일 앱의 특징   장점      앱마켓 사용 가능 : 다양한 수익 창출            앱을 만들었다면 꼭 마켓에 배포해보기           푸시알람, 주소록, 카메라, GPS 등 스마트폰 기능 사용 가능            이런 리소스를 사용하는 것이 필요한 서비스라면 앱 추천           사용자들의 서비스 실행 편함 : 아이콘 클릭으로 서비스 시작 가능   스마트폰에 최적화 됨 = 속도 빠름   메모리 적인것, UI등이 최적화 되어있어 성능 좋음   UI 사용성이 스마트폰에 최적화 되어 있음   단점      마켓 등록 위해 개발자 등록 해야함   사용자가 앱을 다운 받아야하는 불편함            받았다가 바로 삭제하는 경우 많음           IOS, AOS 모두 개발 필요   앱이 수정되면 마켓에 새로 배포해야함 = 배포까지 시간 오래걸림   사용자가 사용하는 디바이스에 OS 따라 버전을 관리해야함   예시) 카카오톡      사용자가 서비스에 자주 접속 = 접속 간편해야함   메세지 왔을 때 빠른 확인 필요 = 알람 필요   UI 매우 중요 = 최적화 필요   간편한 인앱 결제 기능 필요 = 이모티콘, 기프티콘 등   반대 예시) 네이버 = 굳이 사용자가 앱으로 메일 확인할 필요 없다면…   일반적인 서비스의 구성      백(REST API), 프론드(Web + 모바일 앱)   백(REST API), 프론드(Web)   개발의 현실      새로운 개발 프로젝트에 딱 맞는 인원 배치 어려움            해본 사람이 세팅하고 리드하는 동안 경험 없는 팀원이 공부를 조금 더 하고 시작           정해진 시간 안에 완성해야함 = 모든 기능 넣기 어려움   프로젝트 : 정해진 자원과 한정된 기간 내에 최대한 완성도를 높이는 것   타협 방법      공통의 목표 정하기            백엔드 안해봤는데 공부해서 결과물 만들고 싶어 등           우리가 구현하고자 하는 핵심 기능 명확히 정의하고 개발자 배치            공부해서 앱할래, 현실과 타협해서 웹할래?           우리 팀의 역량 객관화   서비스 구현하는 것 뿐만 아니라 서비스 구현까지 개발자의 역할   Q&amp;A   Q. 하나의 서버로 웹과 앱 모두를 동시에 서비스할 수도 있나요? A. 웹페이지, 모바일 두 개 다 모두 프론트엔드임. 동일한 프론트가 같은 서버에 API를 요청하면 안될까?  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%95%B1-%EC%9B%B9-%EC%96%B4%EB%96%A4-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%9C%BC%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%A0%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[Daily Contents] System과 Infra",
        "excerpt":"    System      목적에 맞춰서 만든 체계   Infra      (특정한 APP을 활용한 서비스를 운영하기 위해) 필요한 다양한 하드웨어나 운영체제, 미들웨어, 네트워크 등 시스템의 기반을 총칭   IT 인프라 = 시스템들의 기반 체계   Infra의 4대 구성 요소      하드웨어   운영체제   네트워크   미들웨어            운영체제와 소프트웨어, 소프트웨어와 소프트웨어 간에 통신, 중재하는 역할을 하는 소프트웨어.       상황에 따라 시스템에 편입되기도 하고, 인프라에 편입되기도 함       가장 흔하게 접하게 될 미들웨어는 웹서버, 웹 애플리케이션 서버(WAS), DBA(Database Management System), Nginx 등           사용자는 인프라가 어떻게 구성되어 있는지 딱히 느끼지 못한다!   Legacy는 뭘까?      오래된 시스템   구성 시스템            현재는 AWS, Azure와 같은 가상화 시스템이 우세하고 있는 상황. 기존의 물리적인 서버를 가지고 있는 업체들은 기존 물리 서버를 활용하면서 시스템의 확장을 고려해야 한다. 반면에 신규 서비스를 만들 때는 물리 서버를 구축할 필요 없이 클라우드로 서버를 구축하면 되겠다!           System과 Infra의 관계         Q &amp; A      SSAFY의 Infra를 어떻게 사용할 수 있나요?       서버는 Amazon EC2, 운영체제는 Ubuntu, 공개망으로 제공됨   여러분의 Application을 Infra, System에 올리기만 하면 돌아갑니다.      Application은 시스템이 아닌가요?       System과는 구별되는 개념   채팅 시스템을 구현했다고 생각해 보자!            카카오톡, 매터모스트처럼 다른 애플리케이션이 올라가도 서비스는 가능하다.       Application에 사용될 뼈대라고 생각하면 될까?                  ​아키텍쳐가 아닌 개발자라도 시스템 인프라를 체계적으로 파악했을 때와 파악하지 못했을 때 더 효율적인 개발이 가능할까요?       시스템, 인프라는 지금은 SSAFY에서 제공해주지만 사실은 굉장히 넓은 영역   조금이라도 흐름을 알아두면 프로젝트를 조금 더 짜임새 있게 설계하는 데에 도움이 되지 않을까?   회사에 가면 인프라 팀이 있어서 인프라를 개발할 일은 적지만, 인프라를 이해하고 개발하는 것과 이해하지 못하고 개발하는 것은 차이가 있음!          jvm도 미들웨어인가요?       그렇다고 볼 수 있다. 직접 다루는 게 아닌, 자바를 설치하면 알아서 동작하도록 도움을 주기 때문          인프라 공부에 순서가 있을까요?       순서는 없다. 프로젝트를 만들었을 때 모르는 것들을 만나면 그때그때 공부해보자!          설계도 작성 시 시스템과 인프라를 구분해서 나타내주어야 할까요?       보통은 시스템 설계도, 인프라 설계도 따로따로 작성한다. 다들 잘 모르기 때문에… 알고 있다면 강점이 될 것          Django 는 웹 애플리케이션 프레임워크던데 미들웨어인가요 서버인가요?       Django를 실행하려면 python이 필요하기 때문에, python을 미들웨어로 보는 게 맞다.   python 위에 Django라는 프레임워크와 프레임워크로 만든 나만의 앱이 있는 것   미들웨어는 개발을 도와주는 도구라고 생각해보자!          서버 인프라에서 ubuntu와 centos를 선택하는 기준이 있을까요?       국내에서는 centOS가 많았지만 지원이 중단되면서 2021년 중반부터는 ubuntu로 많이들 옮기고 있다.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/System%EA%B3%BC-Infra/",
        "teaser": null
      },{
        "title": "[Daily Contents] Vue로 FrontEnd 개발해보기",
        "excerpt":"    Vue로 Front End 개발 시작해보기   * 기존 Vue.js의 렌더링을 위한 가상 DOM 설계는 HTML 기반의 템플릿을 제공하고, 이 템플릿 구문을 가상 DOM 트리로 변환하고 실제로 DOM에 어떤 영역이 업데이트 되어야 하는지 재귀적으로 탐색하는 방식. * 불필요한 탐색이 많이 포함됨. * 템플릿 구문에서 정적인 구문이 대부분을 차지하고 동적인 구문이 적을 경우 불필요한 부분이 더욱 발생.   렌더링 성능을 향상하고자 최적화 작업 진행. 컴파일러로 동적 요소만을 탐색하여 트리 순환. 메모리 사용량 절감.   트리쉐이킹 -&gt; 사용하지 않는 코드를 제거하여 코드 최적화 Vue3에서는 이를 강화하여 번들 크기를 절반 이상으로 대폭 줄이는 것에 성공   대표적으로 Composition API 추가.   본래의 Vue의 코드는 직관적이지만 규모가 커지고 로직이 많아지면 결국은 사방에 흩어지게 될 것. 이 문제를 해결하기 위해 Composition API 등장.   소셜 로그인에 대하여      로그인 기능은 중요. 알아두길.   아키텍쳐   Q. 왜 FE에서 로그인 인증 코드 등을 다 처리하지 않고 BE에 전달하는가? A. 보안에 취약하기 때문에.   EX) Kakao      카카오 Developer 사이트에 개발자 가입을 한 후 API KEY를 받아 사용. EX) Google   Index html에 SDK를 넣거나 npm 라이브러리를 이용. EX) Facebook, naver 등등… 위와 마찬가지.   Firebase 인증      사용자의 기본적인 프로필 사진, 닉네임 등이 저장되는 이점이 있음.   사용자의 편의를 위해 지속적 관리, 로직 추가.   프로필 업데이트, 닉네임 변경, 아이디 기억하기, 회원 탈퇴 시 같이 탈퇴, 비밀번호 찾기, 세션 만료, 소셜 회원가입하고 비밀번호가 또 요구될 경우... 등등.   QnA   Q. 무슨 로직을 짜야 할지 생각나지 않을 떄. A. 분위기 환기, 컨디션 재정비.   Q. React보다 Vue가 우수한 점은? A. React의 경우 업데이트가 늦어지고 있는 등의 문제가 있으나 둘 다 우수.   Q. 로그인할 때 모달을 사용하는가? 별도 라우팅 이동을 하는가? A. 로그인 자체는 라우팅을 이용해야 함. 로그인이 필요한 기능을 사용할 때 라우터 기능을 이용.   Q. 회원 가입된 유저의 테이블과 소셜 로그인에 사용하는 이메일 저장 테이블을 분리해서 써야 하는가? A. 분리할 필요는 없음. 테이블 생성도 비용이기에 분리는 효과적으로 보이지 않음.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/Vue%EB%A1%9C-FrontEnd-%EA%B0%9C%EB%B0%9C%ED%95%B4%EB%B3%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Daily Contents] SpringBoot JPA",
        "excerpt":"    JPA   JPA : 표준 ORM(Object-Relational Mapping)   객체 관계 매핑 : 데이터가 담긴 자료구조들의 객체를 저장   장점      쿼리를 몰라도 구현할 수 있다.   두 가지만 하면 된다!!   DB 테이블명 @Entity 원하는 것을 명령하는 쿼리가 되는 JpaRepository                                          누가       언제       어디서       무엇을               어떻게       왜                       게시판       UID               글쓴 사람       글쓴 날짜       ip 주소       제목       내용       모바일/웹       N/A                 Board       uid               user       createdDate       ip       title       contents       1/2                         댓글       UID       게시판_UID       글쓴 사람       글쓴 날짜       ip 주소               내용       모바일/웹       N/A                 Reply       uid               user       createdDate       ip               contents       1/2                      프로퍼티 설정   resources/static/application.properties » ddl의 옵션(create 등) 의미 자율학습   Relationship Mapping      다중성, 방향성, 연관관계의 주인   다중성      @OneToOne, @OneToMany…   일대일, 일대다, 다대일, 다대다   방향성      @JoinColumn   양방향은 JPA에서는 지양   연관관계의 주인      @OneToMany(mappedBy = “boardFk”) ** 양방향일 경우 어떤 테이블 기준으로 데이터를 삭제하면 그것에 관련된 데이터들을 다 삭제할 것인가?   FK 키 관리 주인을 설정해 준다. '다' 쪽이 주인이다. @ManyToOne 은 항상 주인이다.   JpaRepository      Read : find**** 로 시작   Delete : delete**** 로 시작   Create : save   Update : 객체 조회 후 값 변경 그리고 다시 save   Builder : 객체 생성할 떄의 Tip      설계자가 객체를 생성할 떄 순서를 고려하지 않을 때를 방지, 생성자 앞에 @Builder 어노테이션을 작성.   SpringBoot JPA Docs      메소드 명이 곧 쿼리 (ex. findByID, findByTitle, findTop1000ByOrderByUidDesc…)      SpringBoot JPA는 Hibernate라는 ORM 프레임워크를 사용해서 구현한다.   기본적으로 제공되는 레파지토리 메소드 이름 중에 조회에 사용되는 메소드는 find로 시작되는 메소드이다.   JPA를 사용할 때 꼭 구현해 줘야 하는 두 가지는 엔티티와 레파지토리다.   연관관계를 설정할 때에는 3가지를 설정해 줘야 하는데 다중성, 방향성, 연관관계 주인을 설정해 주어야 한다.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/SpringBoot-JPA/",
        "teaser": null
      },{
        "title": "[Daily Contents] React로 FrontEnd 개발해보기",
        "excerpt":"    React   설치 및 시작      Nodejs 설치 : npm(Node Package Manager)   CRA 설치 : 설치 희망 path &gt; npx create-react-app testpjt   - npm = npx - npm이 버전업이 되면서 나온 명령어   ** npm start 로 실행!! **           App.js : 모든 소스가 있는 곳            index.html, index.js              index.js 파일의 root.render 라는 렌더링 선언, 그 내부의 App라는 커스터마이징된 태그가 컴포넌트.       App.js가 SPA를 위해 injection 되어있다.       App.js의 내부 function 등의 내용 수정에 따라 페이지의 내용이 변경.           테이블 생성 &amp; 데이터 적용      React 문법 : 대부분의 Object 표현 방식   { } 중괄호 활용. ex) let title = [‘이름’, ‘전공’] =&gt; { title[0] }   useState      import { useState } from ‘react’;   [객체, 대체값] let[name, nameUpdate] = useState['이름1', '이름2']; =&gt; button onClick {() =&gt; { nameUpdate(['이름3', '이름4']) } }  앞의 name은 대표하는 변수명, 뒤의 nameUpdate는 대체할 수 있는 값. =&gt; 아래의 버튼으로 원래의 이름1, 이름2를 이름3, 이름4로 바꾸는 것이 가능.   component      ex) function TrComp(props)   상위 컴포넌트에서 name과 major 등의 미리 정해둔 변수값을 props를 통해 하위 컴포넌트로 전함.   DataGrid      import { DataGrid } from ‘@mui/x-data-grid’;   json 형태로 만들어둔 값을 &lt;DataGrid rows={rows} columns={columns} /&gt; 등으로 주입.   DataGrid 응용      API 활용하여 응용   ex) &lt;DataGrid rows={rows} columns={columns} rowsPerPageOptions={[13,26,100]} checkboxSelection /&gt;  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/React%EB%A1%9C-FrontEnd%EA%B0%9C%EB%B0%9C/",
        "teaser": null
      },{
        "title": "[Daily Contents] Project DB설계",
        "excerpt":"    1. DB 설계의 목적   - 프로젝트, 명세서 등의 정보 요구사항에 대한 정확한 이해 - 분석자, 개발자, 사용자 간의 원활한 의사소통 수단 - 데이터 중심의 분석 방법 - 현행 시스템만이 아닌 신규 시스템 개발의 기초 제공      설계를 대충 하면 기능 한 개 추가될 때마다 DB와 관련된 이미 개발된 프로그램도 함께 뜯어고쳐야 하는 경우가 발생한다.   2. 설계를 위한 요구사항 분석   - 데이터베이스에 대한 사용자의 요구사항을 수집하고 분석해서 요구사항 기능 명세서를 작성   3. 개념적 설계   - 작성한 요구사항 명세서에서 데이터베이스를 구성하는데 필요한 개체, 속성, 개체 간의 관계를 추출하여 ERD를 생성 1. 개체와 속성을 추출한다. a. 대부분 명사로 선별한다. 2. 개체 간의 관계를 추출한다. a. 대부분 동사로 선별한다. b. 관계에 속한 속성도 있을 수 있다. c. 1:1, 1:N, N:M d. 필수적인 참여, 선택적인 참여   3-1. 개체와 속성   - 요구사항에서 개체는 대부분 명사로 이루저여 있지만, 속성과 구별하여 추출한다.   3-2. 개체 간의 관계   - 개체 간의 관계는 여러가지로 분류해서 정의된다.   3-3. 개념 설계 기반으로 ERD 생성   4. 논리적 설계   - 모든 개쳬는 릴레이션(Table)으로 변환 - N:M 관계는 릴레이션으로 변환 - 1:N 관계는 외래키로 표현 - 1:1 관계는 외래키로 표현 - 다중 값 속성은 독립 릴레이션으로 변환   4-1. 모든 개체는 릴레이션으로 변환   4-2. N:M 관계는 릴레이션으로 변환   4-3. 1:N 관계는 외래키(FK)로 표현   - 일반적으로 1:N 관계에서 1측 개체의 기본키를 N측 릴레이션에 포함시키고 외래키(FK)로 지정   4-4. 1:1 관계는 외래키로 표현   - 일반적 1:1 관계는 외래키(FK)를 서로 주고 받는다.   4-5. 다중값 속성은 독립 릴레이션으로   - 릴레이션에서는 다중 값 속성으로 가질 수 없으므로 다중값 속성은 별도의 릴레이션으로 생성해야 함.   5. 물리적 스키마 및 구현   - ERD를 실제 테이블로 생성한다.(Workbench 같은 DB Tool이나 SQL 스크립트 사용으로도 가능해야 함)   반정규화란?   ** 정규화된 엔티티타입, 속성, 관계를 시스템의 성능 향상, 개발과 운영의 단순화를 위해 모델을 통합하는 프로세스 **   ** 정규화 모델 ** - SQL 작성이 용이하지 않고 과다한 테이블 조인이 발생하여 성능이 저하될 가능성이 높다. ** 반정규화 모델 ** - 같은 데이터가 여러 테이블에 걸쳐 존재하므로 무결성이 깨질 우려가 있다. - 하지만 성능을 더 중시한다면 고려해 볼 만한 선택지.   테이블 반정규화 방법   - 1:1 관계의 테이블 병합 - 1:N 관계의 테이블 병합 - 슈퍼/서브 타입 테이블 변환 - 수직 분할(집중화된 일부 컬럼을 분리) - 수평 분할(행으로 구분하여 구간별 분리) - 테이블 추가(중복 테이블, 통계 테이블, 이력 케이블, 부분 테이블)   대표적 반정규화 - 컬럼 반정규화   - 중복 컬럼 추가(자주 조회하는 컬럼이 있는 경우) - 파생 컬럼 추가(미리 계산한 값) - PK에 의한 컬럼 추가 - 응용시스템 오작동을 위한 컬럼 추가(이전데이터 임시 보관)   대표적 반정규화 - 관계 반정규화   - 중복 관계 추가(이미 A 테이블에서 C 테이블의 정보를 읽을 수 있는 관계가 있음에도 관계를 중복하여 조회 경로를 단축)   정규화가 좋은가 반정규화가 좋은가?   ** 정답은 정해져 있지 않고 그때그떄 다르다. 개념을 잘 알고 있어야 적절하게 쓸 수 있다. **   Quiz(정리)      면접관 Q. 반정규화에 대해 간단하게 설명해 보세요.   지원자 ** A. 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법입니다. **   Q&amp;A      Q. 수평 분할과 인덱스는 데이터 접근을 빠르게 하는 원리가 동일한 듯한데 어느 면에서 차이점이 있는지?   A. 필드가 굉장히 많이 늘어나는 경우가 있다. 이런 경우인데도 특정 부분만 조회하게 되는 경우가 있는데, 이런 조회를 반복하면 메모리에 부하가 늘어나게 된다. 그래서 여기서 가장 많이 쓰는 필드만을 추출해서 사용한다. 즉, 속도와 퍼포먼스를 위해 수평 분할을 하는 것.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/Project-DB%EC%84%A4%EA%B3%84/",
        "teaser": null
      },{
        "title": "[Daily Contents] 개발자와 UX",
        "excerpt":"    UX/UI 정의   UX(User Experience) : 사용자 경험 UI(User Interface) : 사용자 상호 작용 - 디지털 기기(어느 플랫폼에서?), 사용자(누가?), 상호 작용(어떻게 사용할 것인가?)과 관련   _ UX/UI 정의 : 어느 플랫폼에서 누가 어떻게 사용할 것인가를 고민하는 일 _   현업에서의 UI/UX      회사 규모에 따라 역할이 달라짐   사용자 : 기획자 PM_ex) 삼성전자   상호 작용 : 디자이너   디지털 기기 : 개발자 IT회사_ex) 네이버, 카카오   개발자 관점의 현업   기획자 -&gt; 디자이너 -&gt; 개발자 - 플랫폼 스펙에 없는 기능들 요구 - 결과물에 대한 책임은 개발자, 가만히 있으면 피해를 입음   스펙에 없는 기능 예시   1. 플랫폼에 없는 컴포넌트(IOS에는 있으나 안드로이드에는 없는 기능) 2. 해상도 변화를 고려하지 않은 디자인(늘어나지 않는 이미지와 늘어나는 기준에 대한 가이드) 3. 구현할 수 없는 인터렉션(애니메이션) 4. 예외처리 되지 않은 기능들(\"이 상황에는 어떤 화면을 표시해야 하죠?\") 5. 폰트의 line height(웹 환경과 디자인 툴의 표시 차이)   현업 관점에서 유능한 개발자   - 요구 사항에 대한 [가능/불가능/예외 사항 판단 능력] - 이를 정확하게 납득시킬 수 있는 ***설득력***(가장 중요) - 그 기능을 요구하게 된 기획자, 디자이너의 의도 파악 - 최대한 요구와 일정에 맞출 수 있는 개발 실력 * 생각보다 (훨씬) 설득이 잘 안 된다...   설득이 잘 안 되는 이유   - 설명할 수준으로 알고 있기 어려움 - 개발자에 대한 인식(수동적인 태도 \"그건 안 돼요\" -&gt; 그냥 하기 싫어서 안 된다고 말하고 있다는 인상을 주면 안 됨) - *** 지속적인 협업을 통해 나에 대한 신뢰 확보 ***   UI 이해의 중요성   - 각 영역에 대한 이해가 높을수록 일을 하기 수월함 - 한 가지 전문적인 영역 +@ 가 높은 연봉을 만든다   백엔드 개발자에게 UI/UX?   - 백엔드 개발자도 UI/UX 이해가 필요한가요? - 만들고 있는 기능이 어디에 쓰일 것인지 알고 있어야 함.(API 설계 및 예외 처리 등) - 개발자 실력 측정은 동료의 평가로부터 나온다.   UI/UX 개발 특징   좋은 UX란   - 기존 불편함을 개선(카카오뱅크) - 새로운 경험(넷플릭스) - 서비스의 목적/의도는 무엇인가요? - 사용자에게 어떤 느낌을 주고 있나요?   UX의 어려움   - 정답이 없는 분야/예측하기 힘든 분야 - 결과(데이터)를 바탕으로 설계 - 사용자 행동 분석 필요 -&gt; 툴 이용 - 학습의 분야 -&gt; 여러 사례들을 분석한 책들을 학습하자   UI/UX 개발 특징   - 뮤직 플레이어 서비스를 개발한다고 가정 - UI/UX 설계를 담당하게 되었다 가정 * 익숙한 UI/UX도 직접 설계하려면 기억하기 어려움   UI/UX 학습 방법   - 서비스의 UI/UX를 의식하며 사용 - 기존 서비스들의 UI/UX를 분석 -&gt; 평소 관심이 가장 중요   UI 학습 방법   - 디자인 영감 얻기(Behance, Dribble, Pinterest) - 폰트 크기/간격, 여백/색상의 조합을 규칙화해 보기   Front-End 개발자의 매력   - 프로젝트, 서비스의 첫 이미지는 화면에서 결정 - 서비스의 평가는 Client 품질에서 결정 - 큰 이슈는 Back-End에서 나온다.   인정받는 Front-End 개발자?   - 개발 실력 == 결과물 또는 동료들의 평가   UX 사례   - 요구사항 : 음악에 따라 배경 사항을 바꾸고 싶어요. * 어떤 색상을 선택하지? 미리 정한 랜덤 색상 or 앨범 색상 느낌? -&gt; 앨범 색상은 어떻게 얻지? 이미지에서 평균 값 색상 추출? 라이브러리가 있나?   _ 개발자의 선택 : 그 기능이 정말 중요한가? 개발 비용은? 개발자의 애정이 있는가? _   - 개발 예외 케이스 발생 : 너무 밝거나 어두운 경우 * 기능을 취소하고 롤백/해결 방안 고민 -&gt; 어둡거나 밝을 때 분기를 이용할 수 있을까? -&gt; 색상 대비(color contrast)를 참고해 보자.   - 중요하지만 기획/디자인 단계에서 예상하지 못한 UX * 다른 곳에서는 어떻게 하고 있나?(음원 사이트 참조) 어떻게 구현해야 할까?   _ 개발 팁 ** ** 사소한 부분이 실력 차이를 만듭니다. _   현업 UI/UX   * 암호화폐 자동 거래 봇 서비스 UI를 만듭니다. - 거래소 API를 활용하여 거래소 계정 연결 - 유저가 작성한 알고리즘 매수/매도 - 동시 여러 개 봇 운용 가능 - 유저가 작성한 알고리즘 백테스트 기능 - 유저 간 알고리즘 공유 기능   Q&amp;A   Q. 퍼블리싱은 어느 정도까지 공부해야 하는지? A. Todo 앱이나 레이아웃을 잡을 정도의 UI 제작 연습. CSS는 생각보다 오래 걸리지 않음.   Q. 웹다자인 기능사 자격증은 따는 것이 좋은지? A. 자격증도 좋으나 개인 포토폴리오 사이트를 하나 만드는 것이 좋음.   Q. 추가적으로 참고할 수 있는 다른 디자이너 분. A. 구글 인터렉티브 디벨로퍼.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%99%80-UX/",
        "teaser": null
      },{
        "title": "[Daily Contents] 파이어베이스 소개",
        "excerpt":"    DB, 로그인, 호스팅에 사용…   Firebase란?   개발, 성장, 수익 등에 쓰임   1. 인증   FirebaseUI는 Firebase 인증 SDK를 바탕으로 빌드된 라이브러리로, 앱에서 사용할 수 있는 삽입형 UI 흐름을 제공. 이점은 다음과 같다. - 여러 제공업체 - 계정 연결 - 맞춤 설정 - 간편 가입 및 자동 로그인 - 현자화된 UI - 익명 사용자 업그레이드  * 구글 로그인 Kotlin, JS, C++, flutter 등 지원   2. 데이터 베이스   Firebase는 실시간 데이터 동기화를 지원하며 클라이언트에서 액세스할 수 있는 2가지 클라우드 기반 데이터베이스 솔루션을 제공. * Cloud Firestore는 모바일 앱 개발을 위한 최신 데이터베이스로서 직관적인 새로운 데이터 모델, 실시간 데이터베이스보다 풍부하고 빠른 쿼리와 원활한 확장성 제공. * 실시간 데이터베이스는 Firebase기존 데이터베이스로, 여러 클라이언트에서 실시간으로 상태를 동기화해야 하는 모바일 앱을 위한 효율적이고 지연 시간이 짧은 솔루션.  # firestore가 여러 단점을 보강한 최신 DB이므로 추천. # 실시간 수신대기-Vue나 React에서 작성(Web, IOS, Kotlin, flutter, python, C++, go, Unity, ruby, C# 등 지원)   3. 스토리지   Firebase용 Cloud Storage - 사진, 동영상 등의 사용자 제작 콘텐츠를 저장하고 제공해야 하는 앱 개발자를 위해 제작 - Blob 또는 File에서 업로드, Byte 배열, 문자열에서 업로드   4. 호스팅   - Vue나 React로 코드 작성 후 압축, 별도 웹 서버에 설정 없이 Firebase에 올리면 호스팅 사이트 제공. - 자신만의 도메인을 갖고 싶다면 따로 결제.   5. Function   Firebase용 Cloud Functinos - Firebase 기능과 HTTPS 요청에 의해 트리거되는 이벤트에 응답하여 백엔드 코드를 자동으로 실행할 수 있는 서버리스 프레임워크. - Google의 클라우드 서비스에 저장되고 관리형 환경에서 실행. - 자체 서버를 관리하고 크기를 확장할 필요 없음.   Q&amp;A   Q. 백엔드 서버 따로 두고 유저인증 부분만 Firebase 사용 가능한지? A. 가능함.   Q. 대규모 트래픽에서 Firebase가 적합하지 않다고 하는데 어느 정도까지가 사용에 적합한가? A. 대규모 트래픽에서 장애가 있었다는 소식을 들은 적은 없음. 일반적인 스타트업이나 싸피 프로젝트에서는 충분.   Q. 기업에서 많이 사용하는지? A. 전체적으로 다 사용하는 기업은 얼마 없으나 인증, 호스팅, Function 등 기능 하나를 사용하는 기업은 다수.   Q. 계정 관련 이외에도 Firebase의 유용한 점은? A. 인증 이외에도 Key-Value 기반 DB, Storage, Function, Cloud message(앱에 메세지 오는 것) 등등 가능.   Q. 서버리스하게 만들어주는 Function 통해서, DB 접근해서 데이터 줄 수 있을지. A. Function이 Node.js, HTTP 기능 지원. REST 구현하고 데이터 전송.   Q. Firebase로 API 요청에 대한 응답을 각각 실행 가능한가? A. 가능.   Q. 이미지 관련 처리만 Firebase로 처리, 백엔드 서버를 따로 두는 것도 가능한가? A. 가능.   Q. Spring 백엔드가 있는 경우에 Firebase를 쓰는 것이 어떤 이점이 있을지. A. 다른 기능을 사용하는 것을 추천. 인증이나 message, storage 등을 이용하면 좋을 것.   Q. 이런 좋은 기능이 왜 무상인지? A. 일정 이상의 트래픽을 넘어가면 유료.   Q. 기존에 잘 작동하던 프로젝트로 Firebase로 이식하는 게 더 나은 경우가 있을지? 유지관리비용, 보수성, 편리성 측면 등에 대해 의문. A. 코드가 줄어들기 때문에 유지관리비용 등은 감소.   Q. GCP 콘솔에서 제공하는 Firebase와 홈페이지에서 제공하는 것과 차이가 있을지? A. GCP 콘솔이 더 방대하다고 함.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%ED%8C%8C%EC%9D%B4%EC%96%B4%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%86%8C%EA%B0%9C/",
        "teaser": null
      },{
        "title": "[Daily Contents] 데이터 크롤링의 세계",
        "excerpt":"    데이터 크롤링   누군가가 인터넷에 올린 정보를 수집해 사용하는 기술 -&gt; 불법적인 행위로 이어질 수 있음.   Q1. 인터넷상에서 자동으로 데이터를 수집하는 방법에는 어떤 것들이 있나요?   1) OpenAPI 등 공개된 API 를 사용   공공데이터포털, NaverDevelopers, Mydata 허브 등   2) HTTP Get Method   - 정보가 게시되어 있는 대상 웹사이트를 HTTP GET을 사용하여 HTML 코드를 얻고 Text Parsing해서 사용 - 거의 대부분의 언어로 구현 가능 - 동적으로 변하는 웹페이지에는 활용이 어려움   3) Selenium Web Driver   - 본디 테스트를 위해 개발되었으나 데이터 수집용으로 활용 중 - 웹 브라우저 인스턴스를 생성해 실행시킨 후 해당 인스턴스를 컨트롤 - 웹사이트 테스트 자동화 목적으로 개발 - 가상의 브라우저를 실행시키는 Headless Mode 등이 있음 - HTTP GET 방식에 비해 느리고 불안정적이나 보다 많은 웹사이트를 스크래핑 가능 - 사람이 하는 것과 유사한 자동화 방법   4) 사람이 수작업으로 데이터를 수집하는 방법(ㄴㅇㄱ)   Q2. 웹 크롤러와 웹 스크랩퍼는 같은 의미인가요?   웹 크롤러 vs 웹 스크래퍼   ** 웹 크롤러(Web Crawler) **   조직적, 자동화된 방법으로 웹을 탐색/수집하는 프로그램 ex) 구글, 네이버 등의 검색엔진 결과 데이터를 수집하기 위한 봇(Bot)   ** 웹 스크래퍼(Web Scrapper) **   웹사이트에서 정보를 추출하는 프로그램 ex) 상품별 가격을 알기 위해 해당 상품을 파는 페이지들의 가격을 추출      크롤러보다는 대부분 단순 스크래퍼 개발 수요가 많음.   우리나라에서는 많은 기업들이 같은 의미로 혼용.   Q3. 웹 크롤링은 불법이 아닌가요?   크롤링은 불법인가?   불법에 노출되기 쉬운 기술 중 하나라 주의   웹사이트의 홈디렉토리에 위치한 robots.txt 파일을 열어보고 해당 사이트의 정책을 준수하지 않는다면 불법   크롤링할 웹사이트의 URL의 /robots.txt로 접속하면 크롤링해도 되는 파일, 안 되는 파일을 Disallow와 Allow로 구분해서 명시해 놓음.   크롤링한 자료를 상업적인 용도로 사용하면 불법   국내에서는 불법, 해외(미국)에서는 합법 판결이 난 전례가 있음   원작자의 수익을 해치지 않았다면 합법   비상업적인 용도라 하더라도 원작자에게 불이익을 주면 불법   ** 크롤러를 활용해 고의적으로 Abusing -   Q&amp;A   Q. 이전 기수에서 크롤링으로 문제가 된 사례가 있었는지? A. 보통 상담을 받고 진행하기 때문에 미연에 방지된다.   Q. 셀레니움을 사용할 때 렌더링되기 전에 실행되는 경우가 많아 대량의 사이트 데이터를 수집할 때 오류가 발생. 줄일 수 있을지. A. 한 페이지가 다 출력될 때까지 기다리게 하는 커맨드가 있다. 딜레이를 줘서 기다리게 하는 건 아마추어적인 방식. 레퍼런스에서 메서드 알아보기.   Q. 가장 크롤링을 잘 활용한 프로젝트는? A. 토스.   Q. 데이터가 많이 필요한 경우 수많은 URL을 찾아봐야 할 수도 있는데 방대한 데이터가 필요한 경우 수십만 번 HTTP 요청을 보내서 크롤링을 하는지? A. 한 사이트에 한 번 요청하면 데이터는 크롤링 완료. 수십만 번 같은 사이트에 요청하면 소송감.   Q. API 요청을 너무 많이 해서 차단된 케이스가 있다고 하는데 어느 정도 해야 그런 제한이 걸릴지. A. 사이트의 운영정책에 따라 별개.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%AC%EB%A1%A4%EB%A7%81%EC%9D%98-%EC%84%B8%EA%B3%84/",
        "teaser": null
      },{
        "title": "[Daily Contents] Web의 과거와 현재, 그리고 미래",
        "excerpt":"    Internet   컴퓨터로 연결하여 TCP/IP Protocol을 이용해 정보를 주고받는 컴퓨터 네트워크 1969년 미 국방부에서 탄생 중앙집중적인 통신시스템이 핵무기에 취약하다는 문제점을 해결하기 위해 개발 1982년 서울대학교 - ETRI 네트워크 시스템 구축   PC 통신   인터넷인듯 인터넷아닌 인터넷같은   World Wide Web(WWW) - 팀 버너스리   HTTP(HyperText Transfer Protocol) 통신규약을 정의 HTML(HyperText Markup Language) 개발 1990년 최초의 Web Browser, Web Server 개발 ex) MarkDown - 심플한 마크업 언어   WorldWideWeb - 최초의 웹브라우저이자 웹 에디터   Web Architecture   3tier architecture   Presentation tier, application tier, data tier   BackEnd   WAS - 절차지향언어 : ASP, PHP, Model1 JSP - 배포가 쉬운 대신 오류가 잦음. 대규모 서비스에 적합하지 않았음. - 객체지향언어 : Model2 JSP, Struts Framework, Spring Framework, ASP.NET  Python의 Django, Flsk Node.js의 Express   FrontEnd   HTML(Content), CSS(Presentation), JS(Behavior)   Web Browser의 발전   Netscape Navigator - 1990년대 중반까지 Web Browser의 표준으로 군림 - IE와의 1차 브라우저 전쟁에 패하여 사라지고, FireFox로 명맥 유지   Internet Explorer - MS의 Windows OS에 기본 탑재된 브라우저 - OS 기본 탑재를 바탕으로 점유율 95% 달성 - 호환성 부족 느린 성능 등으로 많은 비난 - 한국에서는 Active X의 이용으로 사용 강요 - 2022/06/15 드디어 익스플로러 지원 중단   Chrome Browser - Google이 개발하여 2008년 정식버전 출시 - 초창기 Apple이 개발한 Webkit 엔진을 그대로 탑재(현재는 블랭크 엔진) - V8 자바스크립트 엔진 탑재 - 강력한 개발자 도구 지원   V8 엔진   - 오픈 소스 - React, Vue, Anglur, node.js 등 개발...   Web의 진화   Web 1.0 제공하는 정보를 열람하기만 함. Web 2.0 제공자와 이용자가 소통. 단 이용자가 제공자에게 자신의 정보를 넘겨주게 됨. Web 3.0 1의 읽기, 2의 쓰기 개념에 더해 '소유' 개념을 더하자.   Web 3.0   - 데이터를 분산시켜 해킹에서 자유롭게 - 데이터의 소유권을 플랫폼 기업에서 개인으로 전환 - 참여자들에게 보다 많은 혜택과 권한을 제공   ** 참여자들이 함께 소유하는 탈중앙화 웹 생태계 **      블록제인, NFT…   P2E(Play To Earn)   ** 플레이한 만큼 돈을 버는 게임 - 국내에서는 불법 **   BlockChain Metaverse   DAO   ** 탈중앙화 자율조직(Decentrlized Autonomous Organization) **   중앙집권 주체의 개입 없이 자율적으로 운영하는 조직 투표를 통해 결정하는 과정은 블록체인 위에 모두 기록 투표권은 자격을 갖춘 사람(보통 토큰을 소유한 사람)만 행사   Web 3.0?   \"웹 3 본 적 있는 사람? 나는 찾을 수가 없다.\" \"웹 3.0은 현실보다는 마케팅 용어 같고 이해할 수가 없다.\" \"당신은 웹 3을 소유할 수 없다. VC와 투자자들이 소유할 것이다.\" \"Web3는 그저 다른 이름으로 포장된 중앙화된 실체이다.\"   ** 웹 3.0은 웹 2.0을 완전히 대체하는 것이 아닌 함께 작동되는 방향으로 갈 것이다. **   마치면서   웹의 미래는 밝다. 웹 개발자의 미래도 밝다. 공통 웹프로젝트 열심히...   Q&amp;A   Q. 가상현실 증강현실이 좀 더 대중화된다면 웹의 방향성도 달라질지. A. 웹이란 건 하나의 어플리케이션. 웹이냐 아니냐의 문제보다는 디바이스의 성능 문제에 가까울 것.   Q. PWA도 공부하는 게 좋을지. A. 공부하는 건 다 좋음. 과거에 없던 방식이고, 모바일에서 하면 앱을 만들지 않더라도 여러가지를 해 볼 수 있고, 추천.   Q. 웹 3.0에 대한 개인적인 소견을 듣고 싶음. A. 블록체인 기반에서 여러 서비스가 나올 것이라 생각. 하지만 어떤 서비스가 나오느냐가 중요할 것.   Q. 블록체인은 편의성보다는 익명성과 보안 쪽에 중점을 둔 서비스라서, 보편적인 서비스가 되기에는 쉽지 않다고 생각하는데, 소견을 듣고 싶음. A. 기술이라는 건 어떻게 이용하느냐가 중요함. 현재도 로그인 관련해서 유용하게 이용할 수 있기도 하고, 앞으로 계속 발전해 나갈 것.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/Web%EC%9D%98-%EA%B3%BC%EA%B1%B0%EC%99%80-%ED%98%84%EC%9E%AC,-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%AF%B8%EB%9E%98/",
        "teaser": null
      },{
        "title": "[Daily Contents] 웹 서버 프로그래밍 시 주의할 점",
        "excerpt":"    좋은 웹 AP가 구동될 것 같은 제품?   누가, 어떤 목적으로, 어떻게 사용하느냐에 따라 다르다!   ** ex) 좋은 사진이 갖춰야 할 것들 **      균형, 색감, 이야기   전문가용 고성능 카메라, 작가의 장비 활용 스킬   ** -&gt; 좋은 웹 AP가 가져야 할 것들 **      성능, 안정(신뢰)성, 보안 등…   싱글 게임   ** 개발자는 언어를 사용해 궁극적으로 메모리에 저장되는 값을 제어해가며 원하는 기능을 만들어 나간다 **   ** 치트 엔진으로 값 손쉽게 변경 가능 **   온라인 게임, 서버   ** 클라이언트의 데이터 vs 서버가 알고 있는 데이터 뭐가 우선일까? 이유는? **      서버의 데이터. 이러한 서비스가 제대로 돌아가려면 공평해야 하기 때문.   과거 몬스터 헌터 프론티어라는 게임이 클라이언트의 데이터를 우선한 결과 서비스 종료의 길을 걷게 됨.            클라이언트 의심의 중요성!       서버 중심의 능동적인 대처 필요           ‘너’를 의심   - 사용자 인증&amp;인가 - 서버 중심의 견고한 로직 처리 - 사용자 요청의 유효성 검증 - SQL Injection, XSS 방어   클라이언트 - 서버 통신 프로토콜   HTTP   HTTP   Hyper Text Tranfer Protocol Stateless -&gt; 요청을 한 번 받고 응답하면, 연결을 끊음. 중요한 특징 HTTP 서버는 불특정 다수의 요청을 전제 -&gt; 연결을 끊기 때문에 맥시멈이 높지 않아도 수용이 가능   ** Stateless 프로토콜의 단점은 무엇이며 이를 해결하기 위한 방법은? **      세션과 쿠키를 이용해서 로그인 구현을 할 경우 그 부분을 노리고 공격이 들어옴 -&gt; 토큰 방식으로 해결   사용자 인증&amp;인가   - 복잡하고 긴 URL을 암호처럼 사용? NO - 장소를 알더라도 사용자는 허가를 받고 진입할 수 있어야 함.   사진첩의 '사진'들은 비공개 데이터가 다수 긴 URL만 알고 있다면 그대로 접근 가능했던 시절이 있었음 -&gt; 물론 의도한 기능이라면 사용자에게 위임 가능함(구글 문서)   사용자 인증&amp;인가 - worst 사례   1. 최초 로그인을 통한 인증 과정 이후 차후 서비스 구동에 필요한 모든 API 호출은 URL이 곧 암호인 것처럼 사용 -&gt; 셋탑 박스 내부에서 호출하는 것이라 일반 고객들은 URL을 알 수 없다는 가정 하에 진행한 무모한 사례   요청 검증   요청 필드 값들이 유효한지 서버에서도 검증 특히 리소스 변경에 대한 건은 철저하게 진행 요청 값들의 길이, 코드 부합성등을 체크하는 게 오히려 성능에도 도움이 될 수 있음   요청 검증 - 파일 업로드 worst 사례   1. JSP로 구현된 서비스 &gt; 게시판 파일 업로드 기능 중 'JSP' 파일 그대로 업로드 허용. 2. '.JSP' 소스 파일 내에 특정 테이블 조회 기능 구현 -&gt; 카드 고객의 주요 정보 탈취   클라이언트 요청은 쉽게 변경 가능       ** 실제 사례 **   - 주문 버튼 클릭 후 PG사로 주문 ID와 결제 금액을 전송 - PG사는 요청받은 변조된 금액 20,000원 정상 결제 처리 - PG사를 통해 쇼핑몰은 해당 주문 ID 건이 정상 결제되었다는 응답을 받고 배송 시작   - PG사로부터 받은 HTTP 메세지만으로 모든 정보를 확신할 수 있어야 함 - 최소한 결제 금액 정보를 함께 받았어야 했음 - 혹은 결제 확정 전 PG사에 결제 금액 정보를 확인하는 과정을 추가했어야 함   SQL Injection   ** 클라이언트의 입력 값은 DB query &gt; where 조건문의 일부로 사용 **   select * from USERS where id = 'user1' and pw='pw1'; select * from USERS where id = ''0r 1=1 -- 'user1' and pw='pw1';   잠깐! Dos 공격?   - 우리는 보통 HTTP 요청의 첫 진입점으로 nginx를 사용 - Nginx에 Dos 공격을 방어할 만한 무언가가 없을까?   ** Request 비율 제한 등… 최소한의 장치는 마련할 수 있으므로, 관심을 가지고 설정하기 **   XSS 공격   ** Cross-Site Scripting **   게시글 본문 중 아래 글이 포함된다면?? &lt;script&gt;악의적인 해커의 URL로 사용자 주요 정보 전송&lt;/script&gt;   XSS 방어   프레임워크마다 활용되는 제품들은 있음 만약 없다면 스크립트 실행이 가능한 구문들을 직접 필터링   ‘나’를 의심   - 1이 아닌 N개 클라이언트의 요청 - 적절한 응답 시간과 데이터 신뢰성 - '트랜잭션' 처리 - 서비스 및 컨텐츠 사용 권한 - 주요 데이터 암호화   부하 테스트   - 'JMeter'와 같은 도구를  활용 부하 테스트 수행 - 서버 티어를 목표로 한다면 선택 아닌 필수   응답 시간   ** 요청 : 응답 시간을 줄이기 위해 캐시 layer 적용 고려 **   응답 시간 - 비동기 처리   Synchronous / Asynchronous 는 중요한 개념 업무 이해에 기반한 적절한 비동기 처리 사용 언어, 프레임워크 환경에서 제공하는 것부터 적용해 보기   데이터 신뢰성 - 관리자 환경 설정 예제   ** 관리자 환경 설정 내용을 ‘로컬 파일’로 관리 **   changeEnv() { \t파일오픈 \"D:\\env\\env.cong\" \twrite 작업 수행 }   ** 예상 이슈와 해결 방안은? **   데이터 신뢰성 - 싱글 서버?   ** 단일 서버로 서비스하는 경우는 없다. **   ** Multi-thread 환경에서의 [ concurrency ] **   ** Thread-dafe vs. thread-unsafe, 활용제품(라이브러리)의 설명에 주목 **   데이터 신뢰성 - DB까지도?   - SELECT... FOR UPDATE 문 등으로 명시적 lock 부여 - 특정 row에 대해 동시 트랜잭션이 발생하여 데이터 정합성이 깨지는 것을 방지   [ 트랜잭션 ] - 결제 예제, 중요**   - 쇼핑몰의 결제는 복수 개 수단으로 진행 - 문화상품권 + 신용카드 + 쇼핑몰 포인트 3개의 수단을 지원한다고 할 때 -&gt; 하나가 실패하더라도 전체 결제 트랜잭션 실패(처음부터 다시)   암호화   ** 내 데이터를 누군가 그대로 가져가더라도 문제 없도록 **   - 평문을 암호화 작업에는 분명 연산에 따른 비용이 수반됨 - DB의 USER 테이블에 주민번호, 핸드폰 번호와 같은 개인정보들 -&gt; 반드시 암호화해서 컬럼에 넣어줘야 하는 걸까?   - 암호화의 핵심은 '갈취당하더라도 안전하게...'임 - 민감한 정보들은 암호화하여 보관하도록 법제화되어 있음 - 암호화 솔루션 자체도 인가받은 제품을 사용해야 함   암호화 - 네트워크   ** [ https 통신 ] 은 선택이 아닌 필수 **   - 클라이언트 ~ 서버 티어 진입까지는 public한 인터넷을 거치는 구간 - 누군가 클라이언트의 요청을 엿볼 수 있다는 전제는 기본   logging   - 서버가 작동하면서 발생하는 주요 이슈들을 기록 - 단순 콘솔 출력보다는 주요 logger(라이브러리)를 사용 - 서버 운영 시 발생한 이슈 추적의 시작점   서버 테스트 시나리오   - 복수 개의 요청은 수행해봐야 함 - 눈에 보이지 않는 비 기능 요소에 대한 테스트 시나리오 작성 - 테스트할 내용을 안다는 것 자체로 SW 역량 인증   정리_서버 프로그래밍   ** ‘너’를 의심 **   - 서버 중심의 로직 처리 - 요청값들의 유효성 검증 - 사용자 인증 및 인가 - SQL Injection, XSS 방어   ** ‘나’를 의심 **   - 적절한 응답 시간 - 데이터 신뢰성 - 트랜잭션 처리 여부 - 리소스 사용 권한 체크 - 주요 데이터 암호화   ** 발생한 일 기록 **   - 효율적인 logging 구축 - 주요 액티비티 로깅 - 익셉션, 에러 로깅  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%9B%B9-%EC%84%9C%EB%B2%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90/",
        "teaser": null
      },{
        "title": "[Daily Contents] 공통 프로젝트 배포",
        "excerpt":"    학습 목표   AWS 배포를 위해 필요한 구조를 학습해본다. 웹서버를 운영하기 위한 기술 스택들을 알아본다. 자주 하는 실수에 대해서 알아본다. 배운 것들을 우리 팀 서버 배포 시에 활용해 본다.   배포 구조   ** 브라우저로부터 요청이 들어옴 -&gt; NginX가 받음 -&gt; 요청이 FE와 BE로 나누어져 감 **      80(http) or 443(https) 포트로 요청   /와 /api 로 나누어져 감   Docker 사용. FE의 정적인 파일들은 Nginix를 넣어주기도 함. -V(볼륨) 사용.   NGINX   High performance load balancer, web server, API gateway &amp; reverse proxy 비동기 방식이기 때문에 매우 높은 성능 정적인 파일(주로 프론트엔드 파일들)을 서비스할 때 뛰어난 성능(vs 톰캣) load balancer나 API gateway 용도로도 사용 가능 DDOS 공격 방어도 가능   FE와 BE의 분기   /로 들어오는 모든 연결은 FE로 /api 들어오는 요청은 BE로 Webserver로서의 역할 API gateway로서의 역할   Q. API 분기는 내부에서도 API 분기로만 가야 하는가? A. 선택. /api로 써도 되고, rewrite 기능을 사용하여 재설정도 가능.   CORS   FE BE 각각 naver.com:8080 naver.com:3000 이렇게 하면 안 되는가?   -&gt; 오류 발생   - Cross-Origin Resource Sharing(CORS) - 도메인(naver -&gt; google), 포트(3000 -&gt; 8080), 프로토콜(http, https)이 다를 때 발생 - NGINX의 설정을 기억해 보자 - https://domain-a.com의 FE JS 코드가 XMLHttpRequest를 사용하여 https://domain-b.com/data.json을 요청하는 경우   우리는 왜 도커를 쓰는가?   빠르게 필요한 서버를 증설할 수 있다. 기존에는 VM을 증설하는 방식을 사용 -&gt; VM이 부팅되는 1분이면 서비스 전체가 중지되기에 충분한 시간 운영체제를 부팅해야 하는 기존의 방식보다 빠름 이미지를 만들어두면 찍어내기만 하면 되는 배포의 편의성(w/k8s(쿠버네티스)) -&gt; 버전을 잘못 설치해서 발생하는 문제 해결   어디까지 도커화 해야 할까?   - FE/BE는 필수적 - 배포의 효율성/편의성을 생각해보자 - DB/Jenkins/Nginx는 선택적 (선택) DB를 이미지화해서 새로 배포할 일이 많이 있을까? 옮긴다면 데이터는? (선택) 빌드 서버를 병렬적으로 추가 증설하는 경우는?   임의의 포트를 쓰면 안 되는 이유?   놀랍게도 멀티캠퍼스에서는 투썸플레이스를 들어갈 수 없다! -&gt; 커피 쿠폰이 스타벅스인 이유? ㅋㅋ ISP(SKT, KT, LGU 등등)에 따라서 닫혀있는 포트가 존재   ** 장소에 따라 되고 안 되고 바뀌는 서비스라면? **   ** 고객은 그냥 이탈해 버림… **   Gitlab -&gt; Jenkins   개발자가 Gitlab의 특정 브랜치에 머지를 하면 이벤트가 트리거되어 Jenkins에서 빌드를 시작 빌드가 완료되면 도커 이미지가 제작되어 배포 동일한 도커 이미지로 제작, 배포되기 때문에 동일성(서버)가 보장   SSL( -&gt; TLS)   - 회원 가입 시에 비밀 번호 등의 개인 정보가 전송되고, 수시로 유출되어서는 안 되는 정보들이 오가기 때문에 암호화가 필요 - 매번 데이터를 암호화해서 전송하기 어렵기 때문에 TLS(Transport Layer Security)를 사용 - 이론적으로는 TLS을 활용한 통신은 안전하다고 볼 수 있다. - WebRTC를 위해서는 SSL 인증서 설치가 필요!!   Cert Bot   - https 확산을 위해서 시작된 비영리 프로젝트(Let's encrypt) - 상용 프로그램을 제작할 때는 보통 신뢰할 수 있는 ROOT 인증서 발급자로부터 SSL 인증서를 구매해서 사용 - SSAFY 프로젝트의 경우에는 Cert Bot을 이용해서 무료 인증서를 발급받아 사용하면 좋음 - Cert Bot은 Nginx에 자동으로 설정을 추가해 준다!!   사용자 계정 만들기   - 각 프로그램들을 실행할 때는 프로그램에 맞는 권한을 가진 사용자 계정을 만들어서 실행 - Ubuntu 계정이나 심지어 Root 계정으로 실행(sudo)하는 경우에는 해커의 공격 명령이 그 계정의 권한으로 실행되기 때문에 매우 위험 - 사용자 계정으로 실행하는 경우 해커의 공격을 받더라도 피해를 최소화할 수 있음  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EA%B3%B5%ED%86%B5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%B0%B0%ED%8F%AC/",
        "teaser": null
      },{
        "title": "[Daily Contents] SW 테스트케이스 설계",
        "excerpt":"    주제   테스트 가능한 코드 작성법 BE 및 FE의 테스트   테스트 가능한 코드 작성   아예 Test Driven 하기   테스트를 먼저 작성하면 테스트가 어려운 코드는 만들어질 수 없음.   아래 두 가지 원칙을 따른다.      Parameterize   Separate Logic and Effect            참조 : https://eunjin3786.tistory.com/90           테스트의 기본 형식: Input &amp; Output   ex) AM, PM을 판별하는 시스템      현재 시간을 Input함으로서 AM, PM을 판별.   Protocol           Swift언어에서 나오는 데이터 구조체       Python의 데이터클래스(Data Class)   Swift의 Protocol        Java의 record       WWDC 발표에서는 파라미터를 Protocol로 전달하여 유연성을 확보   Seperating Logic and Effects   ex) /temp 디렉토리 내 파일들 중 생성 시간이 현재 기준으로 10분 이내 것만 남기고 나머지 파일을 삭제하는 프로그램      Input이 없으므로 Parameterize가 안 되었다.   Output도 없다.   엉뚱한 파일이 삭제될 수도 있는 파일 삭제 테스트의 위험성   Output 파일 삭제의 위험성      삭제 대상 선정 로직과 실제 삭제 부분(Effect)을 분리하자.   CleanTemp() 함수는 삭제 대상 목록을 리턴 -&gt; 이 로직 부분이 테스트 대상   별도의 삭제 함수에서 이를 받아 삭제만 함.   이제 테스트는 CleanTemp의 변수를 조정하고 이에 맞는 삭제   FE 테스트   시각적 테스트      HTML 출력 비교   스냅샷 비교(JEST 활용)   시각적 테스트의 한계      실제 결과물의 구조를 예측할 수 있을까? -&gt; To Be의 특정이 어렵다.   테스트가 성공해도 항상 의도된 결과가 나올까? -&gt; 조금씩 틀어지면 항상 실패 테스트? -&gt; FE는 결과에 영향을 주는 요소들이 너무 많다 : CSS, 브라우저 환경 등등   이게 리팩토링에 도움이 될까?   지원 도구들은 많이 있음 -&gt; Percy, Chromatic, applitools -&gt; AI를 활용하여 의미있는 변경점을 찾아줌                          시각적 테스트       기능적 테스트                       용도       회귀 테스트       모든 종류 테스트                 TDD       불가능       가능                 실행 환경       브라우저 외부       브라우저 외/내부, Node.js                 테스트 도구       외부 서비스 필요(유료)       Jest, Mocha                 결과 확인       이미지 확인 UI 필요       커맨드 라인으로 확인                 CI연동/이력 관리       별도 UI 필요       빌트인으로 확인 가능           테스트 대상별                          Code       Component       통합                       대상       method       개별 컴포넌트       화면 + 시나리오                 테스트       prop 값, 기타 변수 값       컴포넌트의 pixel 등       기능 수행 자동화                 도구(추천)       JEST       Storybook       Cypress           ex) 버튼을 눌러 숫자를 증가시키는 버튼   ** 기능적 테스트 **      기능적 테스트는 클릭을 하여 값이 증가, 감소함을 체크       ** 시각적 테스트 **        기능적 요소는 제외, 숫자가 제 위치에 있는지, 폰트 크기 등을 체크   시각적 테스트 준비      StoryBook으로 관리하면 편하다!   통합 테스트(E2E 테스트)      서버 모킹 : API 모킹 서버 활용(https://resttesttest.com/ 등)   테스트 스크립트 : 자동화 도구 사용                          Selenium Web Driver       Cypress                       주 용도       E2E테스트       통합 테스트                 주 사용자       QA/개발자       개발자(프론트)                 사용 언어       JS, Java, Python, C#, Ruby       JS                 크로스 브라우징       지원       미지원                 실행환경       브라우저 외부       브라우저 내부                 실행속도       느림       빠름                 서버 목킹       미지원       지원           시각적 테스트 VS 기능적 테스트      둘 사이의 구분이 명확하지 않은 경우도 많음.   프로젝트, 컴포넌트, 기능별 특징에 따라 적절한 방식 선택   테스트의 가치, 효용을 고려하여 균형있는 선택 필요   단위 테스트 VS 통합 테스트      단위 테스트는 효용성, 비용을 따져 수행 여부를 판단해야 함. -&gt; 단위 테스트의 사업적 가치?   컴포넌트 단위 통합 테스트를 우선으로 고려.   애플리케이션 단위 통합 테스트는 보조적으로 활용.   정리.   ** 테스트 가능한 코드 **      파라미터화   Logic과 Effect의 분리   ** 프론트엔드 테스트 **      시각적 테스트 VS 기능적 테스트   컴포넌트 단위 시각적 테스트 : StoryBoard 활용   도구를 활용한 통합 테스트 : Cypress 등 활용   Q&amp;A   Q. cypress는 빠르지만 크로스브라우징을 지원하지 않는 반면 selenium은 크로스브라우징을 지원한다. cypress만을 사용하는 것은 위험하지 않은지? A. 용도에 따른 것. selenium은 QA에서 많이 활용. 반면 cypress는 개발자용. 빠르게 하나의 타켓을 체크하고 넘어가기 때문에 가볍기도 하다.   Q. 테스트해야 할 시기를 정하는 법에 대해 알고 싶다. A. 단위 테스트, 통합 테스트, 시스템 테스트 세 가지 등으로 나뉘는데, 각각 기능 범위, 페이지 범위, 전체 시스템 범위로 테스트.   Q. 현재 FE에서 TDD 도입하여 개발 중이며 유닛테스트에서는 Jset에서 MSW로 서버 목킹해서 테스팅 중. E2E 테스트에서는 서버를 목킹해서 테스트 해도 될 지, 아니면 실 API로 테스트 하는게 좋을지 여쭈어 봄. A. API 모킹 서버를 활용하여 테스트할 수 있음. 실 API 테스트가 베스트이나, 어려울 때 모킹 서버 활용.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/SW-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%84%A4%EA%B3%84/",
        "teaser": null
      },{
        "title": "[Daily Contents] Modern Java와 Python",
        "excerpt":"    모던 자바란? 함수형 프로그래밍 도입으로 큰 변화가 있었던 Java8 이후   오늘 다룰 내용   함수형과 스트림 고수준 병렬/동시성 지원 And more.... 그리고 파이썬   Java의 간략한 역사      1996년 1월 23에 Java1 출시 -&gt; 당시에는 느리다는 비판(1.2, 1.3 버전에서 JIT Compiler, HotSpot JVM 도입으로 많이 해결)   국내에서는 Java5(2004)부터 많이 활용   6, 7은 큰 변화가 없었음   8에서 큰 변화   2022년 현재 최신 버전은 Java18   모던 자바의 특징   함수형 패러다임 도입 쉬운 동시성(병렬처리) 도입 모듈성 강화 개발자 편의 API 추가   변화의 원인은?   세상의 변화, 개발자의 요구 반영, 파생언어/라이브러리의 장점 수용, 어른의 사정? 등   예제 1   ** 음양 더하기 **   자연수 배열과 부호 배열의 SumProduct 구하기   ex) func({1, 2, 3}), {T, F, T}) = (11) + (2-1) + (3*1) = 2     ** 옛날 자바 **   int answer = 0; for (int i=0; i&lt;sign.length; i++) \tanswer += absolutes[i] + (signs[i]? 1: -1); return answer;   ** 모던 자바 **   return IntStream.range(0, absolutes.length) \t.map(i -&gt; absolutes[i] * (signs[i]? 1: -1)) \t.reduce(0, Integer::sum);   예제 2   ** 문자열 리스트에서 길이가 5~10인 것만 대문자로 출력 **   ** 단 반복문, 조건문 없이… **     ** 옛날 자바 **   안 될 듯?   ** 모던 자바 **   list.stream().filter(s -&gt; s.length() &gt;= 5 &amp;&amp; s.length() &lt;= 10) \t.map(s-&gt; s.toUpperCase()).forEach(System.out::println);   함수형   ** OOP라는 특징에 맞게, 객체지향적으로 함수를 도입했다! **   완전한 함수라고 보기에는 어려움~   함수를 일급 시민(First Class Citizen)에 포함 -&gt; 사실은... 익명 클래스의 번거로움을 람다로 간편하게, 메서드 참조로 재사용 코드 블록을 주입(동작 파라미터화)하고 조합(Pipeline)할 수 있게 됨. 스트림의 기반, 병렬처리와 조화   ** 주요 패키지, 클래스   @FunctionalInterface java.util.function Consumer, Supplier, Function, Predicate... Operator 기본형 Int, Long, Double   함수형_람다, 메서드 참조   람다(lambda) = 익명 함수, 익명 클래스를 대체 함수형 인터페이스(이름 있는 람다) : 하나의 추상 메서드를 가진 인터페이스 메서드 참조 : 메서드나 생성자를 참조하기(::)   ex) 문자열 리스트를 길이에 따라 정렬)   Collections.sort(words, new Comparator&lt;String&gt;() { \tpublic int compare(String o1, String o2) { \t\treturn Integer.compare(o1.length(), o2.length());   - Collection.sort(words, (o1, o2) -&gt; Integer.compare(o1.length(), o2.length())); - Collection.sort(words, Comparator.comparingInt(String::length)); - words.sort(Comparator.comparingInt(String::length));   함수형_Use Case   ** 공식 문서 : “함수형은 이런 데다 쓰세요~” **   주요 인터페이스와 용례: 함수형이 적합한 곳 vs 아닌 곳   predicate : test 메서드, true, false 반환 - 조합 : and, or, not, negate - Use case : 필터, 실행 결과만 확인할 때, stream.filter   Function : apply 메서드, 인자와 리턴 존재, 여러 용도로 사용 - 조합 : andThen, compose - Use Case : 범용적, stream.map   Consumer : accept 메서드, 리턴 없음, 최종 소비자일 때 - 조합 : andThen - Use Case : 메세지 소비자, 처리기, stream.forEach, peek   Supplier : get 메서드, 인자 없음(리턴만) - Use Case : 메세지 생산, 조회, 실행 지연, 의존성 주입, stream.collect, generate   스트림   ** 컬렉션 + 함수형, 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소 **   외부 순환(for, while) vs 내부 순환(VM아 이것 좀 해조) SQL처럼 선언형 스타일로 데이터를 처리 쉽게 병렬처리 적용 : parallelStream 메서드   ** 주요 패키지, 클래스, 메서드 **   java.util.stream BaseStream, Stream map(), filter(), reduce(), min() C.stream(), C.parallelStream()   스트림_주요 개념   중간 연산과 최종 연산 - 중간 연산은 스트림을 반환, 여러 연산을 조합할 수 있음 - 최종 연산을 스트림을 모두 소비하고 닫음 - 스트림은 1회용(최종 연산 이후 사용 불가)   스트림_예제   ** 직원 리스트 -&gt; 부서별 직원 리스트 **   Map&lt;Department, List&lt;Empliyee&gt;&gt; byDept = employees.stream() \t.collect(Collectors.groupingBy(Employee::getDepartment));   ** 직원 리스트 -&gt; 부서별 급여 합계 **   Map&lt;Department, Integer&gt; totalByDept = employees.stream() \t.collect(Collectors.groupingBy(Employee::getDepartment, \tCollectors.summingInt(Employee::getSalary)));   ** 좋은 직원, 안 좋은 직원 나누기 **   Map&lt;Boolean, List&lt;Employee&gt;&gt; byGood = employees.stream() \t.collect(Collectors.partitioningBy(Employee::isGood));   한편 파이썬은…   원래 함수형(v1.0, since 1994) 내장 컬렉션 = 리스트, 맵(딕셔너리), 튜플, 세트, ... lambda, itertools, functools, generator   병렬/동시성_concurrent   저수준 병렬 처리의 어려움 : Thread, Lock, synchronized, .. 안전하고 쉬운 병렬처리 방법 제공 -&gt; 마법은 아니야~ - 많이 사용되는 패턴들을 언어 차원에서 API로 지원 - 고수준, 추상화, Thread Safety, 비동기 지원   주요 패키지, 클래스   java.util, concurrent Executor(s), ExecutorService xxThreadPool, ForkJoinPool Future, CompletableFucture Runnable, Callable   Executor / Service / Etc   Thread를 직접 생성, 관리하지 않고 ExecutorService에서 스레드 관리 작업(Runnable, Callable)을 Executor 서비스에 요청하고 결과 받기 작업 스케쥴링(cron, at) 기능 : ScheduledExecutorService Concurrent Collection - 스레드 안전한 List / Map 제공 Atomic Variable - 변수 자체가 원자성을 보장 Lock 객체 - 동기화 패턴에 따라 사용할 수 있는 유틸리티   비동기 지원_Async   ** 동기는 7기, 비동기는 8기 아 ㅋㅋ**   동기 vs 비동기 and 블록(block) vs 넌블록(non-block) 작업이 끝날 때까지 기다리기 vs 하고 있어. 나중에 물어볼게. Future : 비동기 연산 지원, 완료 확인/대기/결과 조회/취소 CompletableFuture : Future 작업 연결, 순서 정의 등   예제_스프링에서   ** 여러 API 호출을 병렬로 실행 **   for(ApiService api : apis) { \tapiResults.add(api.callApi(param)): } for(CompletableFuture&lt;void&gt; future : apiResults) { \tfuture.get(); }   @Async public CompletableFuture&lt;void&gt; callApi(String param) { \t/// ..api를 호출 \treturn new CompletableFuture&lt;&gt;(); }   한편 파이썬은   파이썬은 느려요~!? 일부만 맞는 이야기 GIL 문제: 스레드 활용을 제한하는 요소 multiprocessing asyncio, conroutine future, executors, ThreadPoolExecutor..   마지막으로_오늘 못 다룬 것들   Reactive(Flow API) 모듈화 Optional 타입 추론 컬렉션 API 개선 날짜와 시간 API 개선 Fork-Join 프레임 워크 Spliterator 인터페이스에 구현을 포함(static, default, private) try-with resources(AutoCloseable) http client 강화된 switch문 etc..   마지막으로2   ** Java Support Tools **   - visualVM, Jconsole - jps, jstack, jstat, jhat, jmap - jshell - flight recorder, jmx, Spring Actuator   ** Python Tools **   -profile(cProfile), memory_profiler, vProf  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/Modern-Java%EC%99%80-Python/",
        "teaser": null
      },{
        "title": "[Daily Contents] 발표회 tip 정리",
        "excerpt":"    발표회 tip      로그인, 회원가입 등 다른 팀이 다 한 거는 간단하게 넘어가기   프로젝트에서 기술이 매우 중요하면 설명해야 하나 간단하게만 해야 함, 깊게 기술 얘기하지 말 것            개발자 컨퍼런스는 기술에 대해 다루는 곳이므로 다름       면접관이 기술에 대해 물어봤을 때는 깊게 얘기해야 함           힘들었던 경험 얘기하지 말 것            ‘잠은 자고 했나요?’ 와 같은 질문이 들어오면 넋두리 얘기하기           기능을 주로 보여주고 홈페지이에 직접 들어가서 시연하는 것도 방법   중간 발표와 겹치는 부분은 간단하게 다룸   온라인에서 진행되므로 미리 연습 많이 하기   재치 있는 시연 + ucc 를 발표에서 보여주면 좋음   발표력이 높은 발표가 집중이 잘 되기 때문에 연습을 많이 하자!   bridge 멘트를 부드럽게 잘 준비하기 (이런 저희 프로젝트, 실제로 보고 싶지 않으신가요? 등)   대본 읽지 말 것(적어도 읽는 게 티나지 않게)  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EB%B0%9C%ED%91%9C%ED%9A%8C-tip-%EC%A0%95%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[Daily Contents] OWASP TOP 10, 시큐어 코딩 실습",
        "excerpt":"    Learning Goals   1. 시큐어코딩과 OWASP TOP 10의 의미를 알 수 있고 코드에 적용할 수 있다. 2. 해시 함수에 대해서 알 수 있다. 3. 실무에서 쓰이는 유용한 팁과, 하면 안 되는 보안 위배 코딩과 해결에 대해서 알 수 있다.   시큐어코딩? 상용화하려면 필수!   한국인터넷진흥원(KISA)에서 안전한 코드 인증   OWASP TOP 10   SQL Injection -&gt; 외부에서 들어오는 값은 검증하고 활용   시큐어코딩   ID, PS를 4~12자, 대소문자 활용 이유   의도치 않은 공격을 방지하기 위해 긴 문자열 금지, 브루트포싱 무차별 데이터 공격을 방지하기 위해 짧은 문자열 금지.   제약사항은 FE, BE에서 전부 구현 -&gt; FE는 사용자를, BE는 시스템을 위한 것.   Cryptography   암호화_복호화 가능   대칭키 암호화: AES, DES, ARIA, SEED...   비대칭키 암호화(공개키 암호화): RSA, ECC, EDCSA, DS(전자서명)   암호화_복호화 불가능(단방향 암호화)(해시 함수)   SHA256, keccak256, RIPEMD-160   복호화 불가능한 함수를 쓰는 이유: 검증 ex) 비밀번호 찾기의 경우 비밀번호를 새로 입력받는 경우   SECURE CODING           스트링 비교 시 string.equals(“”) 대신에 ““.equals(string) 사용 ex) request.getCheckType().equals(anObject: “business”)) -&gt; “business”.equals(request.getCheckType()) -&gt; Null Exception 방지            @RequestBody 바인딩 되는 부분을 JPA Entity 객체로 받으면 안 됨 ex) @RequestBody User request -&gt; @RequestBody Map&lt;String, Object&gt; request String email = request.get(key: “email”).toString();       SUMMARY $ QUIZ      OWASP TOP 10의 취약점 1위로서 시스템 DB에 쿼리문을 주입하는 방법으로 SQL Injection이라고 한다.   복호화 불가능(단방향) 암호화에 쓰이는 SHA256이나 keccak256를 해시함수라고 한다.   평문 문자열 값을 해시암호화한 값은 salt에 따라서 결과가 달라질 수도 있다. (X)   다음 중 변수 String 타입의 id 값이 null이어도 에러가 나지 않는 구문은? “TESTID”.equals(id)   동형암호는 4세대 암호라 부르며 데이터를 암호화한 채로 연산할 수 있는 암호화 기법으로서, 평문을 암호화한 것에 연산을 한 결과와, 평문에 연산을 하여 암호화한 것이 같은 것을 말한다. E(m1) + E(m2) = E(m1 + m2) E(m1) _ E(m2) = E(m1 _ m2)   Q. 아스키코드로 특수문자 넣을 수 있는지? A. 넣을 수 있음.   Q. 현업에서의 방어 기법은? A. 소나큐브 등 정적 분석 툴을 활용하여 일정 점수 이상을 받지 못하면 빌드 불가.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/OWASP-TOP-10,-%EC%8B%9C%ED%81%90%EC%96%B4-%EC%BD%94%EB%94%A9-%EC%8B%A4%EC%8A%B5/",
        "teaser": null
      },{
        "title": "[Daily Contents] CPU 구조",
        "excerpt":"    CPU 구조   캄퓨터 구조      CPU : 연산을 하는 장치(Intell, AMD…)   Memory : 데이터를 보관하는 장치(Samsung, SK 등…)        I/O : 입출력 장치(ketboard, Graphic, Printer, MIC 등등…)              위의 장치들은 Address, Data, Control(Read, Write, INT, DMA..) 등의 호스로 연결                위의 호스들은 Mainboard라는 장치가 제공              Osciilator : 발진기 » 압력을 가하게 되면 진동을 하고, Clock이라는 주파수 생성 » 그 주파수를 CPU, Memory, I/O 등에 공급           Clock : 0, 1로 상태 변화   CPU   Unit   2's complementer controller shifter ALU(arithmetic logic unit)   Register   MAR, MBR, IR, PC, AC, SP   Cache   Memory는 CPU에 비하면 아주 속도가 느린 장치 CPU에서 데이터를 가져오려고 하면, 오래 기다려야 하는 현상(병목 현상)이 발생하기 때문에 그것을 완화해 주기 위해 존재   L1, L2   ALU(arithmetic logic unit)   NOT   0 -&gt; 1 1 -&gt; 0   AND   0 0 -&gt; 0 0 1 -&gt; 0 1 0 -&gt; 0 1 1 -&gt; 1   NAND   0 0 -&gt; 1 0 1 -&gt; 1 1 0 -&gt; 1 1 1 -&gt; 0   OR   0 0 -&gt; 0 0 1 -&gt; 1 1 0 -&gt; 1 1 1 -&gt; 1   NOR   0 0 -&gt; 1 0 1 -&gt; 0 1 0 -&gt; 0 1 1 -&gt; 0   XOR   0 0 -&gt; 0 0 1 -&gt; 1 1 0 -&gt; 1 1 1 -&gt; 0   XNOR   0 0 -&gt; 1 0 1 -&gt; 0 1 0 -&gt; 0 1 1 -&gt; 1   산술논리장치(ALU)   A (Op) B =&gt; Out   Opcode : 00, 01, 10, 11 Mnemonic : ADD, AND, OR, XOR   가산기   최하위 비트 LSB, 최상위 비트 MSB 하나의 가산기는 1비트 가산기고, 64비트 가산기는 1비트 가산기가 64개 모인 것.   감산기   A (Op) (-B) =&gt; Out      2의 보수로 -B를 만들 수 있다.   비트열을 반전시킨 후 +1하면 2의 보수를 만들 수 있다.   곱셈기   비트를 한 칸 왼쪽으로 이동 : 2를 곱함 비트를 한 칸 오른쪽으로 이동 : 2를 나눔   나눗셈기   ex) 11 / 2 = 5, 11 % 2 = 1 » 1011 / 0010 = 0101, 1011 % 0010 = 0001  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/CPU%EA%B5%AC%EC%A1%B0/",
        "teaser": null
      },{
        "title": "[Daily Contents] 회고 방법",
        "excerpt":"    [1] 회고의 필요성      내가 하는 일과 지금 달성하고자 하는 것을 잊지 않도록 해준다.      맺음            마침표를 찍음으로써 다시 시작하고 복기할 수 있는 제공           나의 상태 확인            목표하는 것이 무엇인지 다시 확인       우리가 한 일들이 목표에 부합하는지 확인       앞으로 어떤 일을 해야 목표를 달성할 것인지 확인           행동의 명확성(제일 중요)            Action Item을 만들고 실행 여부를 다음 회고에서 확인                    우리가 어떻게 업무를 해야 하는지           어떤 행동을 통해 개선할 수 있을지           지속적으로 행하지 못했던 것은 무엇이 있는지                           [2] SMART      S: Specific (구체적)   M: Measurable (측정 가능한), 수치나 지표   A: Achivable (달성 가능), 역량 안에 있는 action item을 만들어야 한다.   R: Realistic (현실적)   T: Time-bound (기한이 정해짐)   [3] 지양해야 할 방식      목적이 불분명한 회고   마녀사냥형 회고   [4] 회고의 방법론      KTP(Keep, Proble, Try)     짧은 시간에 모든 구성원의 생각을 공유하고, 실행 가능한 Action Item을 도출       Keep            현재 만족하고 있는 부분       계속 이어갔으면 하는 부분           Problem            불편하게 느끼는 부분       개선이 필요하다고 생각되는 부분           Try            Probem에 대한 해결책       다음 회고 때 판별 가능한 것       당장 실행가능한 것           예시           Keep              Jira 스프린트 종료 후 프로젝트 구성원들이 돌아가며 피드백 했던 것       컨벤션을 상세화해서 가독성을 높인 것       서로의 코드를 리뷰해왔던 과정       주석을 통해 코드를 설명해준 것                Problem                       아쉬웠던 점을 기반으로 앞으로 프로젝트를 진행할 때 개선해야 할 사항         단순히 일어난 사건 뿐 아니라, 해당 결과에 이르기까지의 과정을 정리                         시간의 부족으로 자신의 영역 외에는 잘 모르고 지나친 것       커밋메시지를 모호하게 작성해서 히스토리 파악 난해       하드코딩이 많은 프로그래밍                Try                       Problem에서 도출된 해결책을 제시         다음 회고에서 판별 가능한 것으로 할 것         자신의 행동으로 제어 가능한 것으로 할 것         이번 회고가 끝난 직후, 실행 가능한 것으로 할 것                         깃에 리드미나 위키에 프로젝트 진행상황을 상세하게 기록하고 팀원들과 공유       커밋 메시지를 직관적으로 작성하기       이슈를 세분화해서 할당하고, 진행상황 공유하기       기능 구현에서 어려운 부분이 있으면 빠른 시간 내에 피드백 요청하기           KPT 회고 주의사항      구체적이고 실천 가능해야 한다.            좋은 예시                    Problem: 광고 상품이 추가되면 유관부서에 공유가 누락되어 데이터 정합성이 안 맞았다.           Try: 상품을 추가하는 코드가 호출되면, 유관담당자에게 자동발송하는 기능을 추가하자.                          ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%ED%9A%8C%EA%B3%A0-%EB%B0%A9%EB%B2%95/",
        "teaser": null
      },{
        "title": "[Daily Contents] 개발자의 성장",
        "excerpt":"    Learning Methodology           좋은 개발자가 되려면 끊임없이 공부를 해야한다!!              지금 좋은 개발자라고 해서 10년 뒤에도 좋은 개발자라고 할 수는 없음.                내가 모르는 분야여도 벽 너머의 분야들도 관심을 가지고 배우는 자세가 필요             (내 생각) 개발자가 공부가 중요하긴 하지만 어느 분야든 간에 꾸준히 공부하지 않으면 안 되는 것 같다.           Promise           주어진 업무를 주어진 시간 안에 약속된 퀄리티로 전달하는 것       내가 지킬 수 있는 약속이 어느정도인지 범위를 파악   남들이 나한테 기대하는 기대의 정도 (나 또한 남들에게 올바른 기대를 걸도록 노력해야 함)   약속을 맞추기 위한 나의 노력   내가 할 수 없는 약속을 거절하는 능력도 중요   Expectation      협업을 할 때는 그 사람이 지금까지 해왔던 일, background를 어느 정도 파악해놓으면 효율적이다.   Forecasting / Resource      내가 해본 적 없는 일의 계획을 세우는 건 힘들지만, 그래도 해야 한다. 이걸 잘 하는 게 중요하다.   배우거나 경험을 통해 예측을 늘릴 수 있다.   예측이 어려운 부분의 리스크를 파악하고, 최대한 정량화   Explanation           만약 계획에 변경이 필요할 때 다른 사람들의 계획과 충돌할 수 있으므로 혼자 끙끙 앓지 말고 동료들과의 공유가 중요            계획은 무조건 길게 짜는 게 좋을까?              지금 내가 할 수 있는 일들은 디테일하게.       다른 사람들의 계획이랑 얼마나 연관되어 있을까?                내가 성과를 만들어 냈다면 알리는 게 중요!             내가 성과를 냈다고 해서 주변에서 다 알아주지 않는다. 성과를 알아봐줄 수 있는 사람에게 가서 얘기하기                    쑥스럽거나 부끄러워도 내가 한 일은 내가 알려야 한다.           내가 잘한 일이 있을 때, 누군가에가 내가 잘했음을 설명하는 자료를 만드는 시간을 아끼지 마세요!                           Product      개발자는 어떤 제품을 만드는 지도 중요        개발자로서 빠르게 성장하려면? 그 회사의 핵심, 주력 제품을 개발해보는 것            1위 기업 vs 후발주자 스타트업              없는 마켓을 개척하는 경우가 아니면 역량을 기르기 위해서는 선두하는 기업에 가는 게 좋을 수도       대신 스타트업에서는 폭발적인 성장이 가능           규모가 큰 기업에서 주력/원하는 프로젝트를 맡지 못했을 경우 어떻게 할까?            팀 이동을 위해 노력하는 사람들이 많다.       핵심 부서가 아니더라도 부서가 성장해서 폭발적인 성장을 하는 경우도           Algorithm           알고리즘 공부로 얻어야 하는 통찰              문제에 대해 논리적으로 접근할 수 있는 사고력       ↑를 바탕으로 직접 손으로 구현하는 능력           너무 라이브러리에 의존해서 개발하지 말자! (구현력 업)   우리가 풀이를 알고 있는 문제는 극히 일부. 세상에는 모르는 문제가 더 많다. 시행착오를 하면서 최적의 해를 찾아가는 과정이 중요한 거지, 알고리즘 문제를 풀 때 이 문제는 ㅇㅇ 유형! 하고 외우는 건 별로 도움이 되지 않는다.   현업에서는 정답이 아니라 특정 부분을 포기하고 시간 복잡도를 낮추거나 그런 방식도 많이 쓴다.   Hiring in Silicon Valley      실리콘밸리 개발자가 되는 법            미국에서 학교를 나온다 (취업 비자 얻기가 비교적 쉬움)       해외에 있는 지사에 있다가 본사로 간다       진짜진짜 뛰어나면 특별한 비자나 영주권을 따고 간다           한번 실리콘밸리에 가면 그 다음부터는 일자리가 많다.   English      개발자에게 영어 업무는 필수다.   영어 회화는 지금부터 최대한 빨리 하자   마치면서      배움의 방법론을 완성하는 게 좋은 개발자가 되는 데에 중요하다.   일정을 맞추는 게 정말 중요하다. 지킬 수 있는 약속만 하고 약속은 꼭 지키자.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EC%84%B1%EC%9E%A5-%EC%9D%B4%EB%8F%99%EC%A7%84/",
        "teaser": null
      },{
        "title": "[Daily Contents] 인공지능 Tech Talk",
        "excerpt":"    AI란?   감지하고 있는 것에 반응하여, 환경을 인지하고, 생각하며, 배우고, 행동을 취할 수 있는 컴퓨터 시스템      Sense : their environment   Think   Learn   Take Action   Automated intelligence : 수동적으로 진행한 업무 또는 인지 등의 자동화   Assisted intelligence : 인간이 더 빠르고 더 정확하게 업무를 수행하는 것을 돕는 역할   Augmented intelligence : 더 나은 의사결정에 도움을 주는 역할   Autonomous intelligence : 인간의 개입이 없는 의사 결정 프로세스의 자동화     학습 자료 : Big Data 학습 방법 : Machine Learning Technique 자동화/관리 : Automation &amp; Management   어린 아이에게 한글을 가르치는 과정   학습 자료 : 교재      정제되지 않은 데이터 » 데이터 정제 » 학습 데이터   인공지능 관점            무의미한 데이터의 제거(Noise 제거) ex) 텍스트 내의 특수 기호, 광고 글, 무의미한 링크 등       학습하기 위한 형태로의 변경 ex) 문서 내에서 문장 단위 분리, 데이터 포맷 일원화 등       학습을 위한 Labeling 작업 ex) 고양이 사진, 개 사진, Sentiment문장, 그렇지 않은 문장 등           학습 방법 : 교육법      교재에 맞는 교육법, 교육법에 맞는 교재   인공지능 관점            영상 인식 &amp; 분류 방법 : Convolution Neural Network, Capsule Network       Sentence 분류 방법 : Recurrent Neural Network, Convolution Neural Network with Word2Vec       시계열 예측 방법 : Long Short-Term Neural Network           자동화/관리 : 스스로 공부하는 습관      인공지능 관점            학습 데이터 수동/자동 생성 : 데이터 전처리&amp;정제       학습 스케쥴링에 의한 자동 학습 : 데이터 추가 학습       학습 모델 LifeCycle 관리 : 모델 배포 및 업그레이드           사람처럼 행동하도록 만들어진 장치 또는 소프트웨어   인공지능에 대한 기대      시간 효율성 : 사람보다 훨씬 빠르게 분석해서 결과를 도출, 대량의 데이터를 핸들링   비용 효율성 : 여러 사람이 해야 할 일을 기계가 처리, 24시간 365일 업무를 수행   객관성 유지 : 항상 같은 기준으로 분석/판단을 수행   진화 : 인간이 미처 발견하지 못한 데이터의 특성 인지   과거와 현재      1956            인공지능 초기 : 엘런 튜링(튜링 테스트와 튜링머신 고안)           1960~1980            1차 인공지능 붐 : 규칙 기반 자동 판정 프로그램, 추론엔진, 전문가 시스템의 등장           1980~2000            2차 인공지능 붐 : 연산속도의 비약적 발전, 무어의 법칙의 현실화, 퍼셉트론의 다중화, 오차역전파법 개발(신경망 연구의 발전)           2000~2010            기술의 발전기 : 통계기반 머신러닝 분산처리 기술, 딥러닝 시대의 도래(AutoEncoder, Deep Nueral Network)           2010~            3차 인공지능 붐 : 딥러닝 기반 이미지 인식 성능 향상(AlexNet, Convolutional Neural Network)           AI에 대한 Question   가르치는 관점      아이가 학습하는 과정을 이해 : 사고하고 배우는 과정의 원래를 이해, 아이가 학습한 결과를 설명하는 원인 요소를 파악   적은 양의 교재 &amp; 짧은 학습 시간   학습 효율을 높일 수 있는 효과적인 방법 : 성능 개선   개발한 학습법을 다른 영역을 가르칠 때 재활용 또는 효과적으로 적용할 수 있는 영역   선생님의 개입을 최소화하는 학습   학습법을 개발하기 위한 쉬운 툴   스스로 학습하여 발전(진화)할 수 있는 방법   인공지능 관점      학습하는 원리와 과정 이해            Deep Learning은 학습 과정을 알 수 없음       Deep Learning Model의 성능이 좋은 이유와 원인을 증명할 수 없음           적은 학습 데이터, 짧은 학습 시간            많은 양의 학습 데이터를 생성하는 시간과 인력이 필요       많은 양의 학습을 진행하려면 많은 Computing Power &amp; Resource가 필요           효과적인 학습 모델(학습 효율)            Deep Learning의 성능을 개선할 새로운 개념 및 신경망 이론이 필요           학습법의 재활용            한 영역에서 개발한 인공지능 모델을 다른 영역에 적용하여 개발 효율을 높임       효과적으로 적용할 수 있는 분야 또는 영역           전문가의 개입 최소화            인간의 개입을 최소화하는 인공지능 모델 필요           학습법을 개발하기 위한 쉬운 틀            인공지능 모델을 개발하기 위한 쉽고 편리한 소프트웨어 개발 틀 및 개념           스스로 학습            AI Tool의 민주화       AI 모델 개발 과정을 Programming 지식 없이도 수행할 수 있도록 하는 Platform이 필요       학습 자동화 툴           CNN의 기본 구성   Convolution Filer : 다양한 특징을 생성 Pooling : 특징 중 강한 특징들을 살리면서 차원을 축소 Relu : Activation Function - 불필요한 Feature를 제거하는 역할 Fully Connected : Classification 결정 이전에 Feature들을 재조합하는 연산 Softmax : 확률 값을 내어 보내어 다양한 값을 분류하기 위함   BERT(AI 관련기술, 구글의 베이스 모델)   BERT의 설계 의도   Pre-training      MLM(Masked Language Model)            MaskedToken에 대한 정답을 찾는 Task           NSP(Next Sentence Classfication)            두 개의 문장이 연속된 문장인지 판별하는 Taskv           Fine-Tuning      Sentence Pair Classification Tasks   Single Sentence Classification Tasks   Question Answering Tasks   Single Sentence Tagging Tasks   BERT 모델 Architecture      Multi-layer bidirectional Transformer encoder   BERTbase   BERTlarge   Input/Output Representation   Pre-training      CLS : sequence의 시작을 나타내는 첫번째 토큰   SEP : 두 sentence를 구별하는 토큰   C : CLS 토큰에 해당하는 마지막 hidden vector   $T_N$ : N번째 토큰에 해당하는 마지막 hidden vector   Token embedding : WordPiece embeddings(3만 토큰 사전)   Segment embedding : 문장의 앞뒤를 구분   Position embedding : 토큰의 위치 정보를 포함   AI 기반 외환거래 자동 점검 솔루션 구축 사례에서의 개체명 인식 엔진의 활용   개체명 인식 모델의 학습 / 적용 / 검증을 위한 절차           수행 절차              로그 데이터 전처리 » 데이터 Annotation » 개체명 인식 모델 학습 » 정보 추출           단계별 수행 업무            개체명 인식 수행을 위한 로그 데이터 전처리 수행       인공지능 모델 학습을 위해 개체명에 해당하는 단어의 Category와 위치 정보 생성       Category와 위치 정보를 활용한 로그 데이터를 이용하여 개체명 인식 모델 학습 수행       문자열 로그 데이터의 개체명 인식 결과 추출           성능 측정            Category 정확도 : 추출한 개체명의 카테고리 정보가 원본 데이터의 카테고리 정보와 일치하는 항목 수 확인       위치 추출 정확도 : 추출한 개체명의 위치 정보가 원본 데이터의 위치 정보와 일치하는 항목 수 확인           개체명 인식 모델 성능 검증 결과      개체명 인식 모델 성능 : F1 score 93.15   개체명 인식 모델 카테고리 별 성능 : 평균 성능 93.07%  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5-Tech-Talk/",
        "teaser": null
      },{
        "title": "[Daily Contents] 빅데이터 KNN",
        "excerpt":"    KNN   새로운 데이터가 주어졌을 때 기존 데이터 가운데 가장 가까운 K개 이웃의 정보로 새로운 데이터 예측      (가)                          탕수육       초밥       짜장면                       마이콜       2       8       1                 길동       7       2       9                 사오정       8       1       7                 팔계       1       9       1                 오공       9       2       9                 둘리       1       8       2              (나)                          탕수육       초밥       짜장면                       희동       9       1       ??           (가)표를 바탕으로 (나)표의 ?? 칸에 들어갈 데이터를 예측하는 것이 KNN      희동과 음식 취향이 닮은 유저의 데이터를 기반으로 ?? 칸 예측   탕수육, 초밥 데이터를 기반으로 희동과 닮은 음식 취향 유저 추출   해당 유저의 짜장면 데이터들로부터 {평균 혹은 빈도수}를 희동의 짜장면 데이터로 예측   KNN   S1 : 모든 User 데이터와의 거리 계산   S2 : 가까운 거리에 있는 K개의 User 데이터 찾기   S3 : 평균, 빈도 등으로 아이템 선호도 예측     https://github.com/sweetchild222/vanilla-algorithm     k = 3 user = [9, 1, 0] neighbor_list = [ \t[2, 8, 1],     [7, 2, 9],     [8, 1, 7],     [1, 9, 1],     [9, 2, 9],     [1, 8, 2]]  prediction = predict(user, neighbor_list, k)  print('Predict %f', % (prediction))   def predict(user, neighbot_list, k): \tk_near_neighbors = get_neighbors(user, neighbors_list, k)      predict_candidate = [row[-1] for row k_near_neighbors]     print('predict_candidate : ', predict_candidate)     prediction = max(set(predict_candidate), key=predict_candidate.count)     return prediction   def predict(user, neighbot_list, k): \tdistances = list()     for neighbor in neighbor_list:     \tdist = euclidean_distance(user, neighbor)         distance.append((neighbor, dist))     distances.sort(key=lambda tup: tup[1])      print('neighbors distance : ', distances)      near_neighbors = list()     for i in range(k)     \tnear_neighbors.appned(distances[i][0])      print('near neighbors : ', near_neighbors)      return near_neighbors   def euclidean_distance(user, neighbor): \tdistance = 0.0     for i in range(len(user)-1):     \tdistance += (user[i] - neighbor[i])**2     return sqrt(distance)   KNN_Similarity Distance Measure   https://dbrang.tistory.com/1201   Q&amp;A   Q. K가 하나 멀리 떨어져 있을 때는 좋지 않을 듯하다. A. 좋지 않다. 그런 것은 Noise가 많이 낀 데이터라고 한다.    그럴 경우 Pre-processing을 거쳐서 Noise를 사전에 제거하는 것 또한 방법.   Q. Euclidean Distance와 Cosine Similarity, Manhattan distance 등과의 차이는? A. 거리를 재는 방식은 여럿 있고, 위의 예시 외에도 더 있을 수 있다.   Q. 2차원으로 표현되어 간편한데 3, 4차원으로까지 쓰는 경우가 많이 있는가. A. 3, 4차원, 5차원, 10차원 등 많다. 오히려 2차원인 경우가 적다.   Q. 새로운 데이터가 들어올 때마다 새로 계산해야 하는가? A. 그렇다.   Q. 데이터 간의 비 수치적 교사성도 점수를 주는 것이 나은가? A. 수치여야 알고리즘에 적용이 가능.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0-KNN/",
        "teaser": null
      },{
        "title": "[Daily Contents] 블록체인 명세서 이해 향상",
        "excerpt":"    명세서 활용법   블록체인 프로젝트는 Sub1, Sub2, Sub3으로 진행할수록 뼈대에 기능이 점차 덧붙여지는 애자일 프로젝트      목차, 프로젝트 개요, 프로젝트 목표를 훑어 전체 구성 파악   과제 명세에 프로젝트 별 구현 범위 표시   명세서를 읽으며 공식 문서 참고(공식이 아닌 문서에는 틀린 정보, 과거에는 옳았어도 현재는 틀리게 된 정보 등이 혼재되어 있으므로 공식 문서 권장)   프로젝트 소개   P2P 거래(중개자 없는 전자 상거래 시스템)   플랫폼의 개입을 최소화한 오픈 마켓 서비스   FE - 이더리움 // BE - 이더리움 간 연동 기술   특징      누구나 전자 상거래의 판매자와 구매자가 될 수 있다.   서비스 토큰으로 거래를 진행   주요 기능은 스마트 컨트랙트를 통해 구현            판매 상품 등록       에스크로 기능       구매 이력 기능           전체 아키텍쳐   블록체인 - FE - BE   기술스택   Blockchain      GO-Ethereum : 이더리움 클라이언트 SW   Solidity : 스마트 컨트랙트 개발 언어   solcjs : 솔리디티 컴파일러   Remix IDE : 브라우저 스마트 컨트랙트 통합 개발 환경   FE      Vue.js/Vue CLI : JS 프레임워크 및 툴   web3.js : JS 이더리움 APIs   BE      Java Spring : Java 프레임워크   MySQL : 관계형 데이터베이스   Docker : 컨테이너 솔루션   etc.      VirtualBox : 가상화 솔루션   Vagrant : 프로비저닝 툴   MetaMask : 블록체인 지갑   PJT 주요 과제   Sub1. 블록체인 네트워크 구축 및 활용   Sub2. 지갑 기능, ERC-20 구현   Sub3. 상품 등록 기능 구현, 에스크로 기능 구현, 구매 이력 관리 구현   디지털 화폐   탈중앙형 NFT 거래 플랫폼   OpenSea와 유사한 NFT 거래 플랫폼 구축   특징      표준을 준수하는 Non-Fungible Token을 구현   플랫폼을 통해 디지털 Asset을 NFT화 하고 거래할 수 있다.   전체 아키텍쳐   블록체인 - FE - BE   기술스택   Blockchain      Besu : 이더리움 클라이언트 SW   Solidity : 스마트 컨트랙트 개발 언어   Truffle : 스마트 컨트랙트 프레임워크   MetaMask : 블록체인 지갑   Remix IDE : 브라우저 스마트 컨트랙트 통합 개발 환경   Filesystem      IPFS : Inter-Planetary File System 분산형 파일 시스템(Peer-to-Peer Filesystem)   FE      React : JS 프레임워크   web3.js : JS 이더리움 APIs   BE      Node.js : JS Runtime   MySQL : 관계형 데이터베이스   Docker : 컨테이너 솔루션   PJT 주요 과제   Sub1. ERC-721 구현 및 테스트   Sub2. NFT Minting 및 조회   Sub3. NFT 거래 기능   프로젝트 주안점      BE는 거들 뿐… Web 3.0 프로젝트   블록체인 관련 기술에 초점            지갑과 Cryptocurrency의 개념 이해       스마트 컨트랙트 구현 이해도 높이기                    표준에 맞게 구현하기(ERC-20, ERC-721)           컨트랙트 상속, 호출                       블록체인과 상호작용하기(Web3 API 사용하기)           끊임없이 질문 : 호출할 때마다의 비용 문제, 블록체인에 꼭 넣어야 할 데이터는 무엇?? 또한 오픈이 되어도 상관없는 데이터.   FAQ   Solidity 공부 팁 : 공식 문서, 스마트 컨트랙트 기술을 사용하는 회사의 Github 오픈소스, crypto zombie의 게임으로 학습   Q&amp;A   Q. Dapp에서 이더리움에 배포된 스마트 컨트랙트와 데이터를 주고받기 위해서는 ABI가 필수인지? A. 스마트 컨트랙트 주소는 고유값. 단 컨트랙트 안에 어떤 것을 호출해야 할지는 명시해야 함. 그것을 명시하기 위해 CA와 ABI가 필수.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%AA%85%EC%84%B8%EC%84%9C-%EC%9D%B4%ED%95%B4-%ED%96%A5%EC%83%81/",
        "teaser": null
      },{
        "title": "[Daily Contents] 모빌리티 명세서 읽는 법",
        "excerpt":"    스마트홈   시스템 아키텍쳐      ssafybridge : 내가 통신할 것(controller, perceptron…)과 simulator의 다리 역할을 해 주는 것.   스켈레톤 프로젝트 실행 예시           ROS 메세지 통신 노드 실행(Req 1 : 기능명세 1번) $ ros2 run sub1 publisher -&gt; ter 1 $ ros2 run sub1 subscriber -&gt; ter 2 // 하나의 터미널에서는 하나의 노드밖에 실행되지 않기 때문에 반드시 각각 실행시켜야 함. // *.bef 파일도 각각 실행시켜야 함.            controller(Req 2 : 기능명세 2번) 터틀봇 움직이기 : q 버튼을 눌러 AutoMode로 변경하면 터틀봇이 움직인다. $ ros2 run sub1 controller       센서 설정   Sensor IP : 127.0.0.1   DST IP : 127.0.0.1   IMU : 9091 / 9092   Lidar : 9093 / 9094   Camera : 1231 / 1232             perception(Req 3)   터틀봇에 카메라 장착 후 perception 노드 실행.            Hand control(Req 4)   Custom Map에서 Custom Object를 배치 후 Hand control 노드를 실행.            Odmetry를 이용한 상대경로 생성 및 경로 추종(Req 5)   IMU 센서 추가 세팅 후 odem 노드 실행.       Q. 로봇의 크기 변경 가능한가? A. 불가능.   자율주행   1부   RPS &lt;-&gt; Simulator   2부   인지(판단, 제어)   인지 데이터는 Simulator에서 정답값으로 제공   3부   사용자가 알고리즘으로 인지 단계를 구현   목표   위치인식, 정밀도로, 경로계획   경로 계획 -&gt; 경로 제작 -&gt; 경로 추정   개발 환경 구성   Windows[Ubuntu(VM), (MORAL Sim]   Ubuntu 내의 ROS로 MORAL Sim과 연결      MORAL Sim에서 GPS, IMU 센서를 받는다.   Ego Status, Object Status, Traffic Status에는 메세지가 있다.      gos_parser.py : GPS 센서에서 시뮬레이터 데이터를 코드로 받아옴.   gosimu_parser.py : GPS 데이터와 IMU 데이터를 받아옴. ROS data를 통해서 /Odometry 를 만듬.   tf_pub.py : /Odometry를 받음.   path_maker.py : /Odometry를 받고 Data Read를 함.   global_path_pub.py, local_path_pub.py, mgeo.py, mgeo_pub.py… 계속 이어짐.   velodity_planning.py, pid_control.py, pure_pursuit.py 가 번갈아 가며 고도화 하여 advanced_purepursuit.py가 되고, 그것을 다시 고도화하여 acc.py가 된다.   실행 결과      Sensor 메세지 GPS - parser ter 1. ROS Bridge 실행 ter 2. GPS_parser 실행(simulator에서 GPS 연결)   Sensor 메세지 GPSIMU - parser IMU 센서를 연결하여 GPSIMU 데이터 파싱해서 뿌림. 시뮬레이터에 적용하여 사용하기 위해서는 UTM 변환된 GPS 값에 오프셋 값을 빼 주어야 함. 시뮬레이터의 좌표계 영점을 맞추기 위해(원점을 맞추기 위해) 오프셋 적용. Real World와 simulator의 좌표가 동일하게 됨.   Ego 상태 TF 브로드캐스팅 기본적으로 TF 기능 제공, 직접 만들어보는 것이 목적이므로 사용하지 않음. ter 3. rgt 실행   MGeo : 좌표계 연습   Q&amp;A   Q. 런쳐 화면에서 패키지 리스트를 확인해 보면 현재 가능한 차량, 맵 이외에도 더 많은 것들이 존재하는데 사용 가능한지 여쭤보고 싶다. A. 여러 알고리즘을 적용하는데 적합한 맵이 있기에 처음 시도할 때는 그것을 활용하는 것이 좋다.   Q. loss를 활용하는데 loss2를 활용해서 window 환경으로 가져와서 실행할 수 있을지. A. 할 수는 있는데 난이도가 높음.   Q. 다익스트라에서 노드 사이의 거리를 비용을 설정하는 것으로 했는데 교통체증을 구현하기 위해서 코스트 실시간으로 변경하는 것이 가능할지. A. 교통 흐름을 생성하는 것 가능. 시물레이터에서 스폰 포인트 생성하여 차량을 물리적으로 만들 수도 있음. 알고리즘에서 사용하는 파라미터들도 바꿔가며 테스트해 보길.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EB%AA%A8%EB%B9%8C%EB%A6%AC%ED%8B%B0-%EB%AA%85%EC%84%B8%EC%84%9C-%EC%9D%BD%EB%8A%94-%EB%B2%95/",
        "teaser": null
      },{
        "title": "[Daily Contents] Data Flow",
        "excerpt":"    왜 알아야 하는가?   1. 더 좋은 개발자가 되기 위해 2. 보다 정확한 설계 / 개발을 하기 위해 3. 회의시간의 내용을 빠르게 이해 / 적용할 수 있기 위해 4. 개발기간을 단축하기 위해 5. 좋은 말 아무거나…      기획에 대한 명확한 분석이 되고 전체적인 그림을 이해해서 흐름을 정리하고 흐름의 조각들을 예측하여 어떻게 하면 더 좋은지 최적화에 대한 논의 등을 능숙하게 해내기 위하여   Data Flow란?   Presentation tier -&gt; Logic Tier, Application tier -&gt; Data tier -&gt; Logic Tier, Application tier -&gt; Presentation tier   Data Flow 개념’들’   Data Flow 개념 : Monolithic Architecture of Three Tier   Presentation Tier : \thttp://, socket.io, MQTT, Stomp, Galaxy 기기 등등… Logic Tier, Application Tier : \tNGINX, Docker, jenkins, kubernetes, JPA, MyBatis… Data Tier : elasticsearch   Data Flow 개념 : Micro Service Architecture   특징      DB n개 분할   Logic, Application Tier에 BFF, GW 포함.   RabbitMQ, kafka   Tip. Logic Tier, Application Tier : \t무중단 시스템으로 99.99% 동작할 때 1년에 52분 loss   Data Flow 개념 : DevOps   Application Tier &lt;-&gt; Data Tier 무한 루프, 무한 빌드   Data Flow 개념 : Decentralization(BlockChain)   Application Tier : BlockChain Network   Data Flow 개념 : Summary   상술한 것들 통합 + Security   Tip. HTTP : 중간 탈취 가능. Cert bot을 사용하여 HTTPS 적용. TLS-SSL, 구간 암호화 탈취가 가능한 구간에서는 암호화된 채로, 탈취가 불가능한 시점에 도달하면 복호화.   Tip. 포트번호 1 - 1024 : OS / 2000 - 65535 : SW   Tip. session : accestoken : 정상적인 사용자임을 검증하기 위해 매번 인증. JWT : 부하를 줄이기 위해 한 번만 인증.   (최소한 한번은 정확히 봐야 할) Web Architecture 101   부록 : Architect의 영역과 역할      Business Architecture of(EA) Enterprise Architect : 기획            System Architecture of (CA or GA) Chief or Global Architect : PM                    Application Archtecture of (AA) Application Architect           Data Architecture of (DA) Data Architect           Technical Architecture of (TA)                            Hardware Architecture of (TA) Technical Architect               Solution Architecture of (SA) Solution Architect                                                  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/Data-Flow/",
        "teaser": null
      },{
        "title": "[Daily Contents] 인공지능 기술 기반의 특화 PJT 기획",
        "excerpt":"    특화 PJT 기획에 AI 기반 기술 활용   인공지능 명세서 선택 팀(영상, 음성) BigData, BlockChain, 모빌리티 등 타 도메인 PJT에서 AI 기술 추가   Deep Learning      Training   Inference   인공지능 Dataset 공유      AI hub   Keggle   Teachable Machine   https://teachablemachine.withgoogle.com   누구나 머신러닝 모델을 쉽고 빠르고 간단하게 만들 수 있도록 제작된 웹 기반 도구   TensorFlow.js   https://www.tensorflow.org/js   자바스크립트 머신러닝 라이브러리   정리   인공지능의 모델을 만드는 Training과 모델을 사용하는 Inference 과정   AI Hub 및 인공지능/자율주행 데이터 셋 소개   Teachable Machine 소개   JavaScript 기반의 Machine Learning 라이브러리 TensorFlow.js 소개   자세 추정 모델 PoseNet을 활용한 PJT 시연    ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5-%EA%B8%B0%EC%88%A0-%EA%B8%B0%EB%B0%98%EC%9D%98-%ED%8A%B9%ED%99%94-PJT-%EA%B8%B0%ED%9A%8D/",
        "teaser": null
      },{
        "title": "[Daily Contents] 파이썬 데이터 분석",
        "excerpt":"    데이터 과학!   데이터의 분석과 활용이 개인과 조직의 새로운 힘이 되고 경쟁력이 되는 시대입니다. 데이터 사이언스는 데이터 수집, 큐레이션, 통계 분석과 기계학습 등의 다양한 기술과 지식을 활용하여 복잡한 데이터로부터 인사이트를 얻거나 지능화된 시스템을 구현하기 위한 모든 업무를 총칭.      소프트웨어 컴퓨터 공학(SW 개발, 기계학습, 데이터 사이언스)   수학 통계학(모델 연구, 기계학습, 데이터 사이언스)   도메인 및 절차 지식(SW 개발, 모델 연구, 데이터 사이언스)   데이터 과학의 툴셋   매우 많다. 단지 SSAFY 생활 중에 대체로 익힌다.   데이터 분석 프로세스   목표설정 &gt; 데이터 획득 &gt; 데이터 준비 &gt; 데이터 탐색 &gt; 모델링 및 구축 &gt; 발표 및 적용   개발자 입장(Python) : 수집(requests, BeautifulSoup, Scrapy) &gt; 처리(Database, SQLAlchemy, Pandas) &gt; 분석(Pandas, Numpy, Scipy) &gt; 적용(Matplotlib, Plot.ly)   Quiz   Q. 데이터 탐색 과정의 일부로서 시각화, 통계 분석, 간단한 모델링 등을 이용해 데이터를 다양한 각도에서 관찰하고 이해하는 과정을 뜻하는 말은? A. 탐색적 데이터 분석, EDA(Exploratory Data Analysis)  Q. Jupyter라는 이름은 3개의 프로그래밍 언어에서 따왔다. 어떤 언어일까? A. J-Julia, P-Python, R-R   Jupyter Notebook      Jupyter = Ju(lia) + Pyt(on) + R   웹 기반 + 통합 개발 환경 + 인터랙티브   노트북 = 문서(마크다운) + 코드 + 시각화 + 수식 표현            실행되는 문서!!           IPython에서 시작(2014년)   데이터 과학 분야의 표준 도구(De Facto)   코드 작성과 실행, 출력 보기, 시각화 출력   Jupyter Notebook에서 할 수 있는 것들      마크다운으로 문서화를 할 수 있다.   Python 등 코드를 실행하고 결과를 확인할 수 있다.            REPL(Read Evaluate Print Loop), Interactive, 대화형 콘솔           노트북 도움말 : h,   API 도움 받기 : help(), ?, ??   자동완성 : TAB   Tool Tip : Shift + tab   Magic 명령어 : % 또는 %%, %magic, %load, %run, %history, %Ismagic…   시각화 자료를 통합할 수 있다.   수식 표현이 가능하다.            $, $$ : LaTeX       \\begin, \\end           쉘을 실행할 수 있다.            쉘에서!       또는 터미널 실행창 열기(New -&gt; Terminal)                만들어진 노트북으로 슬라이드쇼를 할 수 있다.              html로 저장 : jupyter nbconvert some-notebook.ipynb –to slides       웹 서버로 실행 : jupyter nbconvert some-notebook.ipynb –to slides –post serve       RISE : rise.readthedocs.io           어디에 쓸까?            데이터 분석과 개발 과정 전반에서 사용       개발 프로토타입을 만들 때       그냥 개발용으로(지원 언어 40+)           누가 쓸까?            데이터를 다루는 누구나!       개발과 기록을 한번에, 내보내기와 공유           Jupyter Notebook 시작하기      설치형            그냥 설치(Python, pip)       anaconda : 패키지 + 환경관리       docoker           서비스형            Google Colab       Kaggle       Cloud : AWS, GCP, Azure           목표 설정(기획)의 중요성      기획            40대 사원을 멘토로 붙이며 경영진과 여사원간의 회식을 정기적으로 열며 휴일에 사원들에게 스터디그룹과 회식을 시킴으로서 이직률 감소를 추구           결과            ???           결론 : 데이터 잘 구하자.   데이터 구하기      Raw Data : RDB, DW, Data Lake, File(CSV, log, txt, Excel), Service, …   Open Dataset, Open API   스크래핑   손맛   돈맛   Open Dataset, Open API      https://aihub.or.kr/   https://www.kaggle.com/   등등   스크래핑      파이썬으로 쉽고 편하게 스크래핑을 개발할 수 있다.   request, urllib3   scrapy   selenium   파싱 : BeautifulSoup, lxml, JSON   ‘데이터 크롤링의 세계’ 참고(0729 Live)   데이터 처리와 분석   데이터 과학의 80%는 데이터 클리닝에 소비되고, 나머지 20%는 그걸 불평하는데 쓰인다.      pandas + python + SciPy + NumPy   데이터를 불러오고            닦고 채우고 자우고 자르고 붙이고 돌리고 묶고 분류하고 계산하고 변형한 뒤           분석 저장하거나 다음 단계로 전달   pandas 유용   시각화(데이터 분석)      분석된 숫자가 있는데 왜 필요할까?        필요성 : 앤스컴 콰르텟              같은 데이터를 표현하더라도 어떤 기준을 잡느냐(평균, 표본분산, 상관관계 등)에 따라 그래프의 모양은 천차만별.       예뻐서 : 사람들이 이해하기 쉽게 전달하려고       EDA의 중요한 과정       데이터 탐색 : 데이터 이해, 트랜드와 패턴 파악, 특이값 찾아내기, 모델 선정       패턴을 인식하는 인간의 능력 활용하기       데이터 리터러시(데이터 문해력)       시각화 방법 선택 &gt; 다방면으로 살펴보기                데이터 시각화 형태 고르는 방법(없는 주소?)              https://brunch.co.kr/@joecool/148           How to Choose the Right Type of Chart for Your Message            https://education.microsoft.com/ko-kr/course/0a60eeb6/1           시각화      많이 사용하는 라이브러리들            matplotlib : 기본       seaborn : matplotlib 기반       plot.ly and ploy.ly express : Javascript, Interactive       Bokeh       Altair and vega       모두 Jupyter Notebook에서 사용 가능           개선하기      협업            nbconvert, nbviewer, binder : Publish           Jupyter Lab : 차세대 Notebook   성능            코드 : 프로파일링(%time, %timeit, %prun)       GPU 가속 : CUDA, cuDF       Clustering/parallelism : dask, vaex           JIT : PyPy, numba   Cloud            AWS SageMaker       GCP AI Platform       Azure ML Notebook       Jetbrains DataLore           Alt. Tool            VSCode도 노트북 지원       Jetbrains DataSpell           Closing      컨퍼런스/커뮤니티 : PyCon, PyData, JupyterCon   참조            (책) 파이썬 라이브러리를 활용한 데이터 분석       (책) 파이썬 데이터 사이언스 핸드북       (책) 밑바닥부터 시작하는 데이터 과학       (web) jupyterbook, kaggle, dacon, github, etc          ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D/",
        "teaser": null
      },{
        "title": "[Daily Contents] 블록체인 기본 개념과 작동 원리 소개",
        "excerpt":"    Learning Goals      BlockChain이 뭔지 알 수 있다.   암호 알고리즘에 대해 알 수 있다.   Blockchain 활용 어플리케이션을 알 수 있다.   BlockChain?!   BLOCK + CHAIN      데이터의 논리적 저장 단위 : Block   거래 내역을 담으면 비트코인, 실행 로직을 담으면 이더리움   위변조가 되면 안 되는 것들에 사용.   Chain           블록이 n번째 생성될 때 그 블록은 n-1번째 생성된 블록을 보증. 그렇게 엮여있다 해서 Chain이라 함.            Hash 함수를 통해서 보증.       Cryptography      복호화 가능, 복호화 불가능(단방향 암호화)으로 크게 두 분류.   해시 함수는 대표적인 복호화 불가능 암호            SHA256(블록체인에 사용), keccak256, RIPEMD-160       256은 비트.           Hash Function      복호화가 불가능한 암호 » 검증에 사용   해킹을 위해서는 브루트포싱 방식을 사용하여 가능한 모든 값을 대입해 봐야 하는데, 가장 빠르게 해도 300년 이상이 걸린다고 함.   Symmetric Encrytion      대칭키 암호화       암호화하는 키와 복호화하는 키의 알고리즘이 같은 암호   AES, ARIA, SEED   단점 : 키가 해킹되면 전부 해킹   Asymmetric Encrytion      공개키 암호화       공개키로 암호화를 하며 개인키로 복호화   개인키로 공개키를 만들 수 있으나 공개키로 개인키를 만들 수 없음.   소인수분해를 이용한 RSA   타원 곡선 함수를 이용한 ECC   DS(Digital Signature)      해시함수의 무결성 이용   누가 보냈는지 검사할 수 있고, 해시값을 송신자의 개인키로 암호화(서명)   수신자는 수신 후 송신자의 공개키로 복호화(검증)   삼성 블록체인 키스토어 : 갤럭시S10 이상부터 존재하는 개인정보 보호   단점 : 많은 비용, 긴 프로세스로 인한 느린 속도   BlockChain Network      블록체인은 P2P 네트워크망에서 작동   인터넷 위의 네트워크 망 : WWW, 어둠의 웹, P2P(대표적으로 소리바다, 토렌트)   P2P망에 접속하면 서버 클라이언트 구조가 아닌 노드라는 피어들이 있으며, 피어들끼리 정보를 공유   중앙에 서버를 두지 않고 노드들끼리 공유하기에 탈중앙화, 라고 불림.   How to Work      CPU : 코어 수 4~16개, 직렬 연산에 적합.   GPU : 코어 수 수백개, 병렬 연산에 적합.   Data in Block      블록 안의 값들을 변경해서 해시를 찾는다. 타임 스탬프 등을 변경해서 해시를 찾는데, 블록에 미리 제한된 난이도보다 적게 나오면 채굴에 성공했다고 하며 이의 증명으로 블록을 제한할 수 있음.       하나의 정보를 해킹하기 위해서는 해당 정보와 연관된 모든 루트의 해시 함수들을 전부 해킹해야 하기에 학문적으로 불가능에 가깝다, 라고 함.    Applications   결제      속도가 느리며 화폐 가치의 급락으로 인하여 실용성에 의문   구글 플레이스토어에 앱을 올리려고 할 때 구글 플레이스토어를 통하지 않는 결제 시스템은 등록이 되지 않기 때문에 불가.   데이터 Storage      암호화폐(송금 내역), 스마트 계약, 물류관리, 지역화폐, 문서관리, 의료정보관리, 저작권 관리, 한정판 디지털상품(NFT), 소설미디어관리, 게임아이템관리, 전자투표, 신원확인 등   위조가 되면 안 되는 사실을 기록   World Computing      P2P에 참여한 노드들은 모든 노드가 같은 연산을 하고 있다는 전제 하에 스마트 컨트랙을 배포해서 참여하는 모든 노드에 같은 조건의 명령어가 실행되고 같은 결과가 나온다는 원리   NFT(Non-Fungible Token)      고유성(Unique), 유일성(Only One), 희소성(A scarcity value)   Fully Decentralized vs Semi-Decentralized      각각의 장단점이 있기에 잘 알아보기.   Summary      블록체인은 보안성, 투명성, 무결성, 탈중앙화의 특징을 가지고 있고, 이 특징으로 여러가지 어플리케이션을 활용할 수 있다.   블록체인의 네트워크는 기본적으로 P2P 네트워크에서 작동한다.   암호화에는 복호화 가능 암호화, 단방향 암호화로 나눠지고, 단방향 암호화는 해시함수로, SCA256, keccack256 등이 있다.   암호화에 서명과 확인을 이용해 메세지의 무결성과 송신자를 보증하는 알고리즘을 전자서명이라고 한다.   이 ECC 암호화 알고리즘은 공개키 암호화로 타원 곡선 함수를 이용하여 암호화한다.   Q&amp;A   Q. 향후 양자컴퓨터의 발전으로 블록체인이 무력화된다는 이야기가 있는데 전망이 괜찮은지. A. 무력화까지는 자극적인 표현이며, 암호화의 필요성은 건재.   Q. 분산신원증명은 어떤 데이터를 저장하는지. A. 프로세스를 기존에서 변경한 것. 데이터를 저장한다기보다 내가 사용하는 디바이스만 인증이 가능하게끔 바뀐 형태.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC-%EC%86%8C%EA%B0%9C/",
        "teaser": null
      },{
        "title": "[Daily Contents] A star 알고리즘",
        "excerpt":"    MAP      S에서 E까지 가는 최단경로   - 평행 이동거리 : 10 - 대각선 이동거리 : 14 - 평행한 이웃 Node가 Block &gt;&gt; 대각선 방향으로 이동 X   Node 4-state   - Close : 가본 곳 - Open : 발견됨, 가 봐야 될 곳 - Empty : 미 발견됨, 안 가봄 - Block : 갈 수 없는 곳   Step   Step 1   S1 : 도착한 노드는 CLose state   Step 2   S2 : 주변 Node 탐색, State에 따라   - EMPTY =&gt; OPEN state - BLOCK =&gt; Nothing(대각선 Node 포함) - CLOSE =&gt; Nothing - OPEN =&gt; -G 값이 작다 =&gt; 부모 Node 바꿈 \t\t  -G 값이 크다 =&gt; Nothings   Step 3   S3 : Open Node 중, 최소 F값 Node로 이동   - G : 출발지에서 이동한 거리 - H : 도착지까지 남은 거리 =&gt; 멘하튼 Distance 방식, 직교하는 거리 - F = G + H   Step 1~3      반복하여 수행   도착 Node를 찾으면 Success   Failed Case      반복해도 Open Node는 줄어들고 Close Node만 많아지다가 모든 노드가 Close Node로 바뀐 후 Fail   Source URL      https://github.com/sweetchild222/vanilla-algorithm   data = [ \t0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, -1, 0, 0, 0,     0, 0, 0, 0, -1, 0, 0, 0,     0, 0, 0, 0, -1, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0]  widrh = 8 height = 6  start = Point(2, 3) stop = Point(6, 3)  map = Map(data, width, height, stop) node = aStar(start, stop, map)  while node: \tprint(node.getPoint())     node = node.getParent()   (6, 3) (6, 2) (5, 1) (4, 1) (3, 1) (3, 2) (2, 3)   class State(Enum): \tEMPTY = 0     OPEN = 1     CLOSE = 2     BLOCK = 3  class Node: \tdef __init__(self, point, h):     \tself.state = State.EMPTY         self.point = point         self.h = h         self.parent = None   def aStar(start, stop, nodeMap): \topenList = OpenList()     node = map.getNode(start)     while True:     \tnode.setClose()         if node.getPoint() == stop:         \treturn node         childList = lookAround(node, nodeMap)         openList.append(childList)         node = openList.minCostFnode()         if node is None:         \treturn None      S1 : 도착한 Node는 Close state   S2 : 주변 Node 탐색, State에 따라…   S3 : Open Node 중, 최소 F값 Node로 이동   def lookAround(node, map):      childDelta = [Point(1, 0), Point(1, -1), Point(0, -1), Point(-1, -1),                  Point(-1, 0), Point(-1, 1), Point(0, 1), Point(1, 1)]      openList = []      for delta in childDelta:          childPoint = node.getPoint() + delta         childNode = map.getNode(childPoint)          if childNode is None:             continue          if neighborBlock(node, delta, map) is True:             continue          if childNode.isBlock():             continue         elif childNode.isClose():             continue         elif childNode.isEmpty():             childNode.setParent(node)             childNode.setOpen()             openList.append(childNode)         elif childNode.isOpen():             currentCostG = childNode.costG()             newCostG = childNode.calcCostG(node)             if currentCostG &gt; newCostG:                 childNode.setParent(node)         else:             print('error!')      return openList   S2 : 주변 Node 탐색, State에 따라   - EMPTY =&gt; OPEN state - BLOCK =&gt; Nothing(대각선 Node 포함) - CLOSE =&gt; Nothing - OPEN =&gt; -G 값이 작다 =&gt; 부모 Node 바꿈 \t\t  -G 값이 크다 =&gt; Nothings  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/A-star-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
        "teaser": null
      },{
        "title": "[Daily Contents] 셀레니움 활용하기",
        "excerpt":"    셀레니움이란?   셀레늄(소프트웨어)      셀레늄은 웹 애플리케이션 테스트를 위한 포터블 프레임워크이다. 셀레늄은 테스트 스크립트 언어를 학습할 필요 없이 기능 테스트를 만들기 위한 플레이백 도구를 제공한다.   웹에서 크롤링할 때 사용, 오픈 소스.   WebDriver, Language, bindings Java, C#, Python, Ruby, R, JavaScript   -&gt;   JSON Wire Protocol   -&gt;   Browser Drivers ChromeDriver, IEDriver, GeckoDriver, SafariDriver, HTMLDriver…   &lt;=&gt; HTTP over HTTP Server   Browsers Chrome, IE, Safari…   셀레니움 용도?      음식점 목록, 영화관 목록, 관광지 목록 등   이미지 자동 다운로드 등   기타 우리 프로젝트에 필요한 정보   자동 소송 프로그램   개발 설정   self.driver = webdriver.Chrome(ChromeDriverManager().install()) PATH = 'G:\\python\\selenium\\chromedriver.exe' options = webdriver.ChromeOptions() options.add_argument('--ignore-certificate-errors') options.add_argument('--ignore-ssl-errors') options.add_argument(\"start-maximized\") options.add_argument(\"disable-infobars\") options.add_argument(\"--disable-extensions\") options.add_experimental_option('excludeSwitches', ['enable-logging])   개발   ele = self.driver.find_element_by_id('userId1') check = ele.is_displayed()   if check : \tele.clear()     ele.click()     sleep(1)     for s in site_id:     \tif s == '2':         \tele.send_keys(Kets.NUMPAD2)         # elif s == '6':         #\tele.send_keys(Keys.NUMPAD6)         else:         \tele.send_keys(s)      숫자 2가 입력이 안 되는 현상에 NUMPAD로 입력   self.driver.find_element_by_id('btnLgn').click() sleep(1) elements = self.driver.find_elements_by_xpath('//*[@id=\"xwup_cert_table\"]/table/tbody/tr) elements[cert_index].click() sleep(1)   actions = ActionsChains(self.driver) ## 원고 입력 actions.move_to_element(hover).perform() self.driver.find_element_by_xpath('//*[@id=\"tmenu01\"]/div/ul/li[2]a').click() self.driver.find_element_by_xpath('//*[@id=\"tabDoc\"]/div[1]/ul/li[1]/a/img').click() self.driver.find_element_by_xpath('//*[@id=\"chkArgElcSo\"]').click() self.driver.find_element_by_xpath('//*[@id=\"btnDsSo\"]).click()   ## 법원선택 x = self.driver.find_element_by_xpath('//*[@id=\"cmbBubCd\"]') drop=Select(x) drop.select_by_visible_text(target_agency)   ## 피해금액 self.driver.switch_to_alert().accept() self.driver.find_element_by_xpath('//*[@id=\"soSogaAmt\"]').send_keys(money)   innorixst      보안으로 인하여 셀레니움으로 자료를 긁을 수 없을 경우   업그레이드 QML(디자인)   from PyQt5.QtCore import Qobject, pyqtSlot, pyqtSignal  class HomeFunctions(QObject): \tsignal = pyqtSignal()     def __init__(self):     QObject.__init__(self)      @pyqtSlot()     def changePage(self):     \tprint(\"Button was pressed\")     @pyqtSlot()     def cert(self, str):     \tprint(\"cert started\", str)   정리   수기로 적는 문서의 프로그램 자동화는 나름 블루오션. 단 위와 같은 법조계에 도움을 주는 자동화 시스템의 경우, 전국의 변호사가 10만명도 채 되지 않는다는 고객층 숫자 이슈가 있어 사업을 하고자 한다면 사전 조사 필수   IT계에서 직접 해 보는 것보다 이론적으로 행해지는 것이 많음 예를 들어 FE를 개발해 본 적이 없는 이들이 Vue가 우수한가 React가 우수한가로 논쟁을 펼치곤 함. IT에 종사하시는 분들은 이론으로 대결하지 말고 사람들에게 이로운 서비스를 제공하는 방향으로 개발하는 것이 올바른 방향이 아닐까.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%85%80%EB%A0%88%EB%8B%88%EC%9B%80-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Daily Contents] 한국어 데이터 전처리",
        "excerpt":"    자연어 처리(NLP)란 무엇인가?      사람이 이해하는 자연어를 컴퓨터가 이해할 수 있는 값으로 변환하는 과정   컴퓨터가 이해하는 값을 사람이 이해할 수 있도록 다시 바꾸는 과정까지 포함   한국어 자연어 처리가 어려운 이유      모호성            차를 마시러 공원에 가는 차 안에서 나는 그녀에게 차였다.       ??? 컴퓨터는 이해 못함           교착어, 고립어, 굴절어   교착어   어간과 어미가 명백하게 분리됨 하나의 형태소는 하나의 문법적인 기능을 함 한국어, 일본어, 터키어, 핀란드어, 헝가리어…   고립어   문법적인 형태를 나타내는 어미가 거의 없고 어순과 위치만으로 문법적인 형태를 나타냄 중국어, 태국어, 미얀마어, 티벳어   굴절어   단어의 활용 형태가 단어 자체의 변형으로 나타나는 언어로 어간과 접사가 쉽게 분리되지 않음 어휘 자체에 격, 품사 등을 나타내는 요소가 포함됨 인도어, 유럽어, 러시아어   영어는?   단어적으로 보면 굴절어 요소가 남아 있지만 문장으로 보면 고립어   한국어 자연어 처리가 어려운 이유      띄어쓰기가 지켜지지 않는다            한국어 : 띄어쓰기를하지않아도읽을수있습니다.       영어 : Youcanreadwithoutspacing           한국어는 교착어이다            ‘그’라는 단어 하나에도 ‘그가’, ‘그를’, ‘그와’, ‘그는’과 같이 다양한 조사가 ‘그’라는 글자 뒤에 띄어쓰기 없이 바로 붙게 됨       같은 단어임에도 서로 다른 조사가 붙어서 다른 단어로 인식이 되면 자연어 처리가 힘들고 번거로워지는 경우가 많음       어간에 접사가 붙어, 단어를 이루고 의미와 문법적 기능이 정해짐           같은 정보를 다르게 표현하기(Paraphrase)            문장 1 : 여자가 김치를 어떤 남자에게 집어 던지고 있다.       문장 2 : 여자가 어떤 남자에게 김치로 때리고 있다.       문장 3 : 여자가 김치로 싸대기를 날리고 있다.       문장 4 : 여자가 배추 김치 한 포기로 남자를 때리고 있다.       문장의 표현 방식이 다양, 비슷한 단어들이 존재           전처리는 왜 필요한가?      한글로 된 데이터를 크롤링 또는 오픈 데이터를 가져다 쓰려고 할 때, 띄어쓰기, 맞춤법이 틀린 것들도 많다. (한글의 맞춤법을 잘 지키지 않는 SNS 피드 데이터 등)   사소한 차이는 임베딩 벡터로 보면 큰 차이일 수 있다.            정제하지 않은 데이터와 정제된 데이터는 분석 결과에서 많은 차이를 보인다.       과연 원문만 넣고 제대로 분석이 가능할까?       비표준어, 맞춤법 무시, 특수문자, 이모지 등이 섞여있음       부정의 부정, 모호한 표현, 채널의 분리 필요           워드 임베딩??!!      워드 임베딩은 단어를 벡터로 표현하는 방법으로, 단어를 밀집 표현으로 변환   밀집 벡터를 워드 임베딩 과정을 통해 나온 결과라고 하여 임베딩 벡터라고도 함   워드 임베딩 방법론으로는 LSA, Word2Vec, FastText, Glove 등이 있음   전처리 방법   Basic Tokenize Spell Check Pos Tag Stemming Stopwords Replacing and Correcting Words      프로젝트에서 한글데이터를 다룬다면 한글 전처리 방법들을 숙지하고 있어야 한다.   1. Basic   기조적인 전처리 html tag 제거(크롤링한 html 원문 데이터일 경우) 숫자, 영어, 특수문자 등 필요하지 않은 언어 제거 Lowercasing 문장부호 제거 이모지 및 BMP 제거      기초 전처리는 데이터를 적재, 전송 등 다른 용도로 사용할 때에도 필요하다.   2. Tokenize   자연어 처리에서는 텍스트를 `토큰 단위`로 나눈다. 특히 한국어에서는 띄어쓰기는 문맥과 의미를 구분하는데 큰 영향 애초에 모든 공백을 없앤 후, 문맥에 따라 띄어 쓴 문장을 만드는 것이 좋은 방법   2-1. 띄어쓰기 방식   경계인식 방식 : 머신러닝을 이용한 문장 경계인식 * 다중 클래스 분류 모델, 다중 손실을 이용한 공동 학습모델   영역인식 방식 : 띄어쓰는 지점 주변 토큰의 영향을 고르게 받음   2-2. 문장 분리   영역 인식 방식 : 문장 분리의 경우 형태소 분석으로 종결어미를 구분, 문장의 CRF 결과로 판단하는 방법 등 한국어 문장분리 파이썬 라이브러리 kss, kiwi, koala, Baseline   정확도는 약간의 편차들이 있음   정확도도 중요하나 대량 데이터 처리 시 속도도 고려해야 함   3. Pos Tag(품사 태깅)   품사를 붙이는 행위를 PoS Tagging이라고 한다. 형태소 분석은 의미있는 가장 작은 단위의 말을 분석한다는 뜻 Pos Tagging 즉 품사 태깅 행위를 현업에서는 구분없이 동의어로 상당히 자주 사용함.   형태소 분석은 말 그대로 형태소를 분석하는 모든 행위를 하지만 `품사 태깅은 형태소의 품사를 붙이는 역할`까지만 함   Konlpy의 형태소 분석기 및, Khaiii 등 여러가지 분석기가 나와 있으며 컨텐츠에 따른 정확도를 확인하여 선택 영어는 NLTK는 자연어 처리 및 문서 분석용 파이썬 패키지 많이 사용   품사가 제대로 태깅이 되어야 양질의 분석이 가능하다.   최근의 ELMo와 BERT 같은 Contextualized Word Embedding 방법에서는 단어 주변의 문맥 정보를 전체적으로 사용하기 때문에, 주요 품사만 사용하는 방법은 효과가 안 좋을 수 있다.      POS Tagging을 사용해 주요 품사만 사용한 결과 값과 적용하지 않은 결과 값을 비교하는 작업이 필요하다.   4-1. Stemming   주어진 단어에서 핵심 의미를 담고 있는 부분을 찾는 과정 단어의 의미를 담고 있는 어간과 문법적 역할을 하는 접사를 분리하는 방식으로 동작 동사를 원형으로 복원한다.   4-2. Lemmatisation      주어진 단어의 사전적 어언을 찾는 과정   5. StopWords   갖고 있는 데이터에서 유의미한 단어 토큰만을 선별하기 위해서 큰 의미가 없는 단어 토큰을 제거하는 방법   6. 한국어 전처리 패키지      PyKoSpacing : 띄어쓰기 교정   Py-Hanspell : 네이버 한글 맞춤법 검사기        SOYNLP : 품사태깅, 단어 토큰화를 지원하는 단어 토크나이저       Customized KoNLPy : 영어는 띄어쓰기만 해도 단어가 잘 분리되나 한국어는 경우가 다르다.            형태소 분석기를 사용할 떄 이러한 상황을 극복하기 위해 하나의 해결책으로서 형태소 분석기에 사용자 사전을 추가       특정 도메인 업종, 특수 명칭 등을 사용하는 텍스트 분석에 유용           7. 실무에서 한국어 전처리      기존에 나와있는 라이브러리를 100% 활용하지는 앟음   내부에서 사용하는 용어, 동의어, 불용어 사전을 함께 운용해서 반영함.   신조어도 주기적으로 반영   AI 기반 확률적 전처리 방법에는 예외가 종종 발생하며 대량의 데이터 처리시 발생하는 처리속도 문제도 있음.   결론      한국어 전처리 하는데 어떤 방법들이 있는지, 예외가 발생하는 이유에 대한 이해가 있어야 분석의 정확도를 높일 수 있다.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%ED%95%9C%EA%B5%AD%EC%96%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%B2%98%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[Daily Contents] 블록체인 프로젝트의 구조 뜯어보기",
        "excerpt":"    어떤 체인을 사용할 것인가?           Private Chain            Public Chain             누구나 접근이 가능하며 진정한 의미의 탈중앙화라는 장점이 있음       데이터를 저장하는 것이 매우 비싸고, Transaction이 발생할 때마다 비용을 지불해야 함.       다소 복잡한 Smart Contract의 배포 비용(0.5ETH)       이더리움                    Middle man의 제거가 가능해짐           닷컴 버블 이후 가장 성장한 비즈니스는 광고 플랫폼 등 Middle man이 필요한 산업           Smart Contract은 바로 이 Middle man의 개입 없이 공정한 분배가 이루어질 수 있음                           오라클 문제      Oracle이란 블록체인 밖의 데이터를 블록체인 안(On-chain)으로 가져오는 것을 의미함.   비가 오면 John에게 10$를 주겠다 » 비가 왔다는 정보   주사위를 던져서 3보다 큰 수가 나오면 1$를 지불한다 » 코드로 구현 가능   10월 11일이 되면 이 빌딩의 소유권을 Paul에게 양도한다 » 10월 11일이 되었다는 정보   어떤 체인을 사용할 것인가      Private Chain은 DB에 준하는 빠른 속도   사전에 약속된 사용자만 참가 가능   주로 Hyperledger fabric을 사용   사용자가 인지할 수 없는 사이에 블록체인 활용 가능   전체 구조를 이해해보자   [FrontEnd] &lt;&lt;&lt;&gt;&gt;&gt; [Application Binary Interface] &lt;&lt;&lt;&gt;&gt;&gt; [Ethereum Network] &lt;&lt;&lt;&gt;&gt;&gt; [BackEnd(Spring), Wrapper Class]   메타마스크      쉽게 사용할 수 있는 크롬 익스텐션.   Key를 보관하고 서명을 안전하게 하는 역할을 한다.   Web3를 이용해서 쉽게 서명할 수 있다.   개발자는 추상화된 API를 이용해서 쉽게 개발 가능.   아 잘 모르겠고 우선 지갑이나 만들어볼까 할 때 학습.   프론트엔드에서 블록체인과 통신하는 법      Web3.js를 이용한다.   직접 private key를 이용해서 서명하는 것도 가능하지만 metamask와 같은 서비스를 이용하는 것이 안전.   다른 사람의 지갑 주소로 ETH를 전송하거나 Smart Contract과 통신해서 데이터를 받아오는 것도 가능.   ABI?      Application Binary Interface   API랑 좀 닮지 않았습니까?            API가 프로그램과 통신하기 위한 인터페이스라면 ABI는 Binary와 통신하기 위한 인터페이스           Binary 형태로 컴파일된 Smart Contract과 통신하기 위한 Interface   컴파일된 바이너리의 모습      문자열. 단, 0과 f로 표현된 영역이 많기에 해석하려면 해석할 수 있기는 함.   Human Readable한 형태      Json의 형태.   How to build? Use solc      solc 이외에도 truffle이라는 라이브러리를 활용   How to deploy?      bytecode와 ABI를 이용해서 deploy한다.   Remix가 있지 않나요?            개발 단계에서 배포할 수는 있으나 파이프라인을 구축해 놓은 뒤에 매번 수정하고 배포하는 것은 번거롭기에 Remix는 개발 때만 활용하는 것을 추천.           Payable modifier           가장 핵심적인 Modifier       이더리움에 깔려있는 전제가 하나 있다.   핵심 로직은 이더리움을 이용한 결제를 통해 발생한다.   이더리움이 스마트 컨트랙에 입금될 때의 로직을 만들고 싶다면?   payable modifier를 붙여준다면 구현 가능하다!   (이더리움) 모임 통장 만들기, 경매, 안전 거래 등등   대부분의 핵심 로직은 payable modifier를 이용해서 구현한다.   Q. 블록체인에 영상을 저장하고 싶어요.      이더리움의 블록 크기는 1~8MB 수준   여기에 영상을 저장할 수 있을까?   텍스트 형태의 데이터라도 200개 이상 저장하는 것이 어렵다   그렇다면 어떤 방법이 있을까?            일반적으로 파일을 정합성을 확인할 때는 해시값을 이용한다.       동영상의 해시값을 블록체인에 저장한다면?           이더리움 VS 자체 코인   화폐의 가치는 어떻게 결정되는가?      화폐의 가치는 그 화폐를 사람들이 얼마나 신용하는지에 따라서 결정된다.   코인의 가치 혹은 블록체인의 가치도 사람들의 신용도에 따라서 결정.   이더리움은 많은 사람들이 사용하기 때문에 신용도가 높고 가치도 높다.   우리가 만든 자체 코인은 자유도가 높지만 신용도는 매우 낮을 것.   하지만 사람들은 가치를 떠나서 그냥 받는 것을 좋아하기도 한다.   Wrapper Class?      Web3j를 이용해서 Smart Contract와 통신하기 위해서는 Wrapper Class를 생성해야 한다!   Compile된 Binary로부터 Wrapper Class를 생성함.   Compile된 Binary가 조금이라도 변경된다면 Wrapper Class를 다시 만들어야 한다.   주석, 공백을 포함해서 어떤 것이 바뀌어도 Wrapper Class는 다시 만들어야 한다.            Jenkins 같은 자동화된 빌드 도구를 사용하는 것이 좋은 방법           유저가 블록체인을 불편해 할 때?      서비스 제공자가 사용자 별로 키를 보관하고 관리해 줄 수 있다.   신규 유저가 생기면 지갑을 생성하고 보관한다.   로그인 인증을 통해서 유저를 확인하고 대신 서명을 해 준다.   일반적인 거래소들이 많이 활용하는 방법!   대부분의 유저들에게 블록체인을 이해시키기 어렵기 때문에 사용한다.   FE VS BE 어디서 처리할까?      완전한 탈중앙화를 추구한다면 FE에서 유저에게 서명하는 것이 옳다.   그러나 유저 입장에서는 블록체인에 익숙하지 않기 때문에 우리 서비스의 BE에서 대신 관리해주는 것도 가능하다.   구조를 설계할 때에 반드시 미리 결정해야 하는 부분이 이곳이다.   어떤 네트워크를 사용할 것인가?      SUB PJT1에 했던 것들이 무엇이었을까?   우리만 사용할 수 있는 Private Network를 구성한 것!   Infura와 같은 public하게 구성된 테스트넷들이 많이 있다.   실제로 이더리움 메인넷과 동일한 환경인 테스트넷을 사용하는 것이 가능하다.   실 서비스를 운영한다면 이더리움 메인넷에 배포해야 할 것.   Public network를 쓸 때의 장점      익스플로러를 지원. 디버깅이 편하다.   Q. BE에서 서명할 때 DB에서 개인키를 저장하는 것인가? A. 개인키는 DB에 저장, 한 번 더 암호화를 할 수는 있으나 DB가 털렸는데 암호화 키가 안전할 거라는 보장은 없음. 설계가 중요.   Q. BE에서 트랜잭션을 발생시키면 대리서명의 이슈는 어떻게 해결해야 하나요? A. 대리서명을 해 줄 수밖에 없음.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%9D%98-%EA%B5%AC%EC%A1%B0-%EB%9C%AF%EC%96%B4%EB%B3%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Daily Contents] 자율주행의 개요 및 현황",
        "excerpt":"    자율주행 개요      No 운전자 조작: 자동차 스스로   환경인식: 차량 도로 등 환경 인식   주행 경로 생성: 차량의 미래 이동 경로 생성   차량 주행: 조향, 가속, 제동 조작   역사      2010년 구글 자율주행차 발표   2015년 자율주행 2단계 상용화 시작(테슬라)   2020년 Level 3 가시화, Level 4 시범 서비스 강화(약속의 해, 약속 파기)   미래형 서비스에 대한 고려   알고리즘 요약   사람이 운전하는 것과 유사           카메라, 라이다 등의 센서 뿐만 아니라 차량의 정보와 교통 인프라 등을 수집해서 해석한 후에 어떤 경로로 가야 할 지, 속도를 높일 건지 줄일 건지 등의 판단을 통해 차량 제어       트롤리 딜레마: 자율주행에 대한 윤리적 고민   MIT Moral Machine 프로젝트: 딜레마 상황에서 자율주행차 인공지능의 윤리적 결정에 대한 사회적 인식 수집   자율주행 6단계           SAE(미국 자동차 공학회) 정의, 업계 표준       Level 0 - 비자동화   Level 1, 2 - 운전자 개입을 위해 항시 운전 주시 필요   Level 3 - 시스템 요청시 운전자 개입   Level 4 - 특정 구간에서 운전자 개입 불필요   Level 5 - 전 구간에서 운전자 개입 불필요   완성차 업체 및 IT 빅 테크 기업의 자율주행차 현황      기술적 측면            빅 테크 기업: 급진적 전략으로 Level 4 이상 자율주행 기술 개발       완성차 업체: 점진적 전략으로 Level 1부터 순차적으로 개발           제도적 측면            대부분 Level 2: 사용자 책임(테슬라 포함)       법적인 책임이 있는 Level 3 상용화 시작           주요 자율주행차 및 센서 시스템   상용화된 주요 자율주행차      부분 자율주행차 상용화   고속도로 한 차선 자율주행 수준            [ 제네시스 EQ900, 테슬라 모델5, 아우디 A8, 낫산 세레나, 벤츠 E350e ]           아우디 A8, 벤츠 E클래스 센서 사례      연구용 차량에는 라이다 많이 사용   실제 차량에는 라이다 제한적 사용(비용 문제)   Level 3 차량 라이다 탑재      2021년 혼다(5개), 벤츠 EQS(1개) 등 상용화   2022년 현대(2개), 볼보(장거리 라이다) 탑재 예정   테슬라 자율 주행용 센서 및 시스템      8개의 카메라            전방 3개                    FOV 50도 150m, FOV 35도 250m, FOV 150도 60m                       측면 2개 (B-필러)       후방 3개           1개 레이더   12개 초음파 센서   슈퍼 컴퓨터: 엔비디아 드라이브 PX2            Tegra 프로세서 _ 2, GPU _ 2       딥러닝 처리속도: 고성능 컴퓨터 150대 동시 처리 수준           테슬라      딥러닝 기반 인식 시스템   실 도로 주행 데이터 수집하여 인공지능 학습   쉐도우 모드: 자율주행 시능이 사용되지 않을 때에도 데이터 수집   FSD(Full Self-Driving)            V8, V9: 도심 자율주행       V10: 고도화, 스마트 써몬(Smart Summon)           자율주행 연구용/테스트 차량      고성능 라이다   정밀 GPS   고정밀 지도(HD 맵) - 위치 오차 20cm 이내   구글 5세대 자율주행 센서 시스템      라이다: 5개   카메라: 500m 표지판 인식   레이더: Image Radar   현대 loniq 5 Robotaxi(2021)      라이다: 5개   카메라: 13개   레이더: 12개   폭스바겐 I.D Buzz AD(2021)      라이다: 6개            장거리 라이다 1개(Argo AI, 1400m)       단거리 라이다 5개(Hesal, 900m)           카메라: 14개   레이더: 11개   고성능 자율주행 센서의 필요성   웨이모 보고서      라이다/카메라/레이더 조합   비/안개 등 악조건 인식 가능   밤/낮으로 인식 가능   보행자 돌발 상황 빠른 인식 가능   카메라/라이다는 안개에서 인식 어려움   안개에 사용 가능한 4D 이미징 레이더   4D 이미징 레이더      물체의 대략적인 모양 인식 가능   비/안개 등 악조건 인식 가능   300m 거리에서도 물체 인식 가능   2024년 상용화 예정(빠르면 내년에)   3D 초음파 센서      차량 근거리 환경 인식 중요   비/안개 등 악조건 인식 가능   근거리에서 라이다 센서 대체 가능   가격 및 크기 장점   완전 자율주행 준비   자동차가 책임지는 자율주행      자율주행 시 자동차 책임   본격화되는 자율주행 3, 4, 5단계 및 상용화 전망            법, 제도 변경: 2020년부터 진행       Level 3 상용화: 2021년부터 시작, 2023년 활성화 전망       Level 4 시범 서비스 다양화: 도심 자율주행 시범 서비스 다양화           운전자 중심 자율주행(0, 1, 2)   운전자 보조 시스템 특정 조건일 때만 센서 사용 차량 외부 상황 위주의 모니터링   자동차 중심 자율주행(3, 4, 5)   자동차가 모든 시스템을 관리 실시간으로 센서 사용 사용자 모니터링 필수화 차량 고장 진단 모니터링 필수화      구글 웨이모 자율주행 택시 서비스   모셔널-리프트 자율주행 택시 서비스   판교 제로셔틀   바이두 무인 자율주행 택시   Level 4 고려      당분간 자율주행 셔틀 위주            교통량이 적거나 정해진 루트의 자율주행           오토노머스 a2z 카카오 모빌리티: 세종시 유료 서비스            2020년 12월 시작       카카오 T앱으로 예약 및 호출           오토노머스 a2z: 세종시 자율주행 셔틀            2021년 5월부터 일반인 이용           포티투닷: 상암대로 일대를 주행하는 자율주행 택시 서비스            2022년 2월 10일부터 시작           도심 주행의 어려움      웨이모 문제   구글 웨이모의 주요 문제점            좌회전 상황       도로 합류 상황       사람이 많은 상황       서있는 차량 끼어들기       고속도로 램프 진입 상황           자율주행 트럭      물류 시장 뒷받침   대부분 고속도로 운행   제도적인 이슈   승용차보다 상용차가 수월   투심플, 플러스, 임바크, 오로라(전기) 자율주행 트럭   자율주행 시뮬레이터      자율주행 시뮬레이터의 발전            자율주행 알고리즘 고도화를 위한 다양한 상황의 주행 데이터 필요       실제 도로에서는 생각보다 다양한 주행 상황 발생하지 않음           정밀 자율주행을 위한 시뮬레이션 기술-웨이모      시뮬레이션 시티   2021년 7월 발표한 자율주행 시뮬레이터   소나기, 어두워지는 빛, 태양의 눈부심 등 다양한 주행 환경 구현   구글이 자율주행으로 모은 3,200km 이상의 데이터와 NHTSA의 충돌 사고 데이터 등 내외부 데이터를 종합하여 테스트   시뮬레이션 환경은 수십개의 도시에서 매일 수집되는 정보를 통해 지속적으로 업데이트   정밀 자율주행을 위한 시뮬레이션 기술-테슬라 AI Day      오토라벨링 기술   차량과 보행자의 움직임 경로 예측을 통해 가려진 물체에 대해서도 오토라벨링   실제 세계와 거의 유사한 시물레이션 World 생성            Real World Clip으로부터 Auto-Labeled Reconstruction을 생성       Real World Clip과 Auto-Labeled Reconstruction을 결합하여 시뮬레이션 World 생성           정밀 자율주행을 위한 시뮬레이션 기술-모라이      완벽한 자율주행을 위한 시뮬레이션 환경 제공을 위해 디지털 트윈 기반의 가상 환경을 포함한 시뮬레이터   유일한 국내 도로 환경을 포함한 시뮬레이터   시뮬레이터 내의 가상 차량 및 센서를 현실과 유사하게 모델링하여 실제와 유사한 자율주행 개발 환경 제공   완전 자율주행 시대      도로 위에 모든 차량이 완전 자율주행차   교통 인프라 최소화            교통 신호 불필요: 설치 및 운영에 드는 비용이 매우 큼          ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%9E%90%EC%9C%A8%EC%A3%BC%ED%96%89%EC%9D%98-%EA%B0%9C%EC%9A%94-%EB%B0%8F-%ED%98%84%ED%99%A9/",
        "teaser": null
      },{
        "title": "[Daily Contents] 머신 러닝 알고리즘",
        "excerpt":"    머신 러닝 알고리즘      Unsupervised Learning            Clustering       Dimensionality Reduction           Supervised Learning            Classification       Regression                Reinforcement Learning       딥러닝 : 인공 신경망, 합성곱 신경망, 적대적 신경망, 순환 신경망        강화학습 : Q-러닝, 유전 알고리즘, SARSA       지도학습            회귀 : 선형 회귀, 다항 회귀, 라쏘 회귀       분류 : 의사 결정 트리, 로지스틱 회귀, k-최근접 이웃, 서포트 벡터 머신, 나이브 베이즈           비지도학습            군집화 : k-평균, 평균 이동, 밀도 기반 공간 군집, 응집       자원 축소 : t-분포 확률적 이웃 임베딩, 주성분 분석           선형 회귀   정의: 종속 변수 y와 한 개 이상의 독립 변수 x와의 선형 상관 관계를 모델링하는 분석 기법   회귀 문제 분류      종속변수와 독립변수 수에 따라 분류   독립변수, 종속변수 1개 » 단변량 단순 회귀   독립변수 2개 이상 » 다중 회귀   종속변수 2개 이상 » 다변량   선형 회귀로 풀 수 있는 문제들   - 메신저에 등록된 친구의 수와 한 주 동안 주고받은 메세지의 수 - 마일리지에 따른 중고차 가격 - 학습시간과 시험점수 - 도심에서부터의 거리에 따른 토지 가격 - 마케팅 비용과 매출 사이의 관계 - 직선형이 아닌 경우   &gt;&gt; 다항 회귀(Polynomial Regression): 지수(x^n) 적용 가능   &gt;&gt; 직선형으로 만들어보기: 데이터 변환(transformation)   싱나는 수학 시간      간단하게 표현한 회귀 모델: $Y = wX + b$            좀 더 정확한 표현(단변량 단순 회귀): $Yi=β0+β1Xi+∈i$(오류항)       일반화(다중 회귀): $Y+Xβ+∈$           어떻게 최적의 $(w,b)$를 찾을까?            최량적합선 찾기       각 데이터 포인트와의 거리(오류)가 가장 가까운 직선의 방정식           수학으로 찾기      오차 정의: SSE(Sum of Squared Errors) : $\\sum(Y-\\hat{Y})^2$            $\\hat{Y}$: 적합선의 Y의 값           공식            $w=$${\\sum((X-\\overline{X})(Y-\\overline{Y})}\\over\\sum(X-\\overline{X})^2$                    $\\overline{X}$: X 평균           $\\overline{Y}$: Y 평균                       $b=\\overline{Y} - w\\overline{X}$           머신 러닝으로 선형 회귀(이론)      손실 함수 또는 비용 함수            예측값과 실제값의 오차       회귀 문제에서는 일반적으로 MSE(Mean Squared Error)를 사용       $MSE =\\(1\\over n\\)\\sum(Y-\\hat{Y})^2$           최적화            가장 작은 손실 함수 값을 출력하는 파라미터$(w, b)$찾기       경사하강법 사용           더 공부하기      (책) 파이썬 라이브러리를 활용한 데이터 분석   (책) 혼자 공부하는 머신러닝 + 딥러닝   (책) 밑바닥부터 시작하는 데이터 과학   (책) 파이썬 라이브러리를 활용한 머신러닝   (책) 파이썬 데이터 사이언스 핸드북   (웹) https://wikidocs.net/53560 (Pytorch로 시작하는 딥러닝 입문)   (웹) https://developers.google.com/machine-learning   (강의) Coursera - Machine Learning(Andrew Ng)  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5-%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80/",
        "teaser": null
      },{
        "title": "[Daily Contents] Drools & Spark",
        "excerpt":"    빅데이터 프로젝트의 간단한 개요      빅데이터 소스 // 데이터 소스(내부 데이터, 외부 데이터)   빅데이터 수집 // 수집, 통합, 전처리(DB Connector, 검색 API)            정형, 비정형 데이터 수집       데이터 취합 후 저장           빅데이터 구축 // 저장, 관리(MySQL)            데이터 분산 저장       필요 시 준 구조화된 데이터 저장           빅데이터 분석 // 분석(PRO SINDI)            초고속 병렬 처리       데이터 가공, 추출       데이터 분석 전처리           빅데이터 활용 // 표현(가시화)            데이터 보안, 권한       데이터 품질, 백업       플랫폼 시스템 관리           (2, 3) &gt;&gt; Operation (4, 5) &gt;&gt; Analytics   Drools와 BRMS   Drools = (매우 빠르게)참 또는 거짓을 평가      Jboss에서 개발한 BRMS(business rule management system : 비즈니스 규칙 관리 시스템)   비즈니스 규칙 구현을 자동화하도록 설계된 Apache license 2.0 OpenSource solution.   비즈니스 규칙 및 의사 결정, 논리 정의, 배포, 실행, 모니터링 및 관리하는 데 사용되는 소프트웨어 솔루션으로, 비즈니스 규칙은 회사 또는 업계가 운영하는 회사 정책 또는 법률 및 규정을 기반으로 하며, 비즈니스 규칙은 작업들의 정의에 따라 항상 참 또는 거짓을 평가   BRMS를 통해 기업은 IT 직원의 개입 없이도 새로운 운영 조건을 빠르게 적용 가능   BRMS는 IT 부서에서 이러한 시스템을 수동으로 재구성하지 않고도 데이터베이스와 같은 IT 시스템에 대한 변경을 자동화함으로서 새로운 비즈니스 규칙을 구현하는 데 걸리는 시간을 줄일 수 있다.   BRMS는 기술 및 비즈니스 사용자가 비즈니스 규칙을 정의하고 관리할 수 있는 개발 도구를 제공, 사용자는 코드를 작성하지 않고 비즈니스 규칙을 개발하는 중에도 비즈니스 규칙을 검증할 수 있다.   단점은 비즈니스 규칙을 정의하려면 회사, 산업 및 규정에 대한 많은 지식이 필요하기 때문에 BRMS를 구현하기가 어렵다는 것   BPMS : 비즈니스 프로세스를 최적화하여 효율성과 생산성을 높이도록 하는 소프트웨어 솔루션   BRMS : 비즈니스 규칙을 정의, 실행 및 관리하기 위한 시스템 BPMS : 비즈니스 프로세스를 최적화하여 효율성과 생산성을 높이는 시스템   Low Code : 선 개발된 모듈과 적은량의 개발, GUI 등의 간단한 조작으로 조합하여 시스템을 만드는 개발 방법. RPA : (반복적인 작업을 처리하는) “로봇을 이용한 프로세스의 자동화”로 비용과 인원을 줄이는 것   No Code   Hadoop MapReduce      Master worker »(작업 부여, 매핑)» Sub workers   Recude : 매핑한 작업의 응답을 받아 최적화하는 과정   Based on - HDFS   Apache Spark   RDD : Resilient Distributed Datasets                          Spark       Hadoop MapReduce                       speed       100x times than MapReduce       Faster than traditional system                 Written in       Scala       Java                 Data Processing       Batch, real-time. iterative, interactive, graph       Batch processing                 Ease of Use       Compact &amp; easier than Hadoop       Complex &amp; lengthy                 Caching       Caches the data in-memory &amp; enhances the system performance       Doesn’t support caching of data           Data Flow   (사례) 쿠팡 데이터 플랫폼 변천사   A Unified Data Infrastructure Architecture   Drools의 미래?   참고      2017년 한국정보통신학회 발간, 한국정보통신학회 논문지 - 아파치 스파크 기반 검색엔진의 설계 및 구현 논문   SK 인포섹 EQST 그룹 - 오픈 소스 소프트웨어 보안 가이드   Youtube - 최신 데이터 인프라 이해하기  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/Drools&Spark/",
        "teaser": null
      },{
        "title": "[Daily Contents] 금융시스템 vs 블록체인",
        "excerpt":"    REMIND   BLOCKCHAIN?      블록에 데이터 저장, 해시함수로 묶어 이전 블록을 가리켜 놓은 것   보안성, 투명성, 무결성, 탈중앙화   암호화      복호화 가능            대칭키 암호화                    AES, DES, ARIA, SEED                       비대칭키 암호화(공개키 암호화)                    RSA, ECC // ECDSA // DS(전자서명)                           복호화 불가능(단방향 암호화)            SHA256(비트코인의 시작), keccak256, RIPEMD-160…           활용      결제   암호화폐(거래 내역), 스마트 계약, 물류관리…   World Computing   LEARNING GOALS   금융 비즈니스의 프로세스를 알 수 있다. BlockChain의 종류를 알 수 있다. BlockChain의 탄생 배경과 철학을 알 수 있다.   당행 송금   수수료 : 없음 소요시간 : 수초 내   타행 송금      두 은행을 중재할 기반이 필요: 금융결제원   수수료 : 경우에 따라 500~1000원 소요시간 : 수초 내   해외 송금      국제 SWIFT » 해외 중계은행 » FED망 » 수취은행   수수료 : 10~20% + @ 소요시간 : 5~7% 영업일   은행이 왜 필요한 거죠?      신뢰   이중 지불 문제   디지털 자산의 이동   블록체인 특징      위변조가 불가능한 모든 거래 내역을 해시값으로 변환하여 저장.   나의 모든 거래 내역, 얼마를 보냈고 받았고 얼마가 남았나를 네트워크에 참여하는 모든 노드들이 알기 때문에 이중지불이 불가능     합의 알고리즘   Consensus Algorithm                          작업증명(Proof of Work)       지분증명(Proof of Stake)       Byzantine Fault Tolerance                       제안 자격 취득       목표값 이하의 해시를 찾는 작업       플랫폼 토큰을 보유한 양과 기간에 따라 결정       정해진 순번 또는 정해진 확률에 의해                 네트워크 참여 제한       없음       없거나 낮음       높음                 합의에 필요한 연산량 및 비용       높음       낮음       낮음                 위협       51% 공격       51% 공격       담합                 대표적인 블록체인       B       Ethereum, EOS       HYPERLEDGER           신원확인 방법   공개키 암호화 : 계좌가 내 것임을 증명   Type of blockchain                          PUBLIC       PRIVATE                       참여형       B, Ethereum                         제한형       Klaytn       ripple, STELLAR // C*RDA, HYPERLEDGER           Cryptocurrency                          B       Ethereum                       개발자       나카모토 사토시(익명)       비탈릭 부테린                 언어       C++       C++, GO, Solidity(Smart Contract)                 합의 알고리즘       PoW       PoW » PoS 변환 완료(22.09.14)                 구현 방법       UTXO 구조       어카운트 기반과 Smart Contract로 구분           Transactions Example      to가 일반 EOA계좌면 Value Transfer   to가 SmartContract계좌면 SmartContract 실행   to가 없으면 SmartContract 배포   HISTORY      중앙집권화된 국가와 거대 기업들에 대항하여 개인의 프라이버시를 보호하기 위해 암호화 기술을 이용하여 익명성을 보장하는 탈중앙화 시스템을 만들려고 한 사회 운동에 기반   의존적이지 않는 것에 철학을 두고 있다.   SUMMARY &amp; QUIZ      은행은 송금시에 중계 역할로 송금 쪽에서 차감 수신 쪽에서 입금 해 줌으로서, 신뢰와 이중 지불 문제 를 해결한다.   블록체인은 보안성, 투명성, 무결성, 탈중앙화의 특징을 가지고 있다.   블록체인의 자격 증명은 합의 알고리즘을 통해서 이중 지불 문제를 해결한다.   이것은 블록을 제안하기 위한 합의 알고리즘의 하나로 최근 이더리움이 환경적으로 문제가 많은 PoW에서 PoS로 Merge를 하여 변경하였다.   이더리움에서 사용하는 해시함수는 Keccak256이다.   Q&amp;A   Q. 우리나라에서 블록체인이 효용을 보려면 은행 수수료가 비싸지는 시점이 와야만 할까요. A. 국내는 은행 수수료가 싼 편. 익명성 때문에 많이들 사용 중.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EA%B8%88%EC%9C%B5%EC%8B%9C%EC%8A%A4%ED%85%9C-vs-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/",
        "teaser": null
      },{
        "title": "[Daily Contents] 인류의 먹거리를 해결하라 (Smart Farm)",
        "excerpt":"    현황      뉴욕에서 세 끼 사 먹으면? 말로만 듣던 ‘살인물가’   식료품 가격은 뉴욕이 약 4$ 저렴   현황 한국 농업      농가인구 급감   농가인구 중 고령자 비중 59.9%   평균 1.5ha(4,500평)            농가당 평균 농지면적 » 영국(87ha), 프랑스(69ha), 독일(60ha)           3      온실 하우스 세계 3위   0.9      스마트팜의 보급률이 낮아 투자자들에게 환영   농업 강대국      1위 미국   2위 네덜란드(미국의 1/250의 면적) : 130조원   3위 독일   세대별 비교                          1세대 스마트팜       2세대 스마트팜                       데이터 수집       생육 환경 정보       생육 환경 + 생체 정보                 데이터 분석       지식, 경험, 분석도구       인공지능                 서비스       편의성 + 긴급 알림       1세대 + 자동조절 + 의사결정                 시스템 제어       농장 단위 제어기       클라우드 시스템              3세대 기본 구성 복합에너지 관리 : 난방기, 지열, 태양열, 본오계 등 최적 제어 기술 적용 스마트 농작업 : 로봇 및 지능형 농기계 농작업 자동화 시스템 특징 : 로봇, 컨설팅   ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%9D%B8%EB%A5%98%EC%9D%98-%EB%A8%B9%EA%B1%B0%EB%A6%AC%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EB%9D%BC-Agtech(Smart-Farm)/",
        "teaser": null
      },{
        "title": "[Daily Contents] JIRA의 활용",
        "excerpt":"    JIRA   도대체 JIRA를 왜 쓰는 거죠?   애자일 팀에서 추천하는 최고의 도구 프로젝트의 체계적 관리 편리한 이슈 트래킹 프로젝트 전반에 대한 레퍼런스 확보 및 관리   프로젝트 관리(취업)에 유리하니까 사용      세계시장 점유율 60%        우대사항 : JIRA 유경험자       JIRA의 기본적 활용   Workflow JQL BULK Releases Components and Labels      Work flow            Ticket이 생성되고 완료될 때까지의 상태 변화       프로젝트 진행상황을 한눈에 파악 가능       불필요한 커뮤니케이션 감소       취업 이후                    각 status의 의미 파악 중요                                JQL              Jira 쿼리문       ex) project = S04P13C107 AND updatedDate = now() and assignee = currentUser()       ex) project = S04P13C107 AND issuetype = Sub-task and summary ~ ‘frontend’                BULK              assign to me 일괄처리       우측 상단 Tools » Bulk » checkbox 선택 후 이슈 가져오기.       send mail for this update 선택하면 누군가의 메일에 대량 메일 발송…                Releases              배포 버전 관리       Version 0.1, 0.11 등으로 이슈의 Fix Version/s에 태그로 기록           Components and Labels            component : 팀 고유의 것.       label : 모든 팀이 공통으로 사용하여 데이터가 오염. 개인이 메모하는 용도로 사용하는 것이 적합.           Story Point            해결에 걸리는 시간이 아니라 이슈의 난이도 표현       1, 2, 3, 5, 8, 13…       ss, sm, sl, mm, lm…          ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/JIRA%EC%9D%98-%ED%99%9C%EC%9A%A9/",
        "teaser": null
      },{
        "title": "[Daily Contents] 금융권 모의해킹",
        "excerpt":"    보안이란?      대상의 안녕과 질서를 유지하는 것   정보 보안 : 대내외의 공격으로부터 정보 자산을 안전하게 지키는 전략적 행위            정보보안, IT보안, 사이버보안, information security 또는 infosec       1918년 독일인에 의해 고안되어 폴란드의 보안 전문가들이 개발한 Enigma가 시초       정보의 수집, 가공, 저장, 검색, 송신, 수신 도중에 발생할 수 있는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 방법       내/외부의 위협요인들로부터 네트워크, 시스템 등의 하드웨어 및 데이터베이스, 통신 및 전산시설 등에서 정보자산을 안전하게 보호/운영하기 위한 일련의 행위       안전은 상태, 보안은 활동을 전제           허락된 사람에게만 접근하도록 지키는 것   정보를 여러 위협으로부터 보호하는 것   예외 처리를 철저히 하는 것   정보보안은 왜 하는가      지키려고 » 가족과 재산   완벽한 보안은 없다 : 100% 보안은 불가능하다.            ex) 2011년 SK Nate 3500만명 고객전원 정보 유출, 2014년 국민, 농협, 롯데카드 2000만명, 8000만건 내역유출, 2014년 KT 1200만명 개인정보 유출 전 국민의 20%           금융권 Domain      계정계 : 금융업무처리 시스템 그 자체   예금, 대출   정보계 : 계정계 데이터를 기반으로 영업점 및 각 부서의 업무처리를 위해 필요한 거래데이터의 기록 및 기록의 통계를 관리하는 시스템   대외계 : 은행 외부기간과 연계되는 업무용 금융 공동망 등 연결 시스템   채널계 : End User에 따른 다양한 접속채널에서 발생하는 데이터들을 관리하는 시스템   운영계 : 시스템의 안정적인 운영을 위한, 통합관제, Net 모니터링, 유지보수 등을 담당   기간계 : Lagacy. 신규 시스템 도입 시점에서 기존에 사용하던 시스템. 아주 오래된 시스템.   금융권 모의해킹 항목      실제 점검 항목 일부            별점 4 자체 보안성심의 점검 항목                    거래 당사자 인증           거래 정보의 기밀성 및 무결성           정보처리시스템 보호대책                       …           금융권 보안의 핵심      데이터를 설계한 케이스 외에는, 절대로 주지 않는 것.   사고 발생 시 조치될 시간을 버는 것.   { \t\"res_code\"     \"res_mesg\"     \"transaction_id\"     \"user_info\" : {     \t\"user_no\"         \"user_nm\"         \"user_nm_enc\"         \"regist_no\"         \"regist_no_enc\"         \"mobile_no\"         \"mobile_no_enc\"     }     \"account_info\" : {     \t\"account_no\"         \"account_no_enc\"         \"amount\"         \"amoutn_enc\"     }   ex) user_nm : \"김*준\", user_nm_enc : \"D5A43256313…\"   enc 정보는 유출이 되더라도 해킹이 불가능. 양방향 암호화. Server에서 암호화. Client에서는 복호화가 불가능.   비밀번호를 반복해서 틀리는 등 기준점을 초과하면 재인증 관련 가이드를 주면서, 한편으로는 모니터링 팀의 모니터링이 들어간다. '시간을 번다'라는 뜻.   보안설계 개념설명      Lagacy   HTTPS Session Ctrl, AccessToken(비동기, JWT) Request Monitoring - drools = certbot - TLS, SSl   Redis(리프레시 토큰을 사용할 때 많이 사용, JWT 토큰을 잘 활용하기 위한 장치) AccessToken - Expired Time   * Data Tier Session - Expired Time Data Transaction 이력 저장   * Logic Tier, Application Tier Data 단방향, 양방향 암호화      Trendy   HTTPS Request Monitoring - drools(JWT)   * 변화하는 트랜드 JWT Gateway kubernetes https(MSA, 서버 간에도 구간 암호화) \tservice Discovery : 유레카, consul, ELB(AWS)     서킷 브레이커, Monkey test(무작위 테스트) istio : 서비스 메쉬, 통신 모니터링 \t프로메테우스, 그라파나 spring bott - Security filter   * Data Tier Data Transaction 이력 저장   * Logic Tier, Application Tier Data 단방향, 양방향 암호화   JWT   핵심은 Hash   { \t\"header\" : {     \t// HashString등의 Header 정보     },     \"payload\" : {     \t// 실제 토큰 정보들         // 발급시스템 정보         // 사용권한 - api, email 등등…     },     \"hash\" : {     \t// header와 payload 정보를 \"서버에서\" 암호화한 Hash값     } } // HeaderBase64.PayloadBase64.hash   OWASP Top 10 Trend      2017년과는 다르다!   2021년   Broken Access Control Cryptographic Failures Injection Insecure Design Security Misconfiguration Vulnerable and Outdated Components Identification and Authentication Failures Software and Data Integrity Failures Security Logging and Monitoring Failures Server-Side Request Forgery(SSRF)   마치며      정보보안의 내 일은 넘쳐나니 골라라!  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EA%B8%88%EC%9C%B5%EA%B6%8C-%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9/",
        "teaser": null
      },{
        "title": "[Daily Contents] 모바일 앱, 어떤 프레임워크로 개발할까?",
        "excerpt":"    네이티브 앱      안드로이드와 IOS   초창기에는 소프트웨어 적으로도 하드웨어적으로도 차이가 명확.   갈수록 비슷해지고, 두 가지를 한 번에 개발할 수 있는 방법이 없을까?   웹 페이지로 앱을 개발?   하이브리드 앱      Native + HTML   하이브리드 앱의 원리      Web View라는 브라우저가 실행   일반적인 브라우저에서 주소창이 없어진 형태   하이브리드 프레임워크      CORDOVA   하이브리드 앱의 장점      앱 개발에 대한 지식이 없어도 개발이 가능   웹 페이지 하나의 개발로, 웹, 앱 모두 서비스 가능   앱이 업데이트 될 때마다 앱 마켓에 업로드 할 필요 없음   하이브리드 앱의 단점      UI로 전부 직접 개발해야 함   앱의 속도가 느림   스마트폰이 제공하는 기능을 사용하기 어려움   네이티브의 UI를 따라가기 어려움   화면을 전부 불러오기 때문에 데이터 사용량이 많음   크로스 플랫폼의 원리      단점을 보완해 보자   네이티브에 라이브러리를 제공   하이브리드 앱은 스마트폰에 있는 하드웨어적인 기능을 라이브러리로 변환해서 사용했기 때문에 속도가 느림   공통으로 사용하는 언어 하나로만 만들면 네이티브로 컴파일하여 네이티브 애플리케이션으로 나오게 해 줌   속도도 빠르며 퍼포먼스도 좋게 되었음   크로스 플랫폼의 종류      React Native   Xamarin   Flutter   100% 네이티브처럼 개발이 가능?      NO   크로스 플랫폼 포기      airbnb            React Native를 포기하고 네이티브로 전환           리액트 네이티브      Latest version : 0.66   1 버전으로 시작하지 않는 것은 완벽하지 않은 베타 버전이라는 의미   Flutter도 마찬가지로 언제든지 서비스를 종료하게 될 수 있음   크로스 플랫폼 앱의 단점      네이티브의 모든 기능을 제공하지는 못함   새로운 기능이 나왔을 때 업데이트 속도가 느림   사업이 중단되어 프레임워크가 사라질 가능성이 있음   스타트업 등은 네이티브로 두 플랫폼을 개발할 여력이 없기 때문에 먼저 빠르게 크로스 플랫폼 등으로 개발해서 출시하고 시장의 반응을 본 후 후일 네이티브로 전환도 가능   결론?      Native VS Hybrid vs Cross-platform   기본은 네이티브. 네이티브의 원리를 잘 이해하고 있다면 하이브리드나 크로스 플랫폼은 쉽게 익히고 다룰 수 있음   처음 공부를 한다면 네이티브를 공부하는 것을 추천   빠르게 서비스를 배포하고 시장의 반응을 보고 싶다면 하이브리드나 크로스 플랫폼을 추천  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1,-%EC%96%B4%EB%96%A4-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%A0%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[Daily Contents] 플러터로 앱 개발해보기",
        "excerpt":"    성능테스트   IOS용 CPU 집약적 테스트      Gauss-Legendre 알고리즘            React Native는 Flutter나 native에 비해서 25배 정도 CPU 사용률이 높음           Borwein 알고리즘            React Native는 물론 Flutter의 CPU 사용률도 높음           Android용 CPU 집약적 테스트      Gauss-Legendre 알고리즘            마찬가지로 React Native의 CPU 사용률이 압도적으로 높음           기타 성능비교      React Native의 성능이 가장 하위   Flutter      공식 문서에 React Native 사용자를 위한 Flutter 소개, JS 개발자를 위한 Dart 소개 등이 기재되어 있음     ex) List 출력   child: Column(   children: [     Expanded(child: ListView.builder(       itemCount: Images.length,       itemBuilder: (context, index){         return InkWell(           onTap: (){             print(\"$indtex clikced\");           },           child: Padding(             padding: const EdgeInsets.only(top: 20),             child: Stack(               children: &lt;Widget&gt;[                 Material(                   child: Container(                     height: 300,                     width: double.infinity,                     child: Images[Index].isEmpty ? null                     : CachedNetworkImage(                     imageUrl: Images[index],                       imageBuilder: (context, imageProvider) =&gt; Container(                         decoratrion: BoxDecoration(                           image: Decoration(                             image: imageProvider,                             fit: BoxFit.cover                           )                         )                       )                     )                   )                 ]               )             )           )         }       )     )   ] )   위는 정적인 코드. 동적인 코드를 원한다면 StringBuilder를 사용.   Q&amp;A   Q. 최신 버전을 Flutter가 자동으로 설정해 주는지? A. 버전이 기입되지 않은 경우 Flutter 자체적으로 버전을 설정.   Q. Flutter는 state 변경을 어떻게 감지하나요? A. 자식 트리가 변경이 되면 부모 트리에게 통지함.   Q. 플러터가 안드로이드에 비해 갖는 강점은? A. IOS 개발도 동시에 가능하기에 비용 절감. 다만 성능 저하의 단점은 있음.   Q. Flutter 공부는 어떤 방식으로? A. 구글이 만든 것이기에 공식 문서 참고.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%ED%94%8C%EB%9F%AC%ED%84%B0%EB%A1%9C-%EC%95%B1-%EA%B0%9C%EB%B0%9C%ED%95%B4%EB%B3%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Daily Contents] 알아두면 쓸모있는 데이터베이스 객체(기능편1)",
        "excerpt":"    Relational DBMS      MySQL - MySQL.   Oracle - 가장 점유율이 높고 가장 비싸다. 기업에서 사용.   MariaDB - MySQL이 Oracle에 인수되면서 그에 반발하며 나온 DB. MySQL과 흡사.   PostgreSQL - 오픈소스. Oracle과 유사.   MS SQL Server - 유료이나 무료로도 어느 정도의 기능 활용 가능. 윈도우에서만 사용 가능. 건설 업계, 공장 등에서 많이 사용.   0. 실습 시나리오   현재 상태 : MySQL 기본 설치. root 사용자로 외부에서 접근 가능. 회원 정보는 한글 사용자, 영문 사용자로 나눠서 관리. 회원정보 변경 시 LOG 테이블에 변경 내역 저장 회원정보 조회 시 회원이 작성한 글 수를 항상 함께 보여줘야 함. 작성한 글 조회 시 항상 작성자 아이디, 이름 함께 보여줘야 함.   0. Schema? Database?   인스턴스 -&gt; 데이터베이스 -&gt; 스키마 -&gt; 테이블      인스턴스 : DBMS가 동작할 때의 단위. OS 입장에서는 ‘프로세스’   Database : 물리적으로 구분된 데이터베이스(스키마의 집합)            다른 Database에 접근할 수 없음.           Schema : 데이터베이스의 구조와 제약 조건을 정의한 것.            접근 제한 등 권한 관리가 가능.           MySQL (스키마와 데이터베이스를 함께 사용.) 인스턴스 -&gt; 스키마 -&gt; 테이블 ex) - CREATE SCHEMA SSAFY DEFAULT CHARACTER SET utf8; - CREATE DATABASE SSAFY DEFAULT CHARACTER SET utf8; 두 쿼리문은 같다.   Oracle (한 인스턴스 안에 데이터베이스 하나만을 생성 가능.) 인스턴스 -&gt; 데이터베이스 -&gt; 스키마 -&gt; 테이블   1. Table      데이터를 담고 있는 객체   행(Row)과 열(Column)로 구성된 2차원 행태(표)의 객체   DBMS의 모든 데이터는 테이블로 관리   2. Contraint      제약조건   데이터의 무결성을 지키기 위해 제한된 조건   NOT NULL, NUIQUE, PRIMARY KEY, FOREIGN KEY, DEFAULT 등   3. Sequence      시퀀스는 자동 순번을 반환하는 데이터베이스 객체   MYSQL에서는 지원하지 않음.(Oracle, Postgresql, MS-SQL 등에서 지원)   SEQ_USER.nextval, SEQ_USER.currval, SEQ_USER.setval 등으로 사용   CREATE SEQUENCE [스키마명.]시퀀스명 INCREMENT BY 증감숫자 START WITH 시작숫자 NOMINVALUE | MINVALUE 최소값 NOMAXVALUE | MAXVALUE 최대값 NOCYCLE | CYCLE NOCACHE | CACHE   4. Function      Return 값 필수   Return 값은 하나(MySQL은 하나만 반환. MSSQL, Oracle은 테이블-2차원 배열을 반환할 수도 있음.)   CREATE FUNCTION '함수명' ( 파라미터 ) RETURNS 반환할 데이터타입 BEGIN   수행할 쿼리   RETURN 반환할 값 ENC   DELIMITER : Function을 감싼다. DELIMITER로 시작해서 DELIMITER로 끝나는 구간까지가 Function.   sha2 : DB에서도 암호화 가능. * 비밀번호를 암호화하는 이유 : 알아볼 수 없게 하기 위해.   View      하나 이상의 테이블로부터 쿼리한 데이터의 집합   접근이 허용된 자료를 제한적으로 보여주기 위해 사용   사용자 편의 : 자주 사용하는 복잡한 SELECT Query문을 미리 제작(재사용)   기존 테이블 구조를 건드리지 않고 필요에 맞는 모습으로 데이터 제공   CREATE VIEW `뷰이름` AS   SELECT Query문;   Q&amp;A   Q. 서버에서 프로시저 호출 시, 프로시저에서 반환값은 마지막으로 Select한 결과인가. A. 반환값이 여러 개일 수 있음. 다음 주에 자세한 설명 예정.   Q. SQL이 실제로 동작하는 시간이 전체 서비스에서 큰 영항을 미치는가. A. function으로 만들 경우와 BE 서버가 처리할 경우와 비교해 네트웨크 트래픽 차이가 생김. 리소스 낭비.   Q. 테이블을 어떤 쿼리가 점유 중이면 다른 쿼리 요청이 못 들어갈 수 있다고 하는데 그런 문제는 안 생기는지. A. 락이 걸리기 때문에 당연히 다른 요청은 못 들어감. 하지만 주의는 필요. 단, Select는 락이 걸리지 않음.   Q. 뷰 기능을 실제 개발 상황에서 언제 사용하는지. A. 보안상 사용하기도 하며, 사용자 편의를 위해서도 사용.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%93%B8%EB%AA%A8%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9D%EC%B2%B4(%EA%B8%B0%EB%8A%A5%ED%8E%B81)/",
        "teaser": null
      },{
        "title": "[Daily Contents] 메세지 큐",
        "excerpt":"    좋은 웹 AP가 가져야 할 것들 - 성능      성능            빠르면 빠를수록 좋다. 양, 부하 등을 견딘다.           안정(신뢰)성   보안            HTTP, HTTPS, 웹캠과 마이크에 테이프 붙여두기…           웹 아키텍쳐      웹 서버 프로그래밍 중 특별한 일을 물리적으로 독립된 다른 곳에서 처리하고 싶다 » Job servers   무인 주차 정산 시스템 구현      입차 시 카메라로 차량번호 인식   요금 할인 대상 차량 여부 확인(REST API)            경차, 저공해 차량 여부 체크       장애우, 유공자 여부 체크           출차 시 주차 요금 자동 정산   입차(차량번호) {   입차 ID = 입차 기록생성(차량번호);   장애우여부 = REASTAPI(차량번호);   유공자여부 = REASTAPI(차량번호);   경차여부 = REASTAPI(차량번호);   저공해차량여부 = REASTAPI(차량번호);   입차기록업데이트(입차 ID, 할인정보); }      실패 - RESR API 평균 응답시간 4초   해결 방법은 비동기처리?   응답 시간 - 비동기 처리      Synchronous / Asynchronous는 중요한 개념   업무 이해에 기반한 적절한 비동기 처리   사용 language, 프레임워크 환경에서 제공하는 것부터 적용   동기 VS. 비동기      일반적으로 코드는 순차적으로 실행   특정 명령어들의 모음을 별도의 작업 흐름으로 생성하여 명령 제어권을 바로 이어받을 수 있게 만든 방식이 비동기 처리 방식   비동기 처리로 해결?      사용 중인 프레임워크에서 제공하는 방법   멀티 서버 환경에서의 주의점      관리자 환경 설정 내용을 ‘로컬 파일’로 관리   changeEnv(){   파일오픈 \"D:\\env\\env.conf\"   write 작업 수행 }   메세지 큐      메세지의 버퍼 역할을 하며 비동기적으로 전송   서비스(서버) 간 느슨한 결합이 가능   메세지의 무손실을 보장   이기종간 메시징에도 적합   MSA   RabbitMQ   RabbitMQ      기본 활용만으로도 많은 장점   단순 사용 경험보다는 어떠한 환경에서 어떤 이유로 적용했는지에 대한 가설을 세워 본 경험이 중요   다양한 클라이언트 라이브러리 제공   메세지 디스크 저장 설정 가능   메세지 무손실(영속성) 보장   고가용성을 위한 클러스터 설정 가능   접근성 좋은 Web UI   마지막으로      서비스를 분리하고 관계를 맺으려 한다면…   우선 메세지 큐 활용법보다는 적합한 사용 시나리오를 찾기 위해 노력해보자.   비동기 처리를 통한 성능 향상과 서비스(서버)간 느슨한 결합이 가져다주는 장점을 경험해보자.   MSA를 고려하고 있다면 적극적으로 고려해보자.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EB%A9%94%EC%84%B8%EC%A7%80-%ED%81%90/",
        "teaser": null
      },{
        "title": "[Daily Contents] 프로젝트에 유용한 기술 스택",
        "excerpt":"    레벨 1 - 싸피를 수료했으면 이 정도는?   JWT                  Header                       Payload                       Signature           JSON Web Token은 웹표준(RFC-7519)으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자기수용적인 (self-contained) 방식으로 정보를 안정성 있게 전달.   Stateless 하기 때문에 대용량 분산 구조에서 사용하기에 적합함.   Mobile 환경에서는 안전한 영역에 JWT를 보관함.   Whitelist가 필요한 경우 Redis에 JWT Token을 보관해서 사용하기도함.   TypeScript      TypeScript는 JavaScript에 Type 표기를 할 수 있도록(type annotation) 한 JavaScript의 superest   Microsoft에서 지원   놀라운 생산성의 향상(코드 어시스트 지원!)   Type을 통해 미리 오류를 방지할 수 있음   Class 기반의 언어에서 사용하던 코딩 패턴을 사용 가능함.   Docker      컨테이너 기반의 오픈소스 가상화 플랫폼   리눅스 컨테이너를 사용해서 프로세스를 격리시키기 때문에 가볍고 빠르게 동작함   동일한 프로그램을 여러 서버에 배포하는 것이 가능함   이미지를 생성해서 공유하는 것이 가능함   Jenkins와 더불어 BE, FE 배포에 사용해보자            kubernetes           레벨 2 - 프로젝트와 맞다면 써 보자   면접관의 날카로운 질문      왜 해야 합니까 이걸??   JPA(Java Persistence API)      JPA는 Java를 위한 영속성(Persistence) 관리와 ORM을 위한 표준 기술   SQL 중심적인 개발의 문제점을 해소   지루한 코드의 반복을 없애서 생산성을 높인다!(쿼리의 90%는 지루하게 반복되는 CRUD)   MyBatis를 사용하고 있었는데 새로운 column이 하나 추가되었다. 여러 개의 쿼리를 수정해야 하는데 쿼리 하나를 수정하는 걸 깜박했다면?   자기소개서에 최근의 트랜드에 대해서 이해하고 있다는 강한 시그널이 될 수 있다   React      사용자 인터페이스를 만들기 위한 JavaScript 라이브러리   기업에서 Vue.js보다 선호   Vue와 React를 어설프게 두 가지 하나를 하는 것보다 확실히 하나를 더 잘하는 것이 좋다.            “Vue와 React를 다 해보셨네요? 두 경우의 장단점을 말씀해 주세요.”       “ㄷㄷㄷㄷㄷ”           공식 문서를 중심으로 공부해보자   MongoDB   여기서 문제 - NoSQL이란?   SQL이 없는거요. 나가      Document Oriented Database   “Not Only SQL”   Document는 Key-value pair로 이루어져 있고 Collection은 그 Document의 그룹이고 Database는 Collection들의 물리적인 컨테이너이다.   { \"\\_id\": ObjectId(\"5099803df3f4948bd2f98391\"), \"username\": \"velopert\", \"name\": { first: \"M.J\", last: \"Kim\" } }   websocket      Client – Handshake(HTTP Upgrade) –» Server   Client «– Handshake(HTTP Upgrade) – Server   Client «– Bidirectional Messages –» Server        Client «– One side closes channel –» Server       실시간으로 상호작용하는 웹 서비스를 만드는 표준 기술   연결을 맺는 비용이 가장 크기 때문에, 연결을 만들어 놓고 계속해서 사용하는 방법   지속적으로 서버와 통신이 필요한 기능(알림, 채팅 등)을 구현하기에 적합   브라우저의 버전에 따라서 websocket을 지원하지 않는 경우가 있기 때문에 socket.io라는 라이브러리를 주로 사용   Redis와 함께 쓰면 좋다   면접관에게 어필하기 좋은 기술 스택   Redis      Remote Dictionary Server   메모리 기반의 Key-value 데이터베이스   메모리를 사용하기 때문에 + Key-value 구조이기 때문에 대단히 빠르다!   만료일을 지정해서 저장하는 기능이 있기 때문에 JWT나 채팅을 저장할 때 사용하면 좋다   과도한 사용자의 요청을 count해서 막는 방법은?   Jenkins      Continuous Integration를 위한 도구   Git과 같은 형상 관리 도구에서 변경이 감지되면 자동으로 빌드해주는 것이 가능   빌드 후에 Pipeline을 통해서 정적 분석/자동화 테스트를 수행(소나큐브 등)   분석과 테스트가 종료되면 개발 서버에 Depoly하거나 개발 서버와 동일한 결과물로 상용 서버에 Depoly   Spring Batch      Batch(일괄 처리) 작업을 수행해주는 Spring Module   ex) 배달의 민족에서 매일 0시에 하루 매출을 정산한다면?   Quartz나 Spring Schedular 등과 함께 사용   정기적으로 수행해야 하는 대용량 데이터 처리가 있다면 Batch를 사용해보다   vs crontab?   Tip      React 상태관리   Redux : React 개발자가 만들었다!   Recoil : Next.js 등을 써 보았다!  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D/",
        "teaser": null
      },{
        "title": "[Daily Contents] 알아두면 쓸모있는 데이터베이스 객체(기능편2)",
        "excerpt":"    6. (Stored) Procedure      하나의 요청으로 여러 SQL문을 실행(가능)   네트워크 소요시간을 줄일 수 있음   리턴값 없을 수도 있음   리턴값 여러 개 반환 가능   CREATE PROCEDURE '프로시저명' (   파라미터 ) BEGIN   수행할 쿼리 END   7. User / 권한      MYSQL의 사용자   grant 명령어를 통해 권한 부여   revoke 명령어를 사용해 권한을 제거   FLUSH PRIVILEGES; 을 통해 권한 반영   CREATE USER {username}@{ip} identified by 'password'; DROP USER {username}@{ip}; grant {권한} privileges on {스키마}.{테이블} to {username}@{ip}; revoke {권한} privileges on {스키마}.{테이블} to {username}@{ip};   8. Trigger      어떤 상황이 발생했을 때 미리 정해진 Action이 자동으로 실행.   특정 테이블에 INSERT, UPDATE, DELETE문이 수행될 때 자동으로 동작.   변경 전 또는 변경 후의 행을 OLD, NEW 라는 가상 변수를 사용하여 읽음.                  이벤트       OLD       NEW                       delete       O       X                 insert       X       O                 update       O       O              사용 가능 O 사용 불가능 X    CREATE TRIGGER '트리거명' AFTER UPDATE ON '테이블명' FOR EACH ROW BEGIN  END   TMI - 분기문      필요에 따라 일반적인 쿼리문 내에서 분기문을 활용할 수 있음   SELECT절 뿐 아니라 WHERE절에서도 분기문 사용 가능   * CURSOR      테이블에서 한 행씩 처리하기 위한 방식   CURSOR, LOOP, FETCH 등의 구문을 사용   성능상 좋지 못해 권장하지 않으며, 실시간 데이터 처리는 매우 위험   DECLARE &gt;&gt; OPEN &gt;&gt; FETCH &gt;&gt;(&lt;&lt;no&lt;&lt;)&gt;&gt; EMPTY &gt;&gt;yes&gt;&gt; CLOSE   Q&amp;A   Q. 로그를 남기면 어떻게 유용하게 사용할 수 있는지 궁금함. A. 현재 유저들이 얼마나 많은 인원이 등록, 삭제, 수정 등을 하는지 확인할 수 있는 용도 등.   Q. 객체들을 많이 사용하게 될 때 부작용은 있을지? A. 성능을 무시하고 개발 기능만을 위해 만든 것. 이렇게 만들었는데 테이블 구조를 변경할 경우 필요한 데이터를 찾을 때 일일히 찾아봐야 하는 부작용이 발생함.   Q. 커서는 프로시저에서만 사용할 수 있는 것인가. A. Function 내에서는 INSERT, DELETE만 사용할 수 있으므로 일반적으로는 커서는 프로시저에서만 사용할 수 있음.   Q. JPA 같은 ORM을 이용해서는 사용할 수 없고 SQL에서 직접 해야 하는 것인지. A. JPA에서는 객체화되어있기 때문에 사용할 수 없음. 하지만 필요하다면 쿼리를 날릴 수는 있음   Q. DB 객체를 사용하는 것과 코드로 같은 작업을 처리할 때를 비교해서 서로 장단점은 무엇이 있을지. A. DB를 왔다갔다 하는 작업을 줄일 수 있음.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%93%B8%EB%AA%A8-%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9D%EC%B2%B4(%EA%B8%B0%EB%8A%A5%ED%8E%B82)/",
        "teaser": null
      },{
        "title": "[Daily Contents] OS 커널과 DB 모델",
        "excerpt":"    세상 모든 OS와 DB      어플리케이션을 구성하는데는 그에 따르는 인프라 필요. 요소에는 어떤 것이 있고 필수적인 OS와 DB의 구성에 대해서 알아보자.   Learning Goals      인프라에 필요한 구성 요소와 자원들의 형태를 알 수 있다.   현존하는 OS의 커널의 종류와 특징을 알 수 있다.   데이터를 저장하는 방식의 종류와, 그에 대표적인 DB 제품들의 특징들을 알 수 있다.   OS?!      Operation System : 시스템 소프트웨어 관리 컴퓨터 하드웨어, 소프트웨어 자원을 공통 제공 서비스를 위한 컴퓨터 프로그램.   하드웨어와 어플리케이션을 중재하는 역할   Type of OS Kernel   OS 커널      Monolithic kernel(모놀리식 커널)            UNIX, LINUX, MS-DOS, Windows 9x 계열(95, 98, me)           Micro kernel(마이크로 커널)            Minix           Hybrid kernel(하이브리드 커널)            Windows NT 계열, MacOS X 이후 버전           Monolithic kernel(단일형 커널)   IO 입출력 기능, 디바이스 장치 지원 등의 운영체제에서 일어나는 모든 일을 한 개의 커널과 동일한 메모리 공간에 적재하여 커리하는 기법      각 기능간의 커뮤니케이션이 좋고, 시스템 호출에 의한 서비스가 빠름.   새로운 디바이스 추가나 기능 변경 시는 어려우며, 어느 한 기능에 불량이 생기면 전체를 새로 빌드해야 하는 단점 등이 있음.   UNIX      HP_UX, ORACLE(SOLARIS), IBM_AIX, FreeBSD, MAC OS X   Linux Distro (Unix-like)      debian, ubuntu, Linux Mint   Red Hat, CentOS, fedora   slackware, SUSE   Micro kernel(마이크로 커널)   모놀리지 커널과 반대되는 디자인. 커널에는 핵심적인 디자인, 기본 프로세스 통신 등만을 포함하고 그 외의 것들은 외부 모듈화를 하여 커널의 사이즈가 작아지고, 임베디드 시스템이나 포터블한 디바이스에 사용이 유리      리얼타임성 시스템에 강함   통신은 메세지 전달을 통해서만 발생하기 때문에 전반적인 퍼포먼스는 저하   Hybrid kernel(하이브리드 커널)   IPC는 커널에 두고 파일시스템은 유저모드에 디자인   DATABASE?!      여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리하는 데이터의 집합   의미 있게 구조화하여 저장된 정보   Type of DB model   DB 모델      Relational   NoSQL            Document Store       Key-Value Store       Wide Column Store       Graph Database           NewSQL   Relational Database      Atomicity, Consistency, Isolation, Durability   Normalization - 1NF, 2NF, 3NF   Scalability (Scale-up, not scale out)   ANSI SQL 문법, JOIN 기능   Type of NoSQL model      주로 비정형화된 데이터를 저장하기 위한 것으로 특정 스키마가 없음.   어플리케이션의 도움 없이 여러 서버 간의 데이터를 자동으로 분할하고 시스템 메모리에 데이터를 캐시하여 처리량을 높이고 성능 향상.   간단한 데이터 모델과 쿼리로 높은 확장성 제공.        단 일관성보다 가용성을 선호하기 때문에 표준화가 부족하고 데이터 노드 간의 동기화가 되지 않아 시스템 장애의 위험이 있어 은행권 등에서는 쓰이지 않음.       Auto Balancing   Integrated Caching   Lack of schema   NoSQL            Document Store       Key-Value Store       Wide Column Store       Graph Database           Document Type Database      XML이나 JSON을 이용하여 데이터 저장. 스키마가 유동적이어서 레코드가 각각 다른 스키마를 가질 수 있음.            MongoDB, Couchbase           Key-Value Type Database      하나의 키에 하나의 값을 갖는 형태, 여러 개의 필드를 가질 수도 있음.   값을 영구히 저장하지는 않으나 휘발성을 이용하여 상태 표현이 필요한 곳에서 사용.            Redis, Memcached           Wide Column Type Database      모든 데이터는 로우별로 저장이 되고, 주어진 로우와 컬럼이 함께 저장.   대규모 확장성을 위해 사용. 수집할 수 있는 엄청난 데이터량을 다루는데 적합.            cassandra, HBASE           Graph Database      데이터를 노드로 표현. 쿼리 관계는 데이터베이스에 영구적으로 저장하기 때문에 빠름.   퍼포먼스가 좋고 유지보수에 용이한 것이 특징.            neo4j           NewSQL      RDB와 NoSQl의 장점을 합친 것. SQL 문법과 트랙잭션 지원. NoSQL처럼 스케일 아웃 지원. 분산 저장 형태의 DB 가능. 수평 분할 가능. 다른 트랜잭션에 영향을 미치지 않음으로서 빠른 성능.            Partitioning/Sharding       Concurrency Control       Replication       Crash Recovery       NUODB, Cockroach DB           DB 사이트   https://db-engines.com/en/ranking   SUMMARY &amp; QUIZ      OS 커널의 종류에는 모놀리식 커널, 마이크로 커널, 하이브리드 커널이 있다.   이것은 OS 중 한 종류로 데니스 리치가 개발하여 현존 OS의 전신이 되고 있는 이 OS의 이름은 유닉스다.   DB에서 NoSQL 종류에는 Document 모델 타입, Key-Value 모델 타입, Wide Column 모델 타입, Graph 모델 타입이 있다.   이 DB는 메모리 위에서 실행되는 Key-Value 타입의 DBMS로 가장 대표적으로 SDK가 제공되는 레디스가 있다.   0.1 + 0.2 = 0.3000000004 (부동소수점)   Q. NewSQL의 장점이 굉장히 많아보이는데, 대표적인 단점은? A. 아직 정식화가 되어있지 않음. 전문으로 하는 회사도 많이 없기에 제품도 많이 없음.   Q. 실시간 통계 보여줘야 하는데 어떤 DB가 가장 좋을지. A. 저장한다면 RDB, 저장하지 않는다면 REDIS가 좋음.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/OS-%EC%BB%A4%EB%84%90%EA%B3%BC-DB-%EB%AA%A8%EB%8D%B8/",
        "teaser": null
      },{
        "title": "[Daily Contents] 코드 리팩토링",
        "excerpt":"    학습 목표      코드 리팩토링이란?   언제 해야 할까?   어떻게 해야 할까?   필요한 이유   코드 리팩토링이란?      소프트웨어의 겉보기 동작은 그대로 유지한 채…   코드를 깨끗하고 이해하기 쉽게 구조만 변경하는 것   핵심은 “이 코드를 더 좋게 만들 수 있습니까?”에 있으며…            이에 대한 판단 기준으로는 확장성, 가독성, 유지보수성           언제 해야 할까?      기능 구현이 우선이고, 정상작동되는지 확인한 후에 진행한다.   한 번에 하나의 작업에만 집중하고 동시에 진행하지 않는다.            기능추가 단계 : 기존 코드는 건드리지 말고, 신규 기능 추가에만 집중       리팩토링 단계 : 기능을 추가하지 말 것, 좋은 설계로 코드를 재구성           어떻게 해야 할까?      개발 프로세스에서는 리팩토링할 시점을 결정하는 게 매우 중요하며…   시점을 정하는 가장 좋은 방법은 범위를 정하는 것   한 번에 한 가지 명확하고 구체적인 목표를 갖고 진행하는 것이 중요   코드 리팩토링의 유형      신규 기능 추가를 대비한 “준비를 위한 리팩토링”   높은 가독성을 고려한 “이해를 위한 리팩토링”   준비를 위한 리팩토링      목적 : 신규 기능을 추가하기 전에, 코드를 쉽게 추가할 수 있도록 대비            현재 구조를 살펴보고, 추가되는 코드가 기존 구조에 녹여지기 어렵다면… 해당 구조를 다듬어서 새로운 기능을 쉽게 적용 가능할 수 있도록 만들어주자       Good Fit? »Yes» Add New Feature       Good Fit? »No» Refactoring to Good Fit » Add New Feature           예제1) 파편화된 코드      동일 코드가 반복적으로 작성되어 있다면…   별도의 Function으로 만들고, 이를 호출하는 방식으로 관심사를 분리   function printOwing(invoice) {   printBanner();   let outstanding = calculateOutstanding();    // print details   console.log(`name: ${invoice.customer}`);   console.log(`amount: ${outstanding}`); }   function printOwing(invoice) {   printBanner();   let outstanding = calculateOutstanding();   printDetails(outstanding);    function printDetails(outstanding) {     console.log(`name: ${invoice.customer}`);     console.log(`amount: ${outstanding}`);   } }   예제2) 중복된 유사 로직      의미가 유사한 function이 2개 이상 존재하면…   매개변수를 이용하는 것으로 function을 통합   function tenPercentRaise(aPerson) {   aPerson, salary = aPerson.salary.multiply(1.1); } function fivePercentRaise(aPerson) {   aPerson, salary = aPerson.salary.multiply(1.05); }   function raise(aPerson, factor) {   aPerson, salary = aPerson.salary.multiply(1 + factor); }   예제3) 모든 분기마다 동일 로직      조건부 모든 분기에 동일 로직을 구현했다면…   분기 밖으로 해당 로직을 이동시켜서, 한 번만 작성   if(isSepcialDeal()) {   total = price * 0.95;   send(); } else {   total = price * 0.98;   send(); }   if(isSepcialDeal()) {   total = price * 0.95; } else {   total = price * 0.98; } send();   이해를 위한 리팩토링      목적 : 코드의 의도를 이해할 수 있도록 가독성을 높인다.            코드를 수정하기 위한 전제조건은 그 코드가 무슨 일을 하는지 파악하는 것       협업하는 동료와 함께 보는 코드는 의도가 명확하게 드러나야 함       더 좋은 설계를 위해서는 사소한 것부터 명확하게 만드는 것이 중요           예제1) 모호한 변수명      a, b, c 등의 의도를 알 수 없는 모호한 변수명이라면…   변수명을 직관적으로 선언   좋은 프로그래머는 사람이 이해할 수 있는 코드를 작성   let a = height * width;   let area = height * width;   예제2) 길어지는 표현식      하나의 표현식이 너무 길어지는 경우에는…   표현식 또는 해당 부분의 결과를 의도 파악이 가능한 개별 변수로 선언   return order.quantity * order.itemPrice -   Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 * Math.min(order.quantity * order.itemPrice * 0.1, 100);   const basePrice = order.quantity * order.itemPrice; const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05; const shipping = Math.min(basePrice * 0.1, 100); return basePrice - quantityDiscount * shipping;   예제3) 변수가 한 번만 변경      변경되는 변수가 하나뿐이라면…   해당변수가 원래 표현식과 다를 바 없을 때는, 변수 선언 대신 인라인해서 리턴값으로 처리   let basePrice = anOrder.basePrice; return (basePrice &gt; 1000);   return anOrder.basePrice &gt; 1000;   비효율적인 때는?      코드 판독 자체가 불가하여 오히려 시간 낭비인 경우   코드가 정상 작동하지 않는다면, 새로 짜는 것이 낫다   납기가 임박했을 때는 지양   성능개선 vs 리팩토링      성능을 높이는 작업도, 리팩토링의 작업 패턴은 유사   그러나 성능 개선은 속도를 높이기 위한 목적이고…   코드 리팩토링은 코드를 깨끗하게 만들기 위함   왜 필요해요?      코드 리팩토링을 왜 해야 하나요?   시간 낭비하는 거 아닌가요?   “깨끗하고 좋은 코드를 만들기 위해서”   설계에 대한 고민없이 작성된 코드는 초반에는 개발속도가 빠르지만…   코드 구조는 한 번 엉망이 되면, 시간이 갈수록 더 엉망진창이 되고…   새로운 기능을 추가할수록, 개발 속도가 점점 뎌뎌진다.   반면, 좋은 설계의 프로그램은 시간이 갈수록 개발 생산성이 높아진다   궁극적 목적      Enconomics(경제성)   적은 인력으로 짧은 시간에 많은 기능을 개발하기 위해…   퀴즈      좋은 코드의 판단 기준은 대표적으로 유지보수성, 확장성, 가독성이 있습니다.   코드 리팩토링을 하기에 적절한 시점은? 기능 개발이 완료된 후   코드 리팩토링의 대표적 유형 두 가지는? 준비, 이해   코드 리팩토링의 궁극적 목적은? Economics(경제성)  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%BD%94%EB%93%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/",
        "teaser": null
      },{
        "title": "[Daily Contents] 알아두면 쓸모있는 데이터베이스 객체(기능편3)",
        "excerpt":"    인덱스?      DataBase 분야에서 Table에 대한 동작 속도를 높여주는 자료구조   인덱스의 종류      Clustered Index   Cluster : 군집 Clustered : 군집화 Clustered Index : 군집화된 인덱스      NonClustered Index   NonCluster : 비군집 NonClustered : 비군집화 NonClustered Index : 군집화되어 있지 않은 인덱스   Clustered Index   alter table TBL_CODE add primary key(CODE);      삽입 삭제를 계속하다 보면 속도가 느려진다.   NonClustered Index   create index col_index on TBL_CODE(CODE, NAME);      검색 속도는 느리지만 데이터의 입력/수정/삭제는 더 빠르다.   별도의 저장공간이 필요.   자료구조 - B Tree      B- 트리            트리 형태로 계산함으로서 연산 횟수 감소           Query Plan      사용자 » 파서 » 옵티마이저(규칙 기반, 비용 기반) » 실행계획 » SQL, 실행 엔진   Query Plan - Explain   EXPLAIN SELECT count(*) FROM TBL_BOARED2 WHERE 1=1 AND USER_SEQ = '113'   Query Plan - Index   SELECT count(*) FROM TBL_BOARD2 WHERE 1=1   AND USER_SEQ = '113' ;   SELECT count(*) FROM TBL_Board3 WHERE 1=1   AND USER_SeQ = '113' ;  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%93%B8%EB%AA%A8%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9D%EC%B2%B4(%EA%B8%B0%EB%8A%A5%ED%8E%B83)/",
        "teaser": null
      },{
        "title": "[Daily Contents] 캐싱의 개념과 적용",
        "excerpt":"    고 품질의 AP를 추구한다면   - 안정성 - 보안 - 처리 속도 / 성능 - 편리한 UX   캐시 - 가까운 곳에서 쉽게 볼 수…   - 이미지, CSS, 스크립트 등의 정적 리소스가 대상 - 서버의 리소스 변경(write)이 실시간성으로 클라이언트에 반영되지는 못함 - 얻는 게 있으면 잃는 게 생기는 법   캐시   - 데이터나 값을 복사해 놓는 임시 장소 - 복잡한 수식을 재연산하는 시간을 절약하고 싶은 경우 - 접근 시간이 느린 곳의 데이터를 상대적으로 빠른 장소에 보관 - 캐시 영역에 데이터를 저장해 놓으면 계산, 접근 시간을 대폭 줄일 수 있음   고전은 중요하다      입력 » 중앙처리장치(CPU) - 제어장치, 산술연산장치 » 출력   메모리(Memory Unit) - 프로그램 영역, 데이터 영역   캐시 - CPU   IPC가 개선된 새로운 프로세서 아키텍쳐 성능 하이브리드 아키텍쳐 최대 16개(P 코어 8개 + E 코어 8개) 코어, 최대 24개의 스레드 증가한 인텔 스마트 캐시(L2와 L3캐시 공유)   응답 지연 값      메모리에서 1MB 순차적으로 읽기 -&gt; 250us   디스크에서 1MB 순차적으로 읽기 -&gt; 30ms   한 패킷의 CA로부터 네덜란드까지의 왕복 지연 -&gt; 150ms   온라인 갤러리 구현      디스크에 저장된 10개 이미지 파일을 클라이언트가 요청하면 전송해주는 서버 구현 미션   이미지 파일의 크기는 1MB 이하        파일 변경은 허용하지 않음       개발자는 자주 변하는 것과 변하지 않는 것을 구분할 수 있어야 한다.   변하지 않는다면 굳이 반복해서 읽어들일 필요가 있을까?   웹 서버 - 이미지 리소스      웹 서버는 빈번한 사용이 예상되고 변경이 거의 없을 거라 예상되는 이미지 리소스를 http 요청마다 새롭게 읽어들일까?   메모리에 띄워놓고 요청하면 바로 주는 형식   생활 캐싱      김싸피가 날씨 정보에 대한 콜센터를 열었다. 김싸피는 날씨 정보를 한 번 기록해 두고 요청이 올 때마다 기록해 둔 날씨 정보를 제공한다.   결정적인 단점은?   내가 가지고 있는 정보가 맞는 정보인지 아닌지 확신할 수 없다.   서버로부터 최초로 기록한 정보가 업데이트 될 경우 새로 받아 재기록 하도록 요청.   실시간 지하철 현황 서비스 구현      특정 지하철역의 0호선의 실시간 열차 현황 정보를 제공   정보의 출처는 ‘서울 열린 데이터 광장 Open API’   출퇴근 시간 기준 각 역마다 대략 100건/초의 요청을 가정   클라이언트 요청마다 Open API 호출 수행되는 구조?   역 기준의 대략적인 지하철 도착 현황 정보만으로도 고객의 니즈는 충적   10초 간격으로 WAS 내에 지하철 정보를 임시 저장(캐싱)하도록 구현   캐싱에 적합한 대상은?   1. Write가 빈번하고 Read는 거의 없는 경우 2. Read가 빈번하고 Write는 거의 없는 경우(적합!!)   바람직한 철학은?   1. 가능한 많은 데이터를 캐싱하면 성능 향상을 기대할 수 있다 2. 메모리는 매우 중요한 자원, 신중, 선별적 캐싱 정책이 중요(적합!!)   캐싱 == 메모리 I/O   Out of Memory : 정말 이것만큼은 피할 수 있도록 조심 또 조심   TTL      보통 캐싱된 데이터에는 만료시간 및 갱신 주기가 존재   데이터 sync. 는 너무나도 중요   캐싱 적용기      메뉴 목록을 하드코딩하지는 않을 듯   메뉴 데이터는 DB에 존재한다고 가정   사용자 요청이 많아질수록 DB 조회 많아짐   직접 구현      메모리에 특정 객체를 생성한 후 캐싱하고자 하는 데이터를 저장   단 해당 프로세스에서 유일한 저장 장소가 되도록 잘 선언해서 사용(싱글톤 패턴)   List menuList = new ArrayList();   menuList = selectMenuListFromDB();   Cluster를 구현해야 함   로컬 캐시 - Ehcache      로컬 캐시 라이브러리   WAS n대 클러스터링 되어있다면 동기화 이슈 발생   WAS간 내부 통신을 통해 동기화 작업 선행   Ehcache가 지원하는 RMI 활용한 클러스터링 설정 가능   로컬 캐시 - 단점      타겟 AP이 여러 대의 머신으로 실행 중이라면 데이터 동기화 이슈가 발생   캐시를 활용하려는 프로세스와 동일 머신의 리소스를 사용한다는 점은 매우 큰 단점   Redis   - NoSQL &amp; Cache 솔루션, 메모리 기반으로 구성 - in-memory DB - 데이터베이스로 사용될 수 있으며 Cache로도 사용될 수 있는 기술   캐싱 실전 적용      Cache의 기본적인 개념 파악 및 캐싱에 적합한 데이터 선택   웹 AP 작성 코드에 상대적으로 느린 I/O(DB 연동) 데이터를 직접 특정 객체에 저장   로컬 캐시 적용해보기   In-memory DB 솔루션 Redis 경험해보기  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%BA%90%EC%8B%B1%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A0%81%EC%9A%A9/",
        "teaser": null
      },{
        "title": "[Daily Contents] 코드리뷰",
        "excerpt":"       정적분석 툴 : SonaQube            https://www.sonarqube.org       버그, 취약점, 보안이슈 등 볼 수 있음       버그 등급                    Blocker - 서버 다운될 정도           Critical - 서버 다운 X, 기능 다운 X           Major - 서버 다운 X, 기능 다운 되지는 않으나 기능이 안됨                            배포가 안됨               현업에서는 Major까지 처리를 해야 올림                                                        NullPointerException              버그의 70~80% : NullPointerException           //전 if(image != null){   if(image.getContentType().startWith(\"image\")){   } }  //후 if(image != null &amp;&amp; !image.getContentType()){   if(image.getContentType().startWith(\"image\")){   } }           //전 Member follow = memberRepository.findById(followId).get();  //후 Optional&lt;&gt; aaa = memberRepository.findById(followId).get(); if(aaa.isPresent()){ }           @Transactional은 private에서 쓸 수 없고 public에서만 쓸 수 있음   엔티티로 받으면 안됨            DB에 들어가는 값이 그대로 들어가기 때문에 외부에서 들어오는 값은 바로 set해주면 injection에 취약하기 때문에 vaildation 체크가 필요함       -&gt; HashMap 사용 / Dto or Vo 사용           //전 public ReponseEntity&lt;Void&gt; 뭐시기(@PathVariable(value=\"뭐시기\") 뭐시기 뭐시기, Member member){}  //후 public ReponseEntity&lt;Void&gt; 뭐시기(@PathVariable(value=\"뭐시기\") 뭐시기 뭐시기,HashMap member){ String aaa = member.get(\"name\").toString(); //꺼내와서 하나씩 set해주기 //or Dto나 VO로 담아와서 넣어주기 }      보안이슈            CSRF : 사이트간 요청 위조 Cross-Site request forgery                    http.csrf().disable() - 위험           ex. 악용하는 링크                           세번 이상 쓰이면 상수 선언하여 사용하기   System.out.println(\"SSAFY\" + \"I\"); System.out.println(\"SSAFY\" + \"I LOVE\"); System.out.println(\"SSAFY\" + \"I LOVE YOU\");  ////  String aa = \"SSAFY\"; System.out.println(aa + \"I\"); System.out.println(aa + \"I LOVE\"); System.out.println(aa + \"I LOVE YOU\");  // 최적화 되어있는 것은 아래 // 세번 이상 쓰이면 상수 선언하여 사용하기 // aa라는 메모리에 쓰임 // 위에는 같은 값에도 불구하고 메모리가 세번 쓰임      System.out.println 대신 slf4j나 log4j로 테스트하기            System으로 시작하는게 제일 느려서 시스템 자체가 굉장히 느려지기 때문에 지양하기           객체선언을 하고 또 하는게 문제인 코드   // 전 Snow snow = new Snow.builder().maker(maker)...build(); snow.save(snow);  // 후 repo.save(Snow.builder().maker(maker)…build());      builder랑 new로 생성하는 것의 차이점   Snow snow = new Snow(); snow.setA(a); snow.setB(b);  // 빌더랑 생성자로 선언하는 것과 차이는 복잡한 객체를 생성할 때, 개발자가 실수하지 않게 하는 역할과 가독성적인 부분에서 쓰는걸로 알고 있습니다.! // new로 하면 순서도 그대로 해야하는데 혹시 실수하면 문제가 생김 //-&gt; 빌더 지향      java8의 stream() 함수는 잘 알고 써야함            초기값, 중간계산값, 결과값       맨 마지막은 stream에는 결과에 해당하는 api가 꼭 있어야함                                                                                    forEach                   Collect                                                                   결과 없으면 중간값을 lazy함?                                Transactional(readOnly = true)              jpa에서는 find로 시작하는 것만 있는 경우 사용하기                    save나 update가 필요하면 @modify를 써도 됨                           &lt;?&gt; 와일드카드 사용 지양            어떤 객체 타입이 들어가는지 제대로 명시해주는 것이 좋음           //전 public ResponseEntity&lt;?&gt; 뭐시기메소드(){}  //후 public ResponseEntity&lt;뭐어시기&gt; 뭐시기메소드(){}  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/",
        "teaser": null
      },{
        "title": "[Daily Contents] 테스트주도개발 TDD",
        "excerpt":"    코딩은 결정, 피드백의 연속   이 함수는 이런 기능을 짜야겠군 -&gt; 결정(Decision) 그런데 내가 이 함수를 잘 만든 걸까? -&gt; 피드백(Feedback) 그럼 함수를 완성하고 여기에 피드백을 받을 테스트 케이스를 만들어야겠다!   코드 -&gt; 테스트케이스      현재 시간이 AM, PM인지 판단하여 리턴하는 함수   public string GetAMorPM() {   var now = DateTime.Now;   if(now.Hour &lt; 12) {     return \"AM\";   } else {     return \"PM\";   } }      문제점은? 테스트를 하려면 오전, 오후가 될 때까지 기다려야 하나?   코드부터 작성하면 테스트 코드를 작성하기가 쉽지 않다!   테스트를 어렵게 만드는 것은…?   불확실성 : 임의의 값, 임의의 시간 필요      전역변수, 외부 API서버로부터 받는 값 등   부수작업들…      DB에 기록   메일 발송        외부에 뭔가를 전달하지만 리턴값이 없는…       결정과 피드백 사이의 간격이 커져버린다.(코드 작성 싱에는 왜 몰랐을까?) 좁히려면 너무 많은 비용이 든다. - Kent Back   테스트케이스 -&gt; 코드   테스트케이스   assertThat(getAMorPM(10:00), equalTo(\"AM\")); assertThat(getAMorPM(14:00), equalTo(\"PM\"));   코드 - 여기에 맞춰 코드를 작성하면 외부 라이브러리 Datetime는 개입이 되지 않는다.   public string GetAMorPM(time) {   if(time.Hour &lt; 12) {     return \"AM\";   } else {     return \"AM\";   } }      TDD는 단위 테스트다? 테스트를 많이 해 보는 것이다? (X)   TDD는 테스트부터 짜고 코드를 작성하는 것 (O)   실습: 로그인 기능 개발      로그인 기능에 몇 개의, 어떤 케이스가 필요할까?                  NO       When       Given       Then                       1       로그인 버튼 클릭       ID: 정상 + PW: 일치       정상 로그인                 2       로그인 버튼 클릭       ID 미입력       ID 입력 메세지 팝업                 3       로그인 버튼 클릭       PW 미입력       PW 입력 메세지 팝업                 4       로그인 버튼 클릭       ID 입력 + PW: 불일치       PW 확인 요청 메세지                 5       로그인 버튼 클릭       ID: 없는 ID 입력 + PW: 아무 값       없는 ID 메세지 팝업           파일 : 별도 제공   정리      TDD는 원하는 코드를 먼저 하는 게 아니라 테스트 케이스를 먼저 만들고 이를 만족시켜 가며 목적 함수를 만든다.   테스트부터 짜면 다음과 같은 이점이 있음            테스트 수행 커버리지를 100%로 맞추기 쉽다.       테스트 가능한 코드가 저절로 만들어진다. -&gt; Clean Code의 기초           수행 케이스는 “함수” 관점에서… 관통 케이스를 TDD로 하기는 어렵다.   그럼 단점은?      테스트에 걸리는 시간만큼 개발 시간이 필요하다.   진입장벽이 있어 습관화하기 어렵다.   생각지 못한 테스트의 경우수가 있을 수 있다.  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C-TDD/",
        "teaser": null
      },{
        "title": "[Daily Contents] 정규 표현식",
        "excerpt":"    정규 표현식(Regular expressions)   전화번호, 이메일 유효성 체크할 때나 복/붙해서 쓰는 것 아닌가?   - 개발에는 편집을 포함한 텍스트 관련 작업이 필수 - 선배들의 노하우가 담긴 파워풀한 도구 - 익숙해진다면 손 빠른 개발에 큰 도움을 줄 수 있다   - 온전한 프로그래밍 언어는 아님 - 다른 프로그래밍 언어나 제품에 포함된 '작은 언어' - 제품마다 조금씩 다른 문법   - 텍스트를 찾고 조작하는데 쓰는 문자열 - 텍스트 검색, 치환에 사용 - 수십 라인의 프로그래밍 없이 정규식 1~2줄로 대부분의 문자열 작업 가능   - email, 주민번호, 생년월일 등의 형식 검증(validation) - 데이터 전처리 작업 - 프로젝트 리팩토링 작업 - Database 검색, 치환 작업   - IDE, editor, 심지어 MS Word도 지원   - SW 엔지니어에게 '외국어'같은 존재 - 다양한 문제 해결법 - 친숙해진다면 파워풀한 도구   정규 표현식 온라인 테스트 도구   https://regexr.com   문자 하나 찾기      일반적인 문자 그대로 기재   ’.’와 같은 메타 문자를 검색하려면 ‘'로 이스케이프   문자 집합으로 찾기      대괄호 ([])를 사용하여 문자 집합 표현   [] 집합에 속한 문자 가운데 하나가 일치   [] 내에 ‘-‘은 연속 요소를 표현 [1-5] -&gt; [12345]   캐럿(‘^’) 문자는 집합 안에 있는 문자나 범위를 모두 제외   반복 찾기      파워풀한 정규 표현 패턴의 능력   ’+’: 하나 이상 일치   ’*’: 없거나 하나 이상 일치   ’?’: 없거나 하나 일치   중괄호 ‘{}’ 내에 반복 횟수 기재 {3} : 3번   게으른 수량자로 문자를 최소로 일치   위치 찾기      텍스트 영역 내 특정 위치에서 검색 희망   ‘\\b’: 단어 경계   ’^’: 문자열 경계의 시작   ’$’: 문자열 경계의 끝   하위 표현식      큰 표현식 안에 속한 일부 표현식을 한 항목으로 다루도록 묶음   ’()’: 괄호로 묶음 가능   &gt;{2,} vs (&gt;){2,}   파워풀한 중첩된 하위 표현식   하위 표현식 - 역참조      하위 표현식으로 매칭된 타겟을 참조   일치한 부분을 반복해 찾거나 치환에 사용   텍스트를 검색하고 치환하는데 매우 유용   ‘There is a ball on on the table.’ - 실수로 중복된 전치사?   전방 탐색      일치 영역을 발견해도 그 값을 반환하지 않는 패턴   실제로는 하위 표현식이며 같은 형식으로 작성   (?=일치할 텍스트)   http://project.ssafy.com ftp://pds.ssafy.com https://lab.ssafy.com   /.+(?=:)/g /(?&lt;=\\/\\/).+/g   전후방 탐색 동시 사용   &lt;head&gt;   &lt;title&gt;SSAFY GIT&lt;/title&gt; &lt;/head&gt;   /(?&lt;=&lt;title&gt;).*(?=&lt;\\/title&gt;)/g   역참조 조건 사용      정규 표현식 조건은 물음표(?)를 사용해 정의   역참조 조건은 이전 하위 표현식이 검색에 성공했을 경우에 한하여 다시 해당 표현식을 검사                                   (?(역참조)true           false)                           (02)2256-3112 (032)-789-3256 010-2679-9318 010 4321 1987   /(\\()?\\d{2,3}(?(1)\\)|-)\\d{3,4}-\\d{4}/g   문제      전치사 2개가 각각 역순으로 반복 –&gt; 정상으로   There is a ball on the the on table   /(\\w+)\\*(\\w+)\\*\\2*\\1/g   정규 표현식 책 추천   손에 잡히는 정규 표현식      AP 개발자에게 필요한 내용을 빠르게 습득 가능   마스터 레벨까지 커버하지는 못함   마지막으로      비 개발자도 알아두면 유용한 도구   텍스트를 다루는 모든 작업에 파워풀한 도구   이해가 아닌 체득의 영역  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D/",
        "teaser": null
      },{
        "title": "[Daily Contents] 주니어 개발자 성장 촉진제",
        "excerpt":"    책 읽기의 필요성   책에는 낡은 지식만 있다? 인터넷에 다 있다? 직접 해 보며 배우면 된다? 지루하다.   Classic(변하지 않는 원칙과 지식들) 점과 선, 그리고 면 경험의 한계, 연역적 지식 개발 능력자들이 읽고 쓴 바로 그 책!!   코드 컴플릿 저자   좋은 프로그래밍 책을 두 달에 한 권, 즉 일주일에 35페이지 정도만 읽어도, 당신은 이내 이 분야에 대한 확실한 감을 갖게 될 것이며 주변의 거의 모든 이들과 구별되는 수준으로 올라설 것이다. -스티브 맥코넬-   주니어 개발자의 책 읽기      성장 최소량의 법칙            베테랑 개발자의 내공과 통찰       개발을 더 잘 하려면 어떻게 해야 할까       SW 개발의 생태           무엇을 읽을까   언제 읽을까   어떻게 읽을까            주도적으로 읽기       함께 읽기       싸피 도서관 등 회사의 지원 제도 활용       적용하고 실천하기           언제 읽어도 좋은 책      바비의 컴퓨터 프로그래머가 될래요            절판           실용주의 프로그래머, 2022(2005)            꼭 봐라, 멘토 추천           소프트웨어 장인, 2015            KHI 코치 추천           테스트 주도 개발, 2014            꼭 봐라, 멘토 추천           프로젝트 전 읽으면 좋을 책      훌륭한 프로그래머 되는 법, 2015            Good First           클린 코드, 2013            꼭 봐라, 멘토 추천           디자인 패턴, 2015            어렵다면…           헤드퍼스트 디자인 패턴, 2022   (자매품) 클린 시리즈      클린 아키텍쳐, 2019   클린 코더, 2016            멘토 추천           클린 소프트웨어, 2017            멘토 추천           프로젝트를 하며 읽으면 좋을 책      리픽터링 2판, 2020            멘토 추천           코드 컴플릿 2판, 2017            모니터 받침           이펙티브 자바 3판, 2018            자바 필수           프로젝트를 마치고 읽으면 좋을 책      맨먼스 미신, 2015(1975)            은총알 그 책           피플웨어 3판, 2014   죽음의 행진, 문제 프로젝트에서 살아남는 법, 2005            비수 주의, 절판…           프로그래밍 심리학, 2013(1971)            DHA 코치 추천           휴가 가서 읽으면 좋을 책      해커와 화가, 2015(2004)            멘토 추천, VC 대부           조엘 온 소프트웨어, 2005            그냥 재미있음           코딩 호러, 2014            stackoverflow           취업하고 읽으면 좋을 책      프로젝트 헤일메리, 2021            개발자 출신 소설가(마션 작가)           커리어 스킬, 2019   개발자로 살아남기, 2022            30년 내공           이직 준비할 때 읽으면 좋을 책      CS 전공지식 노트, 2022            CS 동아줄?           코딩 인터뷰 완전 분석, 2017   프로그래밍 면접 이렇게 준비한다, 2019            시작하기 좋음           And More…      데드라인, 2004            S3 컨설턴트 추천       무려 소설!           개발자의 글쓰기, 2019            SYS 코치 추천           1일 1로그 100일 완성 IT 지식, 2022   More and more…      객체지향의 사실과 오해, 2015            GHJ 코치 추천           잘 그리기 금지, 2021            1K 코치 추천           마치며   좋은 책을 읽는 것은 과거의 가장 뛰어난 사람들과 대화를 나누는 것과 같다. - 르네 데카르트  ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/%EC%A3%BC%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%84%B1%EC%9E%A5-%EC%B4%89%EC%A7%84%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[Daily Contents] IT Trends",
        "excerpt":"    IT Trends   Gartner   미국의 정보 및 기술 자문 회사 보고서와 자문 서비스를 판매 Hype Cycle(솔루션)을 제공하여 시장의 기대 값 예측   삼성 SDS   삼성 그룹의 ICT 기업 솔루션 &amp; 플랫폼 &amp; IT 서비스 제공 매년 IT 기술 트랜드를 제공하여, 현재 삼성에서 주목하고 있는 기술을 소개   Quiz      코끼리를 냉장고에 넣는 법?   무소불위의 권력으로 넣도록 한다.   Strategic Technology Trends      Gartner Top 10 Strategic Technology Trends(2012)   1. Media tablets and beyond 2. Mobile-centric application and interfaces 3. Contextual and social user experience 4. Internet of Things 5. App stores and markerplaces 6. Next-generation analythics 7. Big data 8. In-memory computing 9. Extreme low-energy severs 10. Cloud computing      Gartner Top 10 Strategic Technology Trends(2015)   1. Computing Everywhere 2. The Internet of Things 3. 3D Printing 4. Advanced, Pervasive and Invisible Analytics 5. Context-Rich Systems 6. Smart Machines 7. Cloud/Client Computing 8. Software-Defined Applications and Infrastructure 9. Web-Scale IT 10. Risk-Based Security and Self-protection   Quiz      기린을 냉장고에 넣는 법?   코끼리가 있건 말건 그냥 넣는다.   Strategic Technology Trends      Gartner Top 10 Strategic Technology Trends(2019)   Intelligent - Autonomous Things, Augmented Analytics, AI-Driven Development Digital - Digital Twin, Empowered Edge, Immersive Experience Mesh - Blockchain, Smart Spaces (Privacy and Ethics, Quantum Computing)   Quiz      사자가 동물 회의를 개최했습니다. 감히 불참한 동물은?   호랑이   Strategic Technology Trends      Gartner Top 10 Strategic Technology Trends(2021)   사람 중심 - 행동인터넷 IoB, 통합 경험 Total Experience, 개인정보보호 강화 컴퓨팅 위치 독립성 - 분산 클라우드, 어디서나 운영, 사이버 보안망 회복 탄력성 - 지능적 결합가능 비즈니스, 인공지능 공학, 초 자동화      Gartner Top 10 Strategic Technology Trends(2023)   Optimize - Digital Immune System, Applied Observability, AI TRiSM Scale - Industry Cloud Platforms, Platform Engineering, Wireless Value Realization Pioneer - Superapps, Adaptive AI, Metaverse   Metaverse      지금은 좀 안 풀리는데 아모른직다.   Quiz      7기 여러분, 라이브 방송 몇 회나 했을까요?   106회   Live 방송      공통 프로젝트            IT 프로젝트를 하기 위해서 알아야 할 기초적인 지식들       Web의 중요성(현업에서 많은 프로젝트들이 웹 프로젝트)       Git/아키텍쳐/Cloud/프로젝트 배포 등           특화 프로젝트            프로젝트 진행을 위한 특화 Domain과 관련된 기술 전달       다양한 도메인 별 특강 준비       AI/BigData/BlockChain/IoT 제어 등 특화 관련된 방송 위주           자율 프로젝트            IT 업계 속의 다양한 주제 및 기술에 대한 방송 진행       7기 교육생들이 원하는 방송으로 준비하려고 노력       SSAFY 졸업 이후 사회에 나가기 위해 &amp; 나가서 활용할 수 있는 다양한 주제를 준비          ","categories": ["Daily Contents"],
        "tags": ["Daily Contents"],
        "url": "http://localhost:4000/daily%20contents/IT-Trends/",
        "teaser": null
      }]
