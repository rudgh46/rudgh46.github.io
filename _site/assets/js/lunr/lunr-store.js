var store = [{
        "title": "[Git test]",
        "excerpt":"    Test 2   for git   $git commit -m \"Initial Commit\"  ","categories": ["Git & Github"],
        "tags": ["minimal mistakes","jekyll","blog","favicon","disqus","google analytics"],
        "url": "http://localhost:4000/git%20&%20github/gitTestPost/",
        "teaser": null
      },{
        "title": "[Markdown Basic Sytax]",
        "excerpt":"    GitHub에서 README 파일을 작성할 때나, 블로그에 포스팅을 하거나, 간단한 문서를 만들 때 가볍게 사용하는 문서작성 용도로 자주 사용된다. 그래서 오늘은 이 마크다운 언어에 대해서 알아보려고 한다.   0. 마크다운이란?             일반 텍스트 기반의 경량 마크업 언어   일반 텍스트로 서식이 있는 문서를 작성하는데 사용   일반 마크업 언어에 비해 문법이 쉽고 간단   HTML, 리치텍스트(RTF)등 서식 문서로 변환이 용이            응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 쓰임           0-1. 마크다운 에디터      마크다운 에디터는 메모장이나 아무 에디터를 사용해도 무방   단, 미리보기 기능에 따라 사용성에서 큰 차이   따라서 미리보기 기능을 제공하는 에디터 사용 추천(대부분의 IDE에서 (기본 or 확장기능으로) 제공하고 있기는 함.)            ex) VS Code       미리보기 웹사이트(Make a README)           1. 문법(Syntax)           제목 : title              #을 1~6개 사용하여 크기 조절(&lt;H1&gt; ~ &lt;H6&gt; 지원)       HR(Horizontal Rule, 수평선 구분자)와 결합해서 사용 가능           # 제목1 - H1 ## 제목2 - H2 ### 제목3 - H3 #### 제목4 - H4 ##### 제목5 = H5 ###### 제목6 - H6  // HR(Horizontal Rule, 수평선) 구분자와 결합해서 사용 제목 텍스트 1 ___           제목1 - H1       제목2 - H2       제목3 - H3       제목4 - H4       제목5 = H5       제목6 - H6              제목 텍스트 1                 줄바꿈 : Line Breaks              마크다운 문법에서 엔터를 써도 개행이 되지 않음                    엔터키 2번 : 단락 구분                       ’ ‘ : 공백 2번 입력 -&gt; 줄바꿈(개행                                                                                         : Tag로도 가능                                                   // 공백 2개 입력 X 안녕하세요. 김경호, 개발자입니다.  // 공백 2개 입력 안녕하세요. 김경호, 개발자입니다.  // &lt;br&gt;태그 안녕하세요.&lt;br&gt; 김경호, 개발자입니다.           안녕하세요. 김경호, 개발자입니다.       안녕하세요.  김경호, 개발자입니다.       안녕하세요.  김경호, 개발자입니다.            인용문 : BlockQuote              블럭인용문자(‘&gt;’) 사용           &gt; 첫번째 블록 &gt;&gt; 두번째 블록 &gt;&gt;&gt; 세번째 블록                  첫번째 블록                  두번째 블록                      세번쨰 블록                                     블록 안에 다른 마크다운 요소를 넣을 수 있음           &gt; 첫번째 블록 &gt; 1. 두번쨰 블록 &gt; + 세번째 블록                  첫번째 블록                  두번쨰 블록                        세번째 블록                         목록 : List              순서있는 목록 : 숫자와 마침표 사용           // 1. 2. 3. 이런식으로 해도 되지만, 순서대로 번호를 매겨서 표시됨. 1. 첫번째 아이템   1. 하위 아이템   4. 하위 아이템 1. 두번째 아이템 2. 세번쨰 아이템                  첫번째 아이템       하위 아이템       하위 아이템       두번째 아이템       세번쨰 아이템                  순서없는 목록 : (*, - , +) 사용, 혼합가능           + 첫번째 아이템   - 1-1 아이템   - 1-2 아이템   - 1-3 아이템 + 두번쨰 아이템   * 2-1 아이템   * 2-2 아이템 + 세번쨰 아이템   + 3-1 아이템     + 3-1-1 아이템   + 3-2 아이템                  첫번째 아이템                    1-1 아이템           1-2 아이템           1-3 아이템                       두번쨰 아이템                    2-1 아이템           2-2 아이템                       세번쨰 아이템                    3-1 아이템                            3-1-1 아이템                                   3-2 아이템                                        강조(글씨 꾸미기) : Emphasis              볼드, 이텔릭, 밑줄, 취소선 등 이용가능           *single asterisks 이텔릭체* _single underscores 이텔릭체_ **double asterisks 볼드체** __double underscores 볼드체__ ***tripple underscores 볼드+이텔릭체*** ___tripple underscores 볼드+이텔릭체___ ~~cancelline 취소선~~ **~~bold cancelline 볼드+취소선~~** &lt;u&gt;underline - 밑줄&lt;/u&gt;           single asterisks 이텔릭체  single underscores 이텔릭체  double asterisks 볼드체  double underscores 볼드체  tripple underscores 볼드+이텔릭체  tripple underscores 볼드+이텔릭체  cancelline 취소선  bold cancelline 볼드+취소선  underline - 밑줄                    구분선 : Contour              수평선(Horizontal Rule) 사용법           구분선1 - - - // --- : 제목 문법과 중복되므로 주의!  구분선1-1 ---  구분선1-2 ------------------------------  구분선2 ***  구분선2-1 * * *  구분선2-2 ************************************  구분선3 ___           구분선1         구분선1-1     ## 구분선1-2       구분선2     구분선2-1     구분선2-2         구분선3            코드 : Code            인라인(inline) 코드 &lt;img&gt; 태그를 사용하면 본문에 이미지를 삽입할 수 있습니다.       블록(block) 코드               ```bash     $ git push origin master     ```      ```python     print(\"hello world!\")     ```      ```java     public static void main(String[] args){       System.out.println(\"Hello, world\");     }     ```   $ git push origin master   print(\"hello world!\")   public static void main(String[] args){   System.out.println(\"Hello, world\"); }               표 : Table              본문에 테이블 삽입           |Column1(Left[Default])|Column2(Center)|Column3(Right)| |---|:---:|---:| // 표를 정렬하는 방법 |김경호|개발자|JAVA| |rudgh46|BackEnd|JAVA| |제|목표 도메인은|FullStack입니다.| |My|target Domain is|FullStack|                                      Column1(LeftDefault)           Column2(Center)           Column3(Right)                                           김경호           개발자           JAVA                             rudgh46           BackEnd           JAVA                             제           목표 도메인은           FullStack입니다.                             My           target Domain is           FullStack                                        링크 : Link              문서 작성 시, 특정 사이트를 링크할 때 사용           // [Title](link) : 일반적으로 사용되는 형식 [My GitHub](https://github.com/rudgh46)  // &lt;link Address&gt; : 자동 링크 사용 &lt;https://github.com/rudgh46&gt;  // [link keyword][id] : 참조 링크 사용 // [id] : URL \"Optional Title here Link : [Github][My Github Link] [My Github Link]: https://github.com/rudgh46 \"Go to rudgh46's Github\"           My GitHub       https://github.com/rudgh46       Link : [Github][githublink] [githubLink]: https://github.com/rudgh46 “Go to rudgh46’s Github” (이거 왜 안되징…)            이미지 삽입 : Image              본문에 이미지를 삽입       사이즈 조정 및 정렬은 HTML  Tag 사용           ![TEXT](https://imageurl) ![TEXT](./로컬이미지경로.확장자 \"이미지설명\") ![TEXT](data:image/svg+xml;base64,이미지데이터)  // 참조링크를 이용한 이미지 삽입 ![TEXT][ClassE] [ClassE](https://imageurl \"E클래스 이미지\")  // 이미지에 링크 걸기 ![TEXT](https://imageurl, \"이미지설명\")(LinkURL)  // HTML &lt;img&gt; Tag 사용, 크기 및 정렬 가능 &lt;img src=\"https://cdn.eyesmag.com/content/uploads/sliderImages/2021/02/24/the-new-mercedes-benz-c-class-2021-01-fcc19468-f66c-467a-870f-dc1c7aa29e84.jpg\" width=\"200px\"&gt;  &lt;p align=\"center\"&gt;&lt;img src=\"https://www.motorgraph.com/news/photo/202102/27134_86118_4323.jpg\" width=\"400px\"&gt;&lt;/p&gt;                         2. 장단점           장점              문법이 쉽고 직관적       지원 가능한 플랫폼과 프로그램이 다양       다양한 형태로 변환 가능       Text 형식으로 형상관리를 통한 변경이력관리가 용이       별도 도구 없이 편집가능       Text File이라서 용량이 적음                단점             아직까지 표준이 존재 X       Tool/Viewer에 따라 경과물이 다르게 출력           참고 사이트  ","categories": ["Markdown"],
        "tags": ["markdown","syntax","blog","favicon","disqus","google analytics"],
        "url": "http://localhost:4000/markdown/aboutMarkDown/",
        "teaser": null
      },{
        "title": "[Java 01. 기본 문법 및 응용 (Java의 특징, 변수, 데이터 타입)]",
        "excerpt":"    0. 자바의 특징           OOP is A.P.I.E ?                OOP(Object-Oriented-Programming = 객체지향 프로그래밍) is  Abstraction. Polymorphism. Inheritance. Encapsulation                 GC(Garbage Collection)                더 이상 사용하지 않는 메모리를 자동으로 정리하는 기능                  1. 변수           수학에서는 변하는 수 x     컴퓨터에서는 메모리 공간(그릇)     메모리 공간에 값(value)을 할당(assign) 후 사용     공간의 크기는 타입별로 달라짐      2. Type 이란?           데이터의 종류     Primitive Type (기본형)                미리 정해진 크기의 Memory Size로 표현         변수 자체에 값 저장                 Reference Type (참조형)                크기가 미리 정해질 수 없는 데이터의 표현         변수에는 실제 값을 참조할 수 있는 주소만 저장                          Primitive Type                                                       구분               Type               bit 수               값               Wrapper Class                                                               논리형               boolean                               true/false               Boolean                                         정수형               byte               8               -2^7 ~ 2^7-1 (-128 ~ 127)               Byte                                                         short               16               -2^15 ~ 2^15-1 (-32768 ~ 32767)               Short                                                         int               32               -2^31 ~ 2^31-1 (-2147483648 ~ 2147483647, 대략 20억)               Integer                                                         long               32               -2^31 ~ 2^31-1 (-9223372036854775808 ~ 9223372036854775807)               Long                                         실수형               float               32               float f = 0.1234567890123456789f; =&gt; 0.12345679               Float                                                         double               64               double d = 0.1234567890123456789; =&gt; 0.12345678901234568               Double                                         문자형               char               16               \\u0000 ~ \\uffff(0~2^16-1)               Character                                                      총 8개                                   Reference Type                           나머지 모든 데이터 타입(String, int[], Node와 같은 사용자 정의 타입 …)                           // 기본문제 int i1 = Integer.MAX_VALUE; int i2 = i1+1;  System.out.println(i2);  //실행결과 //overflow   3. 형 변환(Type Casting)           변수의 타입을 다른 타입으로 변환하는 것                char &lt;= =&gt; int                 Primitive는 Primitive끼리, Reference는 Reference기리 형 변환 가능                boolean은 다른 기본 타입과 호환되지 않음         기본 타입과 참조형의 형 변환을 위해서 Wrapper 클래스 활용                 형 변환 방법                형 변환 연산자(괄호) 사용                  double d = 100.5; int result = (int)d; // d = 100.5 // result = 100           타입의 표현 범위                byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double         char  -&gt; int …                 타입의 표현 범위가 커지는 방향으로 할당할 경우는 묵시적 형 변환 발생     명시적 형 변환은 값 손실이 발생할 수 있다.     묵시적 형 변환은 값 손실 걱정없이 JVM이 서비스 해줌      //묵시적 형 변환(값 손실 x)       //명시적 형 변환 (값 손실 o) byte b = 10;                    int i = 300; int i = (int)b;                 byte b = (byte)i; int i2 = b;   //기본문제 int i1 = Integer.MAX_VALUE; int i2 = i1 + 1; System.out.println(i2); // -2147483648  long l1 = i1 + 1; System.out.println(l1); // -2147483648  long l2 = (long)(i1 + 1); System.out.println(l2); // -2147483648  long l3 = (long(i1) + 1); System.out.println(l3); // 2147483648  int i3 = 1000000 * 1000000 / 100000; int i4 = 1000000 / 100000 * 100000; System.out.println(i3 + \" : \" + i4); // -7273 : 1000000 , 컴퓨터는 앞에서부터 계산하기 때문에    int k = 66; char c = (char)k; System.out.println(c); // B  c='A'; k=c; System.out.println(k); //65  int i = 10/3; System.out.println(i); //3  float f = 10/3; System.out.println(f); //3.0  float f2 = 10f / 3F; System.out.println(f2); //3.3333333  double d = 10d / 3D; System.out.println(d); //3.3333333333333335  System.out.println((10/3)*3); //9   Wrapper 클래스?      래퍼 클래스(Wrapper Class)는 산술연산을 위해 정의된 클래스가 아니므로 인스턴스에 저장된 값을 변경할 수 없다.  단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스 값만을 참고할 수 있다.  박싱 : 기본타입 -&gt; 래퍼클래스 / 언박싱 : 래퍼클래스 -&gt; 기본타입 (JDK 1.5부터는 컴파일러가 자동처리, 오토 박싱, 오토 언박싱)    Integer num = new Integer(17); //박싱 int n = num.intValue(); //언박싱 System.out.println(n);  Character ch = 'X'; // 오토박싱, Character ch = new Character('X') char c = ch; //오토언박싱, char c = ch.charValue(); System.out.println(c);  //실행결과 //17 //X  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-1/",
        "teaser": null
      },{
        "title": "[Java 01. 기본 문법 및 응용(연산자, 조건문)]",
        "excerpt":"    1. 연산자란?           어떤 기능을 수행하는 기호(+,-,*,/ …)              연산자의 종류와 우선순위 및 결합 방향                                                       연산기호               결합방향               우선순위                                                               (),.                                                                         ++ – +(부호) -(부호) ~ ! (type):형변환               &lt;-               높음                                         * / %               -&gt;                                                         +(덧셈) -(뺄셈)               -&gt;                                                         « » »&gt;               -&gt;                                                         &lt; &gt; &lt;= &gt;= instanceof               -&gt;                                                         == !=               -&gt;                                                         &amp;               -&gt;                                                         ^               -&gt;                                                         ㅣ               -&gt;                                                         &amp;&amp;               -&gt;                                                         ㅣㅣ               -&gt;                                                         ? :               -&gt;                                                         = *= /= %= += -= «= »= »&gt;= &amp;= ^= ㅣ=               &lt;-               낮음                                                        우선순위는 헷갈리기 쉬우니까 (소괄호) 이용하자                  산술 이항 연산자는 연산 전에 피 연산자의 타입을 일치시킨다.  byte b1 = 10; byte b2 = 20; byte b3 = b1 + b2; //Type mismatch: cannot convert from int to byte //피연산자의 크기가 4byte(int) 미만이면 int로 변경한 후 연산 진행  int i1 = 10; long l1 = 20; int i2 = i1 + l1; //Type mismatch: cannot convert from long to int //두 개의 피연산자 중 큰 타입으로 형 변환 후 연산 진행  float f1 = 10.0; float f2 = f1 + 20.0; //Type mismatch: cannot convert from double to float   int i = 10; System.out.println((i--)%2); //0 System.out.println(--i);     //8 System.out.println(i++);     //8 System.out.println(++(i-2)); //컴파일 에러 ++, --는 변수에만 사용할 수 있다.   비트 논리 연산자           2진수 형태로 변환 후 연산                                                       연산자               연산자 기능               결합방향                                                               &amp;               두 피 연산자의 비트 값이 모두 1인 경우만 1, 나머지는 0 (ex&gt; a&amp;b)               -&gt;                                         ㅣ               두 피 연산자의 비트 값이 모두 0인 경우만 0, 나머지는 1 (ex&gt; aㅣb)               -&gt;                                         ^               두 피 연산자의 비트 값이 서로 다르면 1, 같으면 0 (ex&gt; a^b)               -&gt;                                         ~               두 피 연산자의 모든 비트를 반전시킴 -&gt; 1의 보수 (ex&gt; ~a)               &lt;-                                                   a: 10진수 3 -&gt; 2진수 0 0 0 0 0 0 1 1 b: 10진수 5 -&gt; 2진수 0 0 0 0 0 1 0 1  a &amp; b : 0 0 0 0 0 0 0 1 a | b : 0 0 0 0 0 1 1 1 a ^ b : 0 0 0 0 0 1 1 0   비트 이동 연산자 (쉬프트 연산자)           *2, /2에 비해 속도가 빠름                                                       연산자               연산자 기능               결합방향                                                               «               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 왼쪽으로 이동하고 이동에 따른 빈 공간은 0으로 채움 (ex&gt; a«2)               -&gt;                                         »               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 오른쪽으로 이동하고 이동에 따른 빈 공간은 음수는 1, 양수는 0으로 채움 (ex&gt; a»2)               -&gt;                                         »&gt;               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 오른쪽으로 이동하고 이동에 따른 빈 공간은 0으로 채움 (ex&gt; a»&gt;2)               -&gt;                                                   a = 10; b = a &lt;&lt; 1   =&gt; *2와 동일 c = a &gt;&gt; 1   =&gt; /2와 동일   논리 연산자           논리 연산자                                                       연산자               연산자 기능               결합방향                                                               &amp;               두 개의 피 연산자 모두 true인 경우 true (ex&gt; a&gt;0 &amp; b&gt;0)               -&gt;                                         ㅣ               두 개의 피 연산자가 하나라도 true이면 true (ex&gt; a&gt;0 ㅣ b&lt;0)               -&gt;                                         !               단항 연산자로 피 연산자의 값이 false이면 true, true이면 false로 변경 (ex&gt; !a)               &lt;-                                         ^               두 피 연산자가 서로 다를 경우만 true, 같으면 false (ex&gt; true ^ false -&gt; true, true ^ true -&gt; false)               -&gt;                                                                           &amp;         T         F                             ㅣ         T         F                       T         T         F                             T         T         T                       F         F         F                             F         T         F                          Short Circuit 연산자                                                       연산자               연산자 기능               결합방향                                                               &amp;&amp;               &amp;와 동일한 의미이나 앞의 피 연산자가 false이면 뒤의 피 연산자를 검사하지 않는다. (ex&gt; a&gt;0 &amp;&amp; b&gt;0)               -&gt;                                         ㅣㅣ               ㅣ와 동일한 의미이나 앞의 피 연산자가 true이면 뒤의 피 연산자를 검사하지 않는다. (ex&gt; a&gt;0 ㅣㅣ b&gt;0)               -&gt;                                                   2. 조건문   if문           if(_____)                (논리형) boolean b;  (비교식) x&gt;=y  (Method Call) isEven()                           if문 예제      int a = 20; String grade = null;  if(a&gt;=6){                                 if(a&gt;=19)   grade = \"아동\";                            grade = \"성인\"; } else if(a&gt;=13){                            System.out.println(\"성인\");   grade = \"청소년\";                        else if(a&gt;=13) } else if(a&gt;=19){                            grade = \"청소년\";   grade = \"성인\";                          else if(a&gt;=6) } esle{                                      grade = \"아동\";   grade = \"유아\";                          else }                                            grade = \"유아\";  오류 코드           3항 연산자      int a =10; String str = null;  if(a&gt;=10){   str = \"10 이상\"; } else{   str = \"10 미만\"; }  3항 연산자 사용 str = a&gt;=10 ? \"10 이상\" : \"10 미만\";   switch문           switch(_____)                (정수호환) byte, short, char, int x;  (Enum) Day.MONDAY  (Class Object) Byte, Short, Character, Integer, String  (Method Call) getNumber()                           switch문 예제      switch(value) case 1: ...; case 2: ...; break; case 3: ...; case 4: ...; case 5: ...; break; default:  =&gt; ~부터 break 만나기 전 까지 실행  =&gt; value값이 case 조건에 없으면 default 실행   int month = 3; int day = -1; switch(month){   case 2:     day = 29; break;   case 4:   case 6:   case 9:   case 11:     day = 30; break;   default:     day = 31; }   etc. ★Random 수 활용★                           구분         코드         범위                                 Math.random()         double d = Math.random()         0.0 &lt;= d &lt; 1.0                                 double d = Math.random()*N         0.0 &lt;= d &lt; N.0                                 int i = (int)(Math.random()*N)         0 &lt;= i &lt;= N-1                                 int i = (int)(Math.random()*N)+1         1 &lt;= i &lt; N                       Random rand = new Random();                                           rand.nextInt(N)         int i = rand.nextInt(N)         0 &lt;= i &lt; N                                 int i = rand.nextInt(N)+1         1 &lt;= i &lt;= N                     주사위를 던져서 나올 수 있는 경우의 수(1~6) 구하기 (Random 이용)   int N = 6;  int num = (int)(Math.random()*N)+1; System.out.println(num);  Random rand = new Random(); num = rand.nextInt(N)+1; System.out.println(num);  num = rand.nextInt(100)%N+1; System.out.println(num);      주사위를 두 번 던져서 연속적으로 짝수 또는 홀수가 나오면 ‘A’를, 그렇지 않으면 ‘B’를 출력하는 코드   int N = 6; Random rand = new Random(); int num1 = rand.nextInt(N)+1; int num2 = rand.nextInt(N)+1; String result = null;  boolean isNum1Even = num1%2 == 0; boolean isNum2Even = num2%2 == 0;  result = isNum1Even == isNum2Even ? \"A\" : \"B\";  또는  result = (num1 + num2) % 2 == 0 ? \"A\" : \"B\";  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-2/",
        "teaser": null
      }]
