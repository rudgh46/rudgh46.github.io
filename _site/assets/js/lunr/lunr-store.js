var store = [{
        "title": "[Git test]",
        "excerpt":"    Test 2   for git   $git commit -m \"Initial Commit\"  ","categories": ["Git & Github"],
        "tags": ["minimal mistakes","jekyll","blog","favicon","disqus","google analytics"],
        "url": "http://localhost:4000/git%20&%20github/gitTestPost/",
        "teaser": null
      },{
        "title": "[Markdown Basic Sytax]",
        "excerpt":"    GitHub에서 README 파일을 작성할 때나, 블로그에 포스팅을 하거나, 간단한 문서를 만들 때 가볍게 사용하는 문서작성 용도로 자주 사용된다. 그래서 오늘은 이 마크다운 언어에 대해서 알아보려고 한다.   0. 마크다운이란?             일반 텍스트 기반의 경량 마크업 언어   일반 텍스트로 서식이 있는 문서를 작성하는데 사용   일반 마크업 언어에 비해 문법이 쉽고 간단   HTML, 리치텍스트(RTF)등 서식 문서로 변환이 용이            응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 쓰임           0-1. 마크다운 에디터      마크다운 에디터는 메모장이나 아무 에디터를 사용해도 무방   단, 미리보기 기능에 따라 사용성에서 큰 차이   따라서 미리보기 기능을 제공하는 에디터 사용 추천(대부분의 IDE에서 (기본 or 확장기능으로) 제공하고 있기는 함.)            ex) VS Code       미리보기 웹사이트(Make a README)           1. 문법(Syntax)           제목 : title              #을 1~6개 사용하여 크기 조절(&lt;H1&gt; ~ &lt;H6&gt; 지원)       HR(Horizontal Rule, 수평선 구분자)와 결합해서 사용 가능           # 제목1 - H1 ## 제목2 - H2 ### 제목3 - H3 #### 제목4 - H4 ##### 제목5 = H5 ###### 제목6 - H6  // HR(Horizontal Rule, 수평선) 구분자와 결합해서 사용 제목 텍스트 1 ___           제목1 - H1       제목2 - H2       제목3 - H3       제목4 - H4       제목5 = H5       제목6 - H6              제목 텍스트 1                 줄바꿈 : Line Breaks              마크다운 문법에서 엔터를 써도 개행이 되지 않음                    엔터키 2번 : 단락 구분                       ’ ‘ : 공백 2번 입력 -&gt; 줄바꿈(개행                                                                                         : Tag로도 가능                                                   // 공백 2개 입력 X 안녕하세요. 김경호, 개발자입니다.  // 공백 2개 입력 안녕하세요. 김경호, 개발자입니다.  // &lt;br&gt;태그 안녕하세요.&lt;br&gt; 김경호, 개발자입니다.           안녕하세요. 김경호, 개발자입니다.       안녕하세요.  김경호, 개발자입니다.       안녕하세요.  김경호, 개발자입니다.            인용문 : BlockQuote              블럭인용문자(‘&gt;’) 사용           &gt; 첫번째 블록 &gt;&gt; 두번째 블록 &gt;&gt;&gt; 세번째 블록                  첫번째 블록                  두번째 블록                      세번쨰 블록                                     블록 안에 다른 마크다운 요소를 넣을 수 있음           &gt; 첫번째 블록 &gt; 1. 두번쨰 블록 &gt; + 세번째 블록                  첫번째 블록                  두번쨰 블록                        세번째 블록                         목록 : List              순서있는 목록 : 숫자와 마침표 사용           // 1. 2. 3. 이런식으로 해도 되지만, 순서대로 번호를 매겨서 표시됨. 1. 첫번째 아이템   1. 하위 아이템   4. 하위 아이템 1. 두번째 아이템 2. 세번쨰 아이템                  첫번째 아이템       하위 아이템       하위 아이템       두번째 아이템       세번쨰 아이템                  순서없는 목록 : (*, - , +) 사용, 혼합가능           + 첫번째 아이템   - 1-1 아이템   - 1-2 아이템   - 1-3 아이템 + 두번쨰 아이템   * 2-1 아이템   * 2-2 아이템 + 세번쨰 아이템   + 3-1 아이템     + 3-1-1 아이템   + 3-2 아이템                  첫번째 아이템                    1-1 아이템           1-2 아이템           1-3 아이템                       두번쨰 아이템                    2-1 아이템           2-2 아이템                       세번쨰 아이템                    3-1 아이템                            3-1-1 아이템                                   3-2 아이템                                        강조(글씨 꾸미기) : Emphasis              볼드, 이텔릭, 밑줄, 취소선 등 이용가능           *single asterisks 이텔릭체* _single underscores 이텔릭체_ **double asterisks 볼드체** __double underscores 볼드체__ ***tripple underscores 볼드+이텔릭체*** ___tripple underscores 볼드+이텔릭체___ ~~cancelline 취소선~~ **~~bold cancelline 볼드+취소선~~** &lt;u&gt;underline - 밑줄&lt;/u&gt;           single asterisks 이텔릭체  single underscores 이텔릭체  double asterisks 볼드체  double underscores 볼드체  tripple underscores 볼드+이텔릭체  tripple underscores 볼드+이텔릭체  cancelline 취소선  bold cancelline 볼드+취소선  underline - 밑줄                    구분선 : Contour              수평선(Horizontal Rule) 사용법           구분선1 - - - // --- : 제목 문법과 중복되므로 주의!  구분선1-1 ---  구분선1-2 ------------------------------  구분선2 ***  구분선2-1 * * *  구분선2-2 ************************************  구분선3 ___           구분선1         구분선1-1     ## 구분선1-2       구분선2     구분선2-1     구분선2-2         구분선3            코드 : Code            인라인(inline) 코드 &lt;img&gt; 태그를 사용하면 본문에 이미지를 삽입할 수 있습니다.       블록(block) 코드               ```bash     $ git push origin master     ```      ```python     print(\"hello world!\")     ```      ```java     public static void main(String[] args){       System.out.println(\"Hello, world\");     }     ```   $ git push origin master   print(\"hello world!\")   public static void main(String[] args){   System.out.println(\"Hello, world\"); }               표 : Table              본문에 테이블 삽입           |Column1(Left[Default])|Column2(Center)|Column3(Right)| |---|:---:|---:| // 표를 정렬하는 방법 |김경호|개발자|JAVA| |rudgh46|BackEnd|JAVA| |제|목표 도메인은|FullStack입니다.| |My|target Domain is|FullStack|                                      Column1(LeftDefault)           Column2(Center)           Column3(Right)                                           김경호           개발자           JAVA                             rudgh46           BackEnd           JAVA                             제           목표 도메인은           FullStack입니다.                             My           target Domain is           FullStack                                        링크 : Link              문서 작성 시, 특정 사이트를 링크할 때 사용           // [Title](link) : 일반적으로 사용되는 형식 [My GitHub](https://github.com/rudgh46)  // &lt;link Address&gt; : 자동 링크 사용 &lt;https://github.com/rudgh46&gt;  // [link keyword][id] : 참조 링크 사용 // [id] : URL \"Optional Title here Link : [Github][My Github Link] [My Github Link]: https://github.com/rudgh46 \"Go to rudgh46's Github\"           My GitHub       https://github.com/rudgh46       Link : [Github][githublink] [githubLink]: https://github.com/rudgh46 “Go to rudgh46’s Github” (이거 왜 안되징…)            이미지 삽입 : Image              본문에 이미지를 삽입       사이즈 조정 및 정렬은 HTML  Tag 사용           ![TEXT](https://imageurl) ![TEXT](./로컬이미지경로.확장자 \"이미지설명\") ![TEXT](data:image/svg+xml;base64,이미지데이터)  // 참조링크를 이용한 이미지 삽입 ![TEXT][ClassE] [ClassE](https://imageurl \"E클래스 이미지\")  // 이미지에 링크 걸기 ![TEXT](https://imageurl, \"이미지설명\")(LinkURL)  // HTML &lt;img&gt; Tag 사용, 크기 및 정렬 가능 &lt;img src=\"https://cdn.eyesmag.com/content/uploads/sliderImages/2021/02/24/the-new-mercedes-benz-c-class-2021-01-fcc19468-f66c-467a-870f-dc1c7aa29e84.jpg\" width=\"200px\"&gt;  &lt;p align=\"center\"&gt;&lt;img src=\"https://www.motorgraph.com/news/photo/202102/27134_86118_4323.jpg\" width=\"400px\"&gt;&lt;/p&gt;                         2. 장단점           장점              문법이 쉽고 직관적       지원 가능한 플랫폼과 프로그램이 다양       다양한 형태로 변환 가능       Text 형식으로 형상관리를 통한 변경이력관리가 용이       별도 도구 없이 편집가능       Text File이라서 용량이 적음                단점             아직까지 표준이 존재 X       Tool/Viewer에 따라 경과물이 다르게 출력           참고 사이트  ","categories": ["Markdown"],
        "tags": ["markdown","syntax","blog","favicon","disqus","google analytics"],
        "url": "http://localhost:4000/markdown/aboutMarkDown/",
        "teaser": null
      },{
        "title": "[Java 01. 기본 문법 및 응용 (Java의 특징, 변수, 데이터 타입)]",
        "excerpt":"    0. 자바의 특징           OOP is A.P.I.E ?                OOP(Object-Oriented-Programming = 객체지향 프로그래밍) is  Abstraction. Polymorphism. Inheritance. Encapsulation                 GC(Garbage Collection)                더 이상 사용하지 않는 메모리를 자동으로 정리하는 기능                  1. 변수           수학에서는 변하는 수 x     컴퓨터에서는 메모리 공간(그릇)     메모리 공간에 값(value)을 할당(assign) 후 사용     공간의 크기는 타입별로 달라짐      2. Type 이란?           데이터의 종류     Primitive Type (기본형)                미리 정해진 크기의 Memory Size로 표현         변수 자체에 값 저장                 Reference Type (참조형)                크기가 미리 정해질 수 없는 데이터의 표현         변수에는 실제 값을 참조할 수 있는 주소만 저장                          Primitive Type                                                       구분               Type               bit 수               값               Wrapper Class                                                               논리형               boolean                               true/false               Boolean                                         정수형               byte               8               -2^7 ~ 2^7-1 (-128 ~ 127)               Byte                                                         short               16               -2^15 ~ 2^15-1 (-32768 ~ 32767)               Short                                                         int               32               -2^31 ~ 2^31-1 (-2147483648 ~ 2147483647, 대략 20억)               Integer                                                         long               32               -2^31 ~ 2^31-1 (-9223372036854775808 ~ 9223372036854775807)               Long                                         실수형               float               32               float f = 0.1234567890123456789f; =&gt; 0.12345679               Float                                                         double               64               double d = 0.1234567890123456789; =&gt; 0.12345678901234568               Double                                         문자형               char               16               \\u0000 ~ \\uffff(0~2^16-1)               Character                                                      총 8개                                   Reference Type                           나머지 모든 데이터 타입(String, int[], Node와 같은 사용자 정의 타입 …)                           // 기본문제 int i1 = Integer.MAX_VALUE; int i2 = i1+1;  System.out.println(i2);  //실행결과 //overflow   3. 형 변환(Type Casting)           변수의 타입을 다른 타입으로 변환하는 것                char &lt;= =&gt; int                 Primitive는 Primitive끼리, Reference는 Reference기리 형 변환 가능                boolean은 다른 기본 타입과 호환되지 않음         기본 타입과 참조형의 형 변환을 위해서 Wrapper 클래스 활용                 형 변환 방법                형 변환 연산자(괄호) 사용                  double d = 100.5; int result = (int)d; // d = 100.5 // result = 100           타입의 표현 범위                byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double         char  -&gt; int …                 타입의 표현 범위가 커지는 방향으로 할당할 경우는 묵시적 형 변환 발생     명시적 형 변환은 값 손실이 발생할 수 있다.     묵시적 형 변환은 값 손실 걱정없이 JVM이 서비스 해줌      //묵시적 형 변환(값 손실 x)       //명시적 형 변환 (값 손실 o) byte b = 10;                    int i = 300; int i = (int)b;                 byte b = (byte)i; int i2 = b;   //기본문제 int i1 = Integer.MAX_VALUE; int i2 = i1 + 1; System.out.println(i2); // -2147483648  long l1 = i1 + 1; System.out.println(l1); // -2147483648  long l2 = (long)(i1 + 1); System.out.println(l2); // -2147483648  long l3 = (long(i1) + 1); System.out.println(l3); // 2147483648  int i3 = 1000000 * 1000000 / 100000; int i4 = 1000000 / 100000 * 100000; System.out.println(i3 + \" : \" + i4); // -7273 : 1000000 , 컴퓨터는 앞에서부터 계산하기 때문에    int k = 66; char c = (char)k; System.out.println(c); // B  c='A'; k=c; System.out.println(k); //65  int i = 10/3; System.out.println(i); //3  float f = 10/3; System.out.println(f); //3.0  float f2 = 10f / 3F; System.out.println(f2); //3.3333333  double d = 10d / 3D; System.out.println(d); //3.3333333333333335  System.out.println((10/3)*3); //9   Wrapper 클래스?      래퍼 클래스(Wrapper Class)는 산술연산을 위해 정의된 클래스가 아니므로 인스턴스에 저장된 값을 변경할 수 없다.  단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스 값만을 참고할 수 있다.  박싱 : 기본타입 -&gt; 래퍼클래스 / 언박싱 : 래퍼클래스 -&gt; 기본타입 (JDK 1.5부터는 컴파일러가 자동처리, 오토 박싱, 오토 언박싱)    Integer num = new Integer(17); //박싱 int n = num.intValue(); //언박싱 System.out.println(n);  Character ch = 'X'; // 오토박싱, Character ch = new Character('X') char c = ch; //오토언박싱, char c = ch.charValue(); System.out.println(c);  //실행결과 //17 //X  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-1/",
        "teaser": null
      },{
        "title": "[Java 01. 기본 문법 및 응용(연산자, 조건문)]",
        "excerpt":"    1. 연산자란?           어떤 기능을 수행하는 기호(+,-,*,/ …)              연산자의 종류와 우선순위 및 결합 방향                                                       연산기호               결합방향               우선순위                                                               (),.                                                                         ++ – +(부호) -(부호) ~ ! (type):형변환               &lt;-               높음                                         * / %               -&gt;                                                         +(덧셈) -(뺄셈)               -&gt;                                                         « » »&gt;               -&gt;                                                         &lt; &gt; &lt;= &gt;= instanceof               -&gt;                                                         == !=               -&gt;                                                         &amp;               -&gt;                                                         ^               -&gt;                                                         ㅣ               -&gt;                                                         &amp;&amp;               -&gt;                                                         ㅣㅣ               -&gt;                                                         ? :               -&gt;                                                         = *= /= %= += -= «= »= »&gt;= &amp;= ^= ㅣ=               &lt;-               낮음                                                        우선순위는 헷갈리기 쉬우니까 (소괄호) 이용하자                  산술 이항 연산자는 연산 전에 피 연산자의 타입을 일치시킨다.  byte b1 = 10; byte b2 = 20; byte b3 = b1 + b2; //Type mismatch: cannot convert from int to byte //피연산자의 크기가 4byte(int) 미만이면 int로 변경한 후 연산 진행  int i1 = 10; long l1 = 20; int i2 = i1 + l1; //Type mismatch: cannot convert from long to int //두 개의 피연산자 중 큰 타입으로 형 변환 후 연산 진행  float f1 = 10.0; float f2 = f1 + 20.0; //Type mismatch: cannot convert from double to float   int i = 10; System.out.println((i--)%2); //0 System.out.println(--i);     //8 System.out.println(i++);     //8 System.out.println(++(i-2)); //컴파일 에러 ++, --는 변수에만 사용할 수 있다.   비트 논리 연산자           2진수 형태로 변환 후 연산                                                       연산자               연산자 기능               결합방향                                                               &amp;               두 피 연산자의 비트 값이 모두 1인 경우만 1, 나머지는 0 (ex&gt; a&amp;b)               -&gt;                                         ㅣ               두 피 연산자의 비트 값이 모두 0인 경우만 0, 나머지는 1 (ex&gt; aㅣb)               -&gt;                                         ^               두 피 연산자의 비트 값이 서로 다르면 1, 같으면 0 (ex&gt; a^b)               -&gt;                                         ~               두 피 연산자의 모든 비트를 반전시킴 -&gt; 1의 보수 (ex&gt; ~a)               &lt;-                                                   a: 10진수 3 -&gt; 2진수 0 0 0 0 0 0 1 1 b: 10진수 5 -&gt; 2진수 0 0 0 0 0 1 0 1  a &amp; b : 0 0 0 0 0 0 0 1 a | b : 0 0 0 0 0 1 1 1 a ^ b : 0 0 0 0 0 1 1 0   비트 이동 연산자 (쉬프트 연산자)           *2, /2에 비해 속도가 빠름                                                       연산자               연산자 기능               결합방향                                                               «               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 왼쪽으로 이동하고 이동에 따른 빈 공간은 0으로 채움 (ex&gt; a«2)               -&gt;                                         »               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 오른쪽으로 이동하고 이동에 따른 빈 공간은 음수는 1, 양수는 0으로 채움 (ex&gt; a»2)               -&gt;                                         »&gt;               앞의 피 연산자 비트 열을 뒤 피 연산자 만큼 오른쪽으로 이동하고 이동에 따른 빈 공간은 0으로 채움 (ex&gt; a»&gt;2)               -&gt;                                                   a = 10; b = a &lt;&lt; 1   =&gt; *2와 동일 c = a &gt;&gt; 1   =&gt; /2와 동일   논리 연산자           논리 연산자                                                       연산자               연산자 기능               결합방향                                                               &amp;               두 개의 피 연산자 모두 true인 경우 true (ex&gt; a&gt;0 &amp; b&gt;0)               -&gt;                                         ㅣ               두 개의 피 연산자가 하나라도 true이면 true (ex&gt; a&gt;0 ㅣ b&lt;0)               -&gt;                                         !               단항 연산자로 피 연산자의 값이 false이면 true, true이면 false로 변경 (ex&gt; !a)               &lt;-                                         ^               두 피 연산자가 서로 다를 경우만 true, 같으면 false (ex&gt; true ^ false -&gt; true, true ^ true -&gt; false)               -&gt;                                                                           &amp;         T         F                             ㅣ         T         F                       T         T         F                             T         T         T                       F         F         F                             F         T         F                          Short Circuit 연산자                                                       연산자               연산자 기능               결합방향                                                               &amp;&amp;               &amp;와 동일한 의미이나 앞의 피 연산자가 false이면 뒤의 피 연산자를 검사하지 않는다. (ex&gt; a&gt;0 &amp;&amp; b&gt;0)               -&gt;                                         ㅣㅣ               ㅣ와 동일한 의미이나 앞의 피 연산자가 true이면 뒤의 피 연산자를 검사하지 않는다. (ex&gt; a&gt;0 ㅣㅣ b&gt;0)               -&gt;                                                   2. 조건문   if문           if(_____)                (논리형) boolean b;  (비교식) x&gt;=y  (Method Call) isEven()                           if문 예제      int a = 20; String grade = null;  if(a&gt;=6){                                 if(a&gt;=19)   grade = \"아동\";                            grade = \"성인\"; } else if(a&gt;=13){                            System.out.println(\"성인\");   grade = \"청소년\";                        else if(a&gt;=13) } else if(a&gt;=19){                            grade = \"청소년\";   grade = \"성인\";                          else if(a&gt;=6) } esle{                                      grade = \"아동\";   grade = \"유아\";                          else }                                            grade = \"유아\";  오류 코드           3항 연산자      int a =10; String str = null;  if(a&gt;=10){   str = \"10 이상\"; } else{   str = \"10 미만\"; }  3항 연산자 사용 str = a&gt;=10 ? \"10 이상\" : \"10 미만\";   switch문           switch(_____)                (정수호환) byte, short, char, int x;  (Enum) Day.MONDAY  (Class Object) Byte, Short, Character, Integer, String  (Method Call) getNumber()                           switch문 예제      switch(value) case 1: ...; case 2: ...; break; case 3: ...; case 4: ...; case 5: ...; break; default:  =&gt; ~부터 break 만나기 전 까지 실행  =&gt; value값이 case 조건에 없으면 default 실행   int month = 3; int day = -1; switch(month){   case 2:     day = 29; break;   case 4:   case 6:   case 9:   case 11:     day = 30; break;   default:     day = 31; }   etc. ★Random 수 활용★                           구분         코드         범위                                 Math.random()         double d = Math.random()         0.0 &lt;= d &lt; 1.0                                 double d = Math.random()*N         0.0 &lt;= d &lt; N.0                                 int i = (int)(Math.random()*N)         0 &lt;= i &lt;= N-1                                 int i = (int)(Math.random()*N)+1         1 &lt;= i &lt; N                       Random rand = new Random();                                           rand.nextInt(N)         int i = rand.nextInt(N)         0 &lt;= i &lt; N                                 int i = rand.nextInt(N)+1         1 &lt;= i &lt;= N                     주사위를 던져서 나올 수 있는 경우의 수(1~6) 구하기 (Random 이용)   int N = 6;  int num = (int)(Math.random()*N)+1; System.out.println(num);  Random rand = new Random(); num = rand.nextInt(N)+1; System.out.println(num);  num = rand.nextInt(100)%N+1; System.out.println(num);      주사위를 두 번 던져서 연속적으로 짝수 또는 홀수가 나오면 ‘A’를, 그렇지 않으면 ‘B’를 출력하는 코드   int N = 6; Random rand = new Random(); int num1 = rand.nextInt(N)+1; int num2 = rand.nextInt(N)+1; String result = null;  boolean isNum1Even = num1%2 == 0; boolean isNum2Even = num2%2 == 0;  result = isNum1Even == isNum2Even ? \"A\" : \"B\";  또는  result = (num1 + num2) % 2 == 0 ? \"A\" : \"B\";  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-2/",
        "teaser": null
      },{
        "title": "[Java 01. 기본 문법 및 응용(반복문, 배열)]",
        "excerpt":"    1. 반복문   for문           for(변수 초기화; 반복 조건; 증감식){실행문}                           실행 순서 : 1.변수 초기화 -&gt; 2. 반복 조건 체크 -&gt; 3. (반복 조건 true) 실행문 (break 있으면 바로 종료) -&gt; 4. 증감식                           //1부터 10까지 더하기 (for문) int sum = 0;  for(int i=0; i&lt;=10; i++){   sum+=i; } // 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10  //주사위를 100번 던진 결과의 합과 평균값 출력 (for문) int sum = 0; int cnt = 100; double avg = 0;  Random rand = new Random(); for(int i=0; i&lt;cnt; i++){   sum += rand.nextInt(6) + 1; } avg = 1.0*sum/cnt; //sum이 int형이므로 1.0을 곱해서 실수로 형 변환 System.out.printf(\"sum: %d, avg: %f%n\", sum, avg); //%d : 정수, %f : 실수, %n : 개행문자   while문           while(반복조건){실행문, 증감식}                           실행 순서 : 1. 반복 조건 체크 -&gt; 2. 실행문 -&gt; 3. 증감식 (break 있으면 바로 종료) -&gt; 4. 1번부터 다시 반복                           //1부터 10까지 더하기 (while문) int sum = 0; int i = 0;  while(i&lt;=10){   sum+=i;   i++; } //0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10  //주사위를 100번 던진 결과의 합과 평균값 출력 (while문) int sum = 0; int cnt = 100; double avg = 0; int i = 0;  Random rand = new Random(); while(i&lt;cnt){   sum+= rand.nextInt(6) + 1;   i++; } avg = 1.0*sum/cnt; //sum이 int형이므로 1.0을 곱해서 실수로 형 변환 System.out.printf(\"sum: %d, avg: %f%n\", sum, avg); //%d : 정수, %f : 실수, %n : 개행문자   for vs while           for  - 초기값, 조건식, 증감식의 위치가 명확  - 반복 회수 예측이 가능한 반복  - index의 증감 활용     while  - 예측 가변적인 반복  - index보다는 break, continue 활용      ///break, continue 활용                                     //출력 for(int i=1; i&lt;10; i++){                                    1   2   c   4   b   for(int j=1; j&lt;10; j++){                                  2   4   o   8   r     if(j==5) break;                                         3   6   n   12  e     if(j==3) continue;                                      4   8   t   16  a     System.out.print(i*j +\"\\t\");                            5   10  i   20  k   }                                                         6   12  n   24     System.out.println();                                   7   14  u   28 }                                                           8   16  e   32                                                             9   18      36  //outer 활용 outer: for(int i=1; i&lt;10; i++){                             //출력         for(int j=1; j&lt;10; j++){                            1 2 2 4 3 6 4 8 5 10 6 12 7 14 8 16 9 18          if(j==5) break outer;          if(j==3) continue outer;          System.out.print(i*j +\"\\t\");        }          System.out.println();       }           #찍기      for(int i=0; i&lt;5; i++){              for(int i=5; i&gt;0; i--){              for(int i=0; i&lt;5; i++){   for(int j=0; j&lt;=i j++){             for(int j=0; j&lt;i; j++){               for(int j=0; j&lt;i; j++){     System.out.print(\"#\");                System.out.print(\"#\");              System.out.print(\" \");   }System.out.println();              }System.out.println();                } }                                    }                                      for(int j=9-2*i; j&gt;0; j--){                                                                               System.out.print(\"#\");                                                                             }                                                                             System.out.println();                                                                           } //출력                                //출력                               //출력 #                                     #####                               ######### ##                                    ####                                 ####### ###                                   ###                                   ##### ####                                  ##                                     ### #####                                 #                                       #   2. 배열           배열(Array) 사용 이유                           동일한 타입의 변수를 여러개 사용하면?                            변수의 수 증가               코드의 길이 증가               반복문 적용 불가               변수의 수가 동적으로 결정될 경우, 사용 불가                                                           배열(Array)로 동일 타입 변수 묶어서 사용하기                           배열이란?                            동일한 타입의 데이터 0개 이상을 하나의 연속된 메모리 공간에서 관리하는 것               요소에 접근하는 속도가 매우 빠르다.               한번 생성하면 크기 변경 불가                                                           배열(Array) 만들기 #1                           타입 [] 변수명;           타입 변수명[];                            int[] points;               String[] names;                                   변수의 타입과 저장하는 데이터의 타입?                            int a =&gt; a의 타입? int               int [] arr =&gt; arr의 타입? int의 배열타입 (Reference형), arr이 저장하는 데이터 타입? int                                                  배열의 생성과 초기화                           생성                            new keyword와 함께 배열의 데이터 타입 및 크기 지정 : new data_type[length]                                    new int[3]; =&gt; int 타입의 자료 3개를 저장할수 있는 배열을 메모리에 생성                   points = new int[3]; 생성된 배열을 points라는 변수에 할당                   points는 메모리에 있는 배열을 가리키는 reference 타입 변수                                                                   초기화                            배열을 생성과 동시에 자료형에 대한 default 초기화 진행                                                                           자료형         기본값         비고                                 boolean         false                                 char         ‘\\u0000’         곰백문자                       byte, short, int         0                                 long         0L                                 float         0.0f                                 double         0.0                                 참조형 변수         null         아무것도 참조하지 않음                     배열의 사용          -배열은 index번호를 가지고 각 요소에 접근 가능              index 번호는 0부터 시작       배열의 길이 : 배열이름.length로 배열의 크기 조회 가능           int [] points = new int[3]; System.out.printf(\"배열의 크기: %d%n\", points.length); =&gt; 3  points[0] = 1; points[1] = 'A';    //묵시적 형 변환 //points[2] = 1.5;  //double 할당 불가 (배열이 int형이므로)  System.out.printf(\"0 번째 요소: %d%n\", points[0]); // 1 System.out.printf(\"1 번째 요소: %d%n\", points[1]); // 65 System.out.printf(\"2 번째 요소: %d%n\", points[2]); // 0   char[]을 이용해 String “KKH”의 각 문자를 저장하고 출력하는 코드   String str = \"KKH\"; char[] ch = new char[str.length()]; //배열의 길이는 str의 길이  for(int i=0; i&lt;ch.length; i++){   ch[i] = str.charAt(i); //문자열에서 문자를 하나씩 가져오기 }  for(int i=0; i&lt;ch.length; i++){   System.out.print(ch[i]); }   String “1234567890” 의 자리 별 수를 1차원 배열에 저장하고 배열을 순회해서 합 구하기   String str = \"1234567890\"; char[] nums = str.toCharArray(); //char 배열로 만들어줌 int sum = 0; for(int i=0; i&lt;nums.length; i++){   sum += num[i]-'0' } System.out.printf(\"sum: %d%n\", sum);           배열(Array) 만들기 #2                           생성과 동시에 할당                            int [] b = {1,3,5,6,8};               int [] c = new int[] {1,3,5,6,8};                                   선언 후 생성 시 초기화 주의                            int [] points;  points = {1,3,5,6,8}; // 컴파일 오류               int [] points;  points = new int[]{1,3,5,6,8}; // 선언할 때는 배열의 크기를 알 수 없을 때                                                   for-each문           가독성이 개선된 반복문으로, 배열 및 Collections에서 사용     index 대신 직접 요소(elements)에 접근하는 변수를 제공     naturally ready only(copied value)     : 사용     index를 사용하지 않아서 간편해졌지만 index를 사용 할 경우에는 사용 불가      int intArray[] = {1,3,5,7};                                   for(int i=0; i&lt;intArray.length; i++){} for(int x : intArray){                                          int x = intArray[i];   System.out.println(x);                  =                     System.out.println(x); }                                                             }  //순서 바꾸기 (swap) int intArray[] = {1,3,5,7}; int temp = intArray[1]; intArray[1] = intArray[2]; intArray[2] = temp;  for(int x : intArray){   System.out.println(x); }      Array is Immutable          최초 메모리 할당 이후, 변경할 수 없음     개별 요소는 다른 값으로 변경이 가능하나, 삭제할 수는 없음.     크기를 늘리거나 줄일 수 없음      배열 요소의 각 숫자가 몇번 사용 되었는지 숫자별로 사용 횟수 출력   int arr[] = {3,7,2,5,7,7,9,2,8,1,1,5,3}; int used[] = new int[10];  for(int num:arr){   used[num]++; //배열 숫자가 used 배열의 index로 활용 } System.out.println(Arrays.toString(used)); //배열 값 출력           2차원 배열(Array) 만들기 #1                           int Type 기준으로 4*3 배열 만들기                                          선언       생성       할당                       int [][] arr       arr = new int[4][3];       arr[0][2] = 3;                 int arr[][]                                 int []arr[]                                   2차원 배열 만들기 #2                           int Type 기준으로 4*3 배열과 값을 동시에 만들기           {}안에 , 와 {}을 이용해서 선언과 동시에 값을 할당                                          선언 생성 할당 동시에                       int [][] arr = {{0,1,2},{0,1,2},{0,1,2},{0,1,2}}                   2차원 배열 만들기 #3                           int Type 기준으로 4*? 배열 만들기           1차 배열만 생성 후, 필요에 따라 2차 배열을 생성함                                          1,2차 선언 / 1차 생성                       int [][] arr = new int[4][]                          2차 생성                       arr[1] = new int[2];                 arr[0] = new int[4];                 arr[2] = {1,2,3}; X           etc. ★배열 탐색★   X로 표시된 항목의 상하좌우 숫자의 합을 구하는 코드                                                            2       3       1       4                 1       X       3       2                 3       4       X       X                 X       4       1       5           int deltas[][] = { {-1,0},{1,0},{0,-1},{0,1}}  int sum = 0; for(int r = 0; r&lt;4; r++)   for(int c=0; c&lt;4; c++)     if(arr[r][c] == 'X'){       for(int d=0; d&lt;4; d++){         int nr = r + deltas[d][0];         int nc = c + deltas[d][1];         if(nr&gt;=0 &amp;&amp; nr&lt;4 &amp;&amp; nc&gt;=0 &amp;&amp; nc&lt;4 &amp;&amp; arr[nr][nc] != 'X'){           sum += arr[nr][nc] - '0';           arr[nr][nc] = '0';         }       }     } System.out.println(sum);  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-3/",
        "teaser": null
      },{
        "title": "[Java 02. 기본 문법 및 응용 (Java의 클래스, 객체, 변수의 종류)]",
        "excerpt":"    0. 객체지향 프로그래밍이란? (Object Oriented Programming)           객체란?                주체가 아닌 것, 주체가 활용하는 것                        우리 주변에 있는 모든 것으로 프로그래밍의 대상 : 사물, 개념, 논리 …                                     객체지향 프로그래밍                주변의 많은 것들을 객체화 해서 프로그래밍 하는것         객체지향은 객체를 많이 만드는 것을 추천한다?? YES!                 객체지향 프로그래밍의 장점                블록 형태의 모듈화된 프로그래밍                        신뢰성 높은 프로그래밍이 가능하다.             추가/수정/삭제가 용이하다.             재사용성이 높다.                                              현실 세계 객체, 클래스, 프로그램의 객체(instance, object)의 관계                현실의 객체가 갖는 속성과 기능은 추상화(abstraction)되어 클래스에 정의된다.         클래스는 구체화 되어 프로그램의 객체(instance, object)가 된다.                 실생활에서의 예) 붕어빵 틀 = Type, 붕어빵 = 객체                프로그램의 클래스와 객체                        클래스                                객체를 정의해 놓은 것 즉 객체의 설계도, 틀                 클래스는 직접 사용할 수 없고 직접 사용되는 객체를 만들기 위한 틀을 제공할 뿐                                         객체(instance, object)                                클래스를 데이터 타입으로 메모리에 생성된 것                                                                        &lt;클래스&gt;                                       &lt;객체&gt; - 객체를 정의해 놓은 것                         - 클래스를 구체화 한 것 - 객체를 생성할 때 사용     =&gt; 구체화 객체화     - 실제로 동작하는 것 - 데이터 타입                                  - 메모리에 생성된 데이터   &lt;현실세계&gt;    철수            영희          =&gt; 객체 이름: 철수      이름: 영희 나이: 40        나이: 38        =&gt; 상태, 속성 - 변수, 필드 배고픔: X       배고픔: X  먹는다          먹는다          =&gt; 기능, 행위 - 메서드, 함수 일한다          일한다  &lt;프로그래밍&gt; -추상화- Person                         =&gt; 클래스 String name: int age:                       =&gt; 멤버변수 boolean isHungry:  void eat()                     =&gt; 멤버메서드 void work()  -구체화-                       =&gt; 객체(메모리 어딘가에 존재해야 사용할 수 있다) Person p = new Person(); p.name = \"철수\"; p.age = 20; p.isHungry = false;  p.eat(); p.work();   추상화로 클래스 만들고 구체화로 객체 사용하기  Person 클래스 작성하기   Public class Person{   //멤버 변수 - 속성   String name;   int age;   boolean isHungry;    //멤버 메서드 - 동작   void eat(){     isHungry = false;     System.out.println(\"먹기\");   }   void work(){     isHungry = false;     System.out.println(\"일하기\");   }    public static void main(String[] args){     Person p1 = new Person();     p1.name = \"홍길동\";     p1.age = 10;     p1.eat();      Person p2 = new Person();     p2.name = \"장길산\"     p2.age = 3;     p2.work();   } } p1 과 p2는 같은 타입일 뿐, 데이터가 공유되거나 하지는 않는다.   객체 생성과 메모리         1. 변수      변수의 종류          타입에 따른 분류                                                       변수 종류               특징               비고                                                               Primitive Type               기본 8가지 type의 변수               int i, char c, float f…                                         Reference Type               나머지 모든 것(객체 참조)               String s, int[] a, Person p…                                                  선언 위치에 따른 분류                                                       종류               변수 종류               선언 위치                                                               멤버 변수               클래스 멤버변수               클래스 영역 (static keyword)                                                         인스턴스 멤버 변수               클래스 영역                                         지역 변수               지역 변수               함수 내부                                                         파라미터 변수               함수 선언부                                                   public class VariableType {   int instanceVariable; //인스턴스 멤버 변수   static int classVariable; //클래스 멤버 변수   public static void main(String[] args){//파라미터 변수     int localVariable = 10; //로컬변수     for(int i=0; i&lt;100; i++) {//로컬변수      System.out.println(i);     }   } }      인스턴스 멤버 변수의 특징          선언 위치 : 클래스{}영역에 선언     변수의 생성 : 객체가 만들어질 때 객체 별로 생성됨                생성 메모리 영역 : heap                 변수의 초기화 : 타입 별로 default 초기화     변수에 접근 : 객체 생성 후(메모리에 올린 후) 객체 이름(소속)으로 접근                객체를 만들 때 마다 객체 별로 생성 -&gt; 객체마다 고유한 상태(변수 값) 유지                  Person p1 = new Person(); p1.name = \"김경호\"; Person p2 = new Person(); p2.name = \"호경김\"; //////////////////////////////////// 여기까지 작성, 18일 2번째 5:22  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "http://localhost:4000/java/Java_Basic-4/",
        "teaser": null
      },{
        "title": "[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (영속성 관리, 앤티티 매핑)]",
        "excerpt":"    ##  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-1/",
        "teaser": null
      },{
        "title": "[CS 01. 기본이론]",
        "excerpt":"    0. CS기본이론을 배워야 하는 이유           수년 경력을 지닌 경력자가 스택과 큐의 차이점을 설명할 수 없다면 무엇을 믿고 그 사람에게 일을 맡길 수 있을까?   모든 고급 개발 지식과 업무의 기본 근간은 알게 모르게 우리가 배웠던 CS 기본 지식으로 연결된다.   우리는 실무에서 스택과 큐를 직접 구현할 일은 거의 없지만 구현하려는 코드에 어떤 자료구조가 알맞은지, 어떤 알고리즘이나 자료구조를 선택해야 하는지에 대한 의사결정은 CS기본기에서 나온다고 해도 과언이 아니다.     CS 기본이론의 필요성                컴퓨터(시스템)에 대한 이해 (컴퓨터와 제대로 소통하기)         자료구조, 알고리즘 활용법(일의 효율을 높이기)         Coder에서 Developer로 성장         기업목적에 따른 기본적 CS지식이 필요                  1. 소프트웨어 공학           소프트웨어 개발 생명주기                계획 단계에서 유지보수 단계에 이르기까지 일어나는 일련의 절차                  정의단계 What                     타당성 분석 -&gt; 개발 계획 -&gt; 요구사항 분석          - 사용자의 요구사항 확인 및 타당성 검토 (계획, 요구분석)                                                          - 개발에 필요한 요구사항 명세화  개발 단계 How                      설계 -&gt; 개발 -&gt; 테스트                            - 코딩을 통한 프로그램 개발 (설계, 개발, 테스트)                                                       - 단위/통합/시스템/인수/설치 테스트  유지보수 단계 Change                   유지보수 -&gt; 폐기                                  - 시스템 운영 및 운영 중 발생한 문제점들에 대한 유지보수 (적용, 예방, 폐기)                                                         - 새로운 시스템 개발로 인한 기존 시스템 폐기           소프트웨어 개발 프로세스 정의                작업(task)순서의 집합 + 제약조건(일정, 예산, 자원)을 포함하는 일련의 활동                  좁은의미 : 사용자의 요구사항을 SW로 구현하기 위한 절차, 과정  넓은의미 : 사용자의 목적을 이루기 위한 기획, 프로젝트 관리 등을 포함한 절차, 과정, 방법  소프트웨어 개발 7단계 : 계획 - 요구분석 - 설계 - 구현 - 테스트 - 반영 - 유지보수           소프트웨어 프로세스 모델(1)                폭포수 모델         프로토타입 모델         나선형 모델         통합프로세스 모델                 소프트웨어 프로세스 모델(2)                애자일 프로세스 모델                        고객의 요구에 민첩하게 대응하고 그때그때 주어지는 문제를 풀어나가는 방법론                                              소프트웨어 아키텍처 정의                           소프트웨어 아키텍처                            소프트웨어에 대한 전체적인 구조               소프트웨어를 이루고 있는 여러 구성요소(서브시스템, 컴포넌트)               구성 요소들의 인터페이스 간의 상호작용 정의               시스템 설계와 개발 시 적용되는 원칙과 지침                                   소프트웨어 아키텍처의 구성                            구성 요소               구성 요소들 사이의 관계               구성 요소들이 외부에 드러내는 속성               구성 요소들과 주변 환경 사이의 관계               구성 요소들이 제공하는 인터페이스               구성 요소들의 협력 및 조립방법                                                           아키텍처 모델(1)                           데이터 중심형 모델                            주요 데이터가 repository에서 중앙 관리               repository와 여기에 접근하는 서브시스템으로 구성               데이터가 한군데에 모여 있기 때문에 데이터를 모순되지 않고 일관성 있게 관리 가능               새로운 서브시스템의 추가 용이               repository의 병목 현상 발생 가능               서브시스템과 repository 사이의 강한 결합 - repository 변경 시 서브시스템에 영향을 줌                                                  아키텍처 모델(2)                           Client-Server 모델                            네트워크를 이용하는 분산 시스템 형태               데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용               서버 :클라이언트(서브시스템)에 서비스 제공               클라이언트 : 서버가 제공하는 서비스를 요청(호출)하는 서브시스템                                                  아키텍처 모델(3)                           Layering 모델                            기능을 몇 개의 계층으로 나누어 배치               구성 : 하위 계층은 서버, 상위 계층은 클라이언트 역할                                                  아키텍처 모델(4)                           Model/View/Controller 모델                            같은 모델의 서브 시스템에 대하여 여러 뷰 서브시스템을 필요로 하는 시스템에 적합               장점                                    데이터를 화면에 표현(뷰)하는 디자인과 로직(모델)을 분리함으로써 느슨한 결합 가능                   구조 변경 요청 시 수정 용이                                               단점                                    기본 기능 설계로 인한 클래스 수의 증가로 복잡도 증가                   속도가 중요한 프로젝트에 부적합                                                                                   소프트웨어 공학 기출문제           소프트웨어 위기에 대해서 설명하시오.      답변 Point : 소프트웨어 위기에 대한 정형화된 답보다는 실제 사례를 들어서 설명하자  예시 : 2000년대 초반 많은 사람들이 이용했던 싸이월드가 이제는 사용되지 않는 것은 서비스에 대한 다양한 수요를 예측하지 못하고 반영하지 못한 대표적인 사례로 생각합니다. 소프트웨어 위기는 소프트웨어가 더 이상 사용자들의 요구를 충족할 수 없어서 사용자들로부터 외면받는 것을 이야기합니다.  * 소프트웨어 위기란? 소프트웨어 공학 초기에 사용되던 용어로 정돈된 주제가 되기 이전에 사용되었다. 이 용어는 급격한 컴퓨터 계산 용량과 문제의 복잡성이 급격히 증가함에 따라 발생하는 것을 서술하기 위하여 사용되었다. 본질적으로, 이는 정확하고 이해할 수 있고, 검증 가능한 컴퓨터 프로그램을 작성하는 것이 얼마나 어려운가를 뜻한다.           소프트웨어 공학이 필요한 이유는 무엇인지 설명하시오.      답변 Point : 소프트웨어 공학의 적용에 대해서 예시를 들어 설명하자, 소프트웨어들을 비교하면 설명이 쉽다.  예시 : 소프트웨어 공학은 소프트웨어의 개발, 운용, 유지보수 등의 단계를 체계적으로 다루는 학문이라고 합니다. 제가 생각하는 소프트웨어 공학은 **에서 진행했던 프로젝트에서 단기간에 원하는 목적으로 이루기 위해서 소프트웨어를 기획하고, 설계하고, 구현하고, 테스트하고, 보완하는 과정을 걸쳤는데 이 과정을 체계적으로 정리하고 이를 공유하는 과정이 소프트웨어 공학이 아닌가 생각합니다.           소프트웨어 개발 경험과 소프트웨어 개발 시 적용한 개발 방법론이 있다면 설명하시오.      답변 Point : 소프트웨어 개발의 경험을 생각해보면 1개 이상의 방법론이 적용된 것을 알 수 있다. 개발 시 고려한 개발방법론이 없더라도 개발했던 경험을 복기해서 가장 적절한 개발방법론을 적용하자  예시 : **에서 프로젝트를 진행하면서 린 개발 방법을 찾아서 적용했습니다. 린 개발 방법론의 가장 큰 특징인 낭비요소를 제거하고, 지속적인 개선과 수행속도의 향상과 더불어 품질을 효과적으로 개선하는 것인데 **의 프로젝트의 기간이 짧아 어려움을 겪었습니다. 초기 서비스에 대한 방향성을 자신할 수 없어서 지속적으로 서비스를 향상할 수 있는 방법론이 필요했고, 그래서 린 개발 방법론을 찾아서 적용하게 되었습니다. 경험이 많지 않아서 린 개발 방법론의 적용이 쉽지는 않았지만, 단기간에 프로젝트를 완성하는데는 도움이 되었습니다.           소프트웨어 프로젝트 진행 경험에 대해서 설명하시오.      답변 Point : 소프트웨어 진행 경험은 '무엇을 개발하였다' 라기 보단 '어떻게 개발하였다'라고 말하는 것이 필요하다. 그 안에는 개발방법론이나 소프트웨어 아키텍처를 들어서 설명하는 것이 필요하다.  예시 : 대학교 졸업을 위한 프로젝트로 빅데이터를 통한 관광정보 제공 서비스를 개발하였습니다. 관광정보에 대한 빅데이터를 수집하고 분석하여 이용자의 특성(연령, 성별, 지역)에 맞추어 관광정보를 제공하는 서비스를 개발하였습니다. 린(Lean)개발 방법론이 짦은 기간 개발에 적용하기에 적절하다고 하여 적용하였습니다.   2. 프로그래밍           객체지향(1)                객체지향 개요                        소프트웨어 객체는 현실 세계의 객체를 필드와 메서드로 모델링한 것             소프트웨어 객체는 상태를 필드(Field)로 정의하고, 동작을 메서드(Method)로 정의             필드는 객체 내부에 ‘선언된 변수’를 의미하고, 메서드는 객체 내부에 ‘정의된 동작’을 의미함                             절차지향                        일련의 동작을 순서에 맞추어 단계적으로 실행하도록 명령어를 나열             데이터를 정의하는 방법보다는 명령어의 순서와 흐름에 중점                             객체지향                        현실 세계를 객체 단위로 프로그래밍하여, 객체는 필드(데이터)와 메서드(코드)를 하나로 묶어 표현             프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소트프웨어 개발에 많이 사용             소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능                                              객체지향(2)                캡슐화(정보은닉)                        필드와 메서드를 하나의 캡슐처럼 포장해 세부 내용을 외부에서 알 수 없도록 감추는 것                             상속                        상위 객체를 상속받은 하위 객체가 상위 객체의 메서드와 필드를 사용하는 것                             다형성                        대입되는 객체에 따라서 메서드를 다르게 동작하도록 구현하는 기술             실행 도중 동일한 이름의 다양한 구현체 중에서 메서드를 선택 가능                                              Jave의 목적                Write Once Run Anywhere         Java는 platform independent하게 동작         Super Computer부터 Smart Card까지 한번 작성된 코드는 코드의 수정이 없이, 코드의 재컴파일 없이 실행가능                 Java 언어의 개발 목적                Program 개발을 쉽게 하였다         Compile환경이 아니라, Interpreted 환경이다.         한 개 이상의 thread를 사용할 수 있다.         동적으로 program을 변화시킬 수 있다.         Code 자체적으로 security를 보장해준다.                          JVM(Java Virtual Machine)                JVM은 System 마다, 그리고 운영체제 마다 다름                 Garbage Collection (GC)                Java는 프로그래머에게 메모리를 release(최적화)하게 하는 책임을 지우지 않음         GC는 Java Program의 life cycle 동안 자동적으로 동작하여 메모리의 부족을 제거                          Process의 개념                프로그램 - 저장장치에 저장되어 있는 정적인 상태         프로세스 - 실행을 위해 메모리에 올라온 동적인 상태         프로그램이 프로세스가 된다는 것은 운영체제로 부터 프로세스 제어 블록을 얻는다는 뜻         프로세스가 종료된다는 것은 해당 프로세스 제어 블록이 폐기된다는 뜻                 Thread의 개념                프로세스에서 실행 제어만 분리한 실행 단위(프로세스 실행부)         프로세서를 사용하는 기본 단위이며, 명령어를 독립적으로 실행할 수 있는 하나의 제어 흐름         같은 그룹의 스레드는 코드, 주소 공간, 운영체제의 자원(파일, 신호) 등을 공유                          멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법     멀티 프로세싱 : CPU를 여러 개 사용하여 여러 개의 Thread를 동시에 처리하는 작업 환경     CPU 멀티 Thread : 하드웨어적인 방법으로 하나의 CPU에서 여러 Thread를 동시에 처리하는 병렬 처리 기법     멀티 Thread : 운영체제가 소프트웨어적으로 프로세스를 작은 단위의 Thread로 분할하여 운영하는 기법              병행성(concurrency) 문제                두 개 이상의 Thread가 어떤 객체에 있는 하나의 데이터에 접근하게 되는 경우         서로 다른 두 스택에서 실행되는 메소드가 객체에 있는 동일한 객체에 대한 getter/setter 메소드를 호출하게 되는 경우         Thread는 자신이 잠시 중단된 적이(interrupt) 있다는 것을 기억할 수가 없음                 Thread에서의 동기화                다중 Thread 환경에서 한번에 하나의 쓰레드 만이 공유 데이터를 접근할 수 있도록 제어하는 것         여러 Thread가 동시에 실행되는 다중 Thread에서 데이터를 공유하기 위해서는 어떤 Thread가 다른 Thread의 상태와 행동 들을 고려                          형상관리 (1)                정의 : SW개발 및 유지보수 과정에서 발생하는 변경 사항들을 관리하기 위해 개발된 일련의 활동 (소프트웨어 개발의 전 단계에 적용되는 활동으로, 유지보수 단계에서 수행)         목적 : 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증함                 주요 기능 : 버전관리, 리비전 관리, 소스관리, 소스코드 관리              형상관리(2)                종류 : SVN, git, Mercurial, Bazaar 등, 주로 SVN과 git 사용         SVN : 소규모 시스템 적합         git : 대규모 시스템 적합                          빌드도구                소스코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 생성하는 프로그램(프로젝트를 진행하며 시간이 지남에 따라 라이브러리의 버전을 자동으로 동기화)         ANT : XML 기반 빌드 스크립트 개발, 명확한 빌드 절차 정의가 필요         MAVEN : 프로젝트에 필요한 모든 종속성(Dependency)를 리스트의 형태로 관리, 전자정부 프레임원크         Gradle : ANT와 MAVEN의 단점을 보완한 오픈소스 기반의 Build 자동화 도구, 안드로이드 스튜디오                  프로그래밍 기출문제           JAVA와 C의 차이를 설명하시오.      답변 Point : 절차지향 vs 객체지향 / 하드웨어 최적화 vs 하드웨어 독립적 등의 여러 관점에서 비교 설명하자.  예시 : C언어는 아두이노를 활용한 IoT 수업에 사용하였었고, 자바는 안드로이드 어플 제작할 때 사용했습니다. 하드웨어를 제어할 때 C언어가 적합한 언어라고 생각합니다. 자바를 사용할 때에는 다양한 유형의 데이터를 정의와 데이터 간의 관계를 설정, 사용자의 동작을 정의, 구현하는 과정을 거쳤는데, 실제 업무와 유사하여 규모 있는 프로젝트를 개발할 때 자바가 적합했던 언어였습니다.  또한, 개발 환경에 있어서도 윈도우 환경에서 개발한 프로그램을 그대로 리눅스 기반으로 알고 있는 안드로이드 환경에서 동작하는 것을 통해서 하드웨어 독립적으로 운영이 가능한 것이 C언어와 차이라고 할 수 있습니다.           JVM 가비지컬렉션 동작 과정을 설명하시오.      답변 Point : 가비지 컬렉션은 메모리와 연관된다. 소프트웨어 개발 경험 중 메모리 부족 현상을 겪은 경험이 있으면, 경험을 토대로 설명하자.  예시 : 가비지컬렉션은 JVM에서 메모리 관리를 하는 방법으로 더 이상 사용하지 않는 메모리에 대해서 수집해서 스스로 동작해서 사용을 해제하는 기능입니다. C언어를 사용할 때에는 코드에서 메모리의 할당과 함께 해제를 같이 처리해주었는데, 자바에서는 직접 해제하는 기능은 없었고, 사용하지 않는 메모리에 대해서는 메모리의 참조변수에 null을 대입해서 참조변수와 연결된 메모리가 더 이상 사용하지 않음을 JVM에 알려주는 것만으로 메모리해제 요청을 하였습니다.           JAVA에 적용된 OOP에 대해서 설명하시오.      답변 Point : 실제 작업한 사례를 통해서 설명하자. 설계한 객체와 클래스를 비교해서 설명  예시 : [관광정보 제공 서비스 프로젝트 개발] * 서비스에서 제공되는 주요 정보인 관광지/ 식당/ 호텔 등을 객체로 정의 * 관광지를 모델링 한 것을 객체/ 모델링한 관광지를 자바의 코드로 정의한 것은 클래스 * 각 클래스에 실제 관광지 값을 대입하여 메모리에 올린 것은 인스턴스  - 주요 모델링한 정보 : 관광지 이름/ 관광지 주소/ 관광지 위경도/ 관광지 길 탐색 기능  - 클래스에서는 관광지의 이름은 PLACE_NAME의 String 타입으로 정의  - 관광지 위/경도는 PLACE_LAT, PLACE_LNG의 double 타입으로 정의  - 길을 탐색하는 기능은 navigate 라는 메소드로 구현  - 객체는 실 세계를 모델링 한 것이면 클래스는 모델링 한 것을 실제 코드로 구현한 것           형상관리 활용 경험을 설명하시오.      답변 Point : 형상관리 경험이 있다면, 형상관리 경험을 이야기, 경험이 없다면, 회사에서 제공하는 서비스나 소프트웨어를 대상으로 필요성을 설명  예시 : 저는 4명의 팀원과 함께 프로젝트를 진행하였습니다. 이중에 2명은 라이브러리를 개발하고 1명은 서버 측을 1명은 사용자 화면 및 동작을 개발하였습니다. 동시에 같이 개발하면서 서로의 코드를 참조하고, 확인을 위해 SVN을 이용해서 형상관리를 진행하였습니다.  SVN을 활용한 형상관리를 하면서 코드 작업 후 업데이트할 때 오류가 있는 코드를 업데이트 하거나, 업데이트 시 정확한 코멘트를 남기지 않아서 애를 먹었던 경험도 있습니다. 초반에는 혼란을 겪었지만, 수시로 베이스 라인 변경과 통제를 통해 형상관리 프로젝트를 체계적으로 관리할 수 있었습니다.   3. 웹&amp;모바일 서비스           웹 서비스(1)                기존의 웹                        HTTP, HTML, URL과 같은 기술을 통해 인터넷에 분산되어 있는 정보 자원들에 대하여 표준화된 접근과 정보 표현 방법                             웹 서비스                        ‘XML’과 ‘인터넷 프로토콜’을 통해 ‘표준화된 방식으로 상호작용’             새로운 기술이라기 보다는 컴포넌트, 인터넷, XML등의 기술을 새로운 개념으로 적용하는 방법론             기본적인 표준 인프라가 구축되어 있는 경우에는 그것을 바탕으로 무궁무진한 활용이 가능                             웹서비스의 특징                        플랫폼에 독립적             동적인 기능(Dynamic Function)             비용 효율적             기존 시스템(Legacy System)에 적용                                              웹 서비스 동작 흐름              웹 서버              정적페이지와 동적 웹페이지                정적 웹페이지                        컴퓨터에 저장된 텍스트 파일 그대로 보는것             HTML                             동적 웹페이지                        저장된 내용을 다른 변수로 가공 처리하여 보는 것             PHP, ASP, JSP                                              클라이언트 - 서버                클라이언트-서버 모델 기반                        서버 : 서비스 정보들을 보관하고 이를 제공해주는 컴퓨터             클라이언트 : 사용자가 서버에서 제공하는 정보를 받는 컴퓨터                             서버 프로그램                        호스트 컴퓨터에 서버 역할을 수행             아파치 또는 IIS등 웹 서버 프로그램             FTP 서비스의 경우 FTP 서버 프로그램                             클라이언트 프로그램                        사용자가 서버에 접속하여 서비스 이용             Chrome, Explorer와 같은 웹 브라우저 프로그램/ FTP 클라이언트 프로그램 필요                                              웹 서버의 구성 예시                윈도우 서버 환경 구축 예시                        Window Server + TOMCAT + JSP + (Oracle)                             리눅스 서버 환경 구축 예시                        리눅스 Server + APACHE + TOMCAT + JSP + (My SQL)                                              모바일 서비스                시스템 소프트웨어                        모바일 운영체제(OS) : 모바일 단말기용 시스템 소프트웨어                             애플리케이션                        다운로드 애플리케이션 (사용자가 직접 다운로드 하여 실행)             모바일 웹 브라우저 (모바일 기기에서 실행되는 웹브라우저)             내장 애플리케이션 (모바일 운영체제에 직접 구현된 프로그램)                             모바일 운영체제(OS)                        휴대폰에서 PC의 운영체제와 같은 역할을 수행             스마트폰의 프로세서, 메모리, 화면 등의 하드웨어를 관리하고 운영             모바일 애플리케이션이 실행되는 소프트웨어 플랫폼 역할             공개형(Open) 모바일 운영체제가 대세                                              모바일 앱 vs 모바일 웹 vs 하이브리드 앱                모바일 앱                        디바이스에 최적화             플랫폼 전용 언어로 개발함             안드로이드 -java / Kotlin             아이폰 - Object-C / Swift                             하이브리드 앱                        유지보수의 편의성             하이브리드 앱 전용 언어로 개발함             React Native             Flutter             XAMARIN             IONIC                             모바일 웹(앱)                        모바일 웹가 모바일 앱의 호환             유지보수의 편의성             모바일 웹을 앱으로 제젝             HTML5 / CSS3 기반의 모바일 웹 개발 후 WebView에서 제공                                      웹&amp;모바일 기출문제           AJAX가 무엇인지 예를 들어서 설명하시오.      답변 Point : 기술적인 접근보다는 서비스를 예시로 설명하자. 쉽게 접할 수 있는 사례를 찾아서 설명한다.  예시 : AJAX는 비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법으로 주로 회원가입 시 아이디 중복검사나 비밀번호 유효성 검사 등에 사용합니다. 웹 페이지는 화면을 이동할 때 마다 화면의 컨텐츠를 다시 가져와서 표시하는데, 웹 서비스 중에는 현재의 화면을 그대로 둔 채로 특정 영역의 데이터를 추가/ 삭제/ 변경 등의 기능을 쓸 때 AJAX을 활용합니다. AJAX를 사용하면 화면 전체를 재 로딩함으로 발생하는 트래픽의 증가도 필요한 영역의 적은 데이터만 통신함으로 트래픽을 줄이는 효과도 있습니다.           웹 브라우저 검색창에서 키워드를 입력하면 결과가 나오는 과정을 설명하시오.      답변 Point : 웹 서버의 흐름을 생각하고, 키워드를 입력 받아 웹서버에서 처리해서 반환하는 과정을 도식화해서 설명  예시 : 웹 브라우저에 검색 창에 키워드를 입력하면 웹 사이트의 검색창에 정의된 form의 method(get/post)의 방식으로 action에 기록된 서버로 검색 키워드를 전송하게 됩니다. 서버는 검색 키워드를 전송 받으면 검색 키워드와 관련하여 구현된 비즈니스 로직을 실행시키고, 그 결과를 HTML로 구성하여 다시 웹 브라우저로 전송합니다. 웹 브라우저는 서버로 부터 새로운 HTML이 오면 결과를 화면에 보여지게 합니다.  ","categories": ["CS"],
        "tags": ["CS"],
        "url": "http://localhost:4000/cs/CS_Basic_1/",
        "teaser": null
      },{
        "title": "[CS 02. 기본이론]",
        "excerpt":"    1. 자료구조           자료구조의 분류                정의                        자료를 효율적으로 표현하고 처리할 수 있도록 정리하는것                             자료의 분류                        단순구조 (정수, 실수, 문자, 문자열 등의 기본 자료형)             선형구조 (자료들 사이의 관계가 1:1관계/ 순차 리스트, 연결 리스트, 스택, 큐, 데크 등)             비선형구조 (자료들 사이의 관계가 1:다, 또는 다:다 관계/트리, 그레프 등)             파일 구조 (서로 관련있는 필드로 구성된 레코드 집합인 파일에 대한 구조, 순차파일, 색인파일, 직접파일 등)                                              순차 자료구조                순차 자료구조의 개념                        구현할 자료들을 논리적 순서로 메모리에 연속 저장하는 구현 방식             논리적인 순서와 물리적인 순서가 항상 일치해야 함             C프로그래밍에서 순차 자료구조의 구현 방식 제공하는 프로그램 기법은 배열                                              선형리스트                리스트                        자료를 구조화 하는 가장 기본적인 방법은 나열하는 것                             선형 리스트                        순서 리스트             자료들 간에 순서를 갖는 리스트                                              연결자료구조                자료의 논리적인 순서와 물리적인 순서가 불일치                        각 원소에 저장되어 있는 다음 원소의 주소에 의해 순서가 연결되는 방식             물리적인 순서를 맞추기 위한 오버헤드가 발생하지 않음                             연결리스트의 종류                        연결하는 방식에 따라 단순 연결 리스트와 원형 연결 리스트, 이중 연결             리스트, 이중 원형 연결 리스트                                              연결리스트                단순 연결 리스트                        단순 연결리스트의 개념                                노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가짐                 연결 리스트, 선형 연결 리스트, 단순 연결 선형 리스트                                                         원형 연결 리스트                        단순 연결 리스트에서 마지막 노드가 리스트의 첫 번째 노드와 연결된 리스트             단순 연결 리스트의 마지막 노드의 링크 필드에 첫 번째 노드 연결             링크를 따라 계속 순회하면 이전 노드에 접근 가능                             이중 연결 리스트                        양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트                                              순차 자료구조와 연결 자료구조의 비교                     구분       순차 자료구조       연결 자료구조                       메모리 저장 방식       메모리의 저장 시작 위치부터 빈자리 없이 자료를   순서대로 연속하여 저장, 논리적 순서와 물리적 순서가 일치       메모리에 저장된 물리적 위치가 순서와 상관없이   링크에 의해서 논리적인 순서를 표현하는 구현 방식                 연산 특징       삽입, 삭제 연산 후 자료가 순서대로 연속하여 저장   변경된 논리적인 순서와 물리적 순서가 일치       삽입, 삭제 연산을 하여 논리적인 순서가 변경되어도,   링크 정보만 변경되고, 물리적인 순서가 변경되지 않음                 프로그램 기법       배열을 이용       포인터를 이용                   스택                스택의 정의                        접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 형태의 자료구조             스택에 저장된 원소는 top으로 정한 곳에서만 접근 가능             Top의 위치에서만 원소를 삽입하므로, 먼저 삽입한 원소는 밑에 쌓이고, 나중에 삽입한 원소는 위에 쌓이는 구조             마지막에 삽입(Last-In)한 원소는 맨 위에 쌓여있다가 가장 먼저 삭제(First-Out)됨             후입선출 구조(LIFO, Last-In-First-Out)                                              큐                큐의 정의                        스택과 비슷한 삽입과 삭제의 위치가 제한되어 있는 유한 순서 리스트             큐는 뒤에서는 삽입만 하고, 앞에서는 삭제만 할 수 있는 구조             삽입한 순서대로 원소가 나열되어 가장 먼저 삽입(First-In)한 원소는 맨 앞에 있다가 가장 먼저 삭제(First-Out)됨             선입선출 구조(FIFO, First-In-First-Out)                                              스택과 큐의 연산 비교                             삽입연산               삭제연산                               자료구조       연산자       삽입위치       연산자       삭제위치                 스택       PUSH       TOP       POP       TOP                 큐       enQueue       rear       deQueue       front                   데크(Deque : Double-ended queue)                데크의 정의                        큐 두 개 중 하나를 좌우로 뒤집어서 붙인 구조             큐의 양쪽 끝에서 삽입 연산과 삭제 연산을 수행할 수 있도록 확장한 자료구조                                              트리                트리(tree)의 정의                        원소들 간에 1:n 관계를 가지는 비선형 자료구조             원소들 간에 계층관계를 가지는 계층형 자료구조 (Hierarchical Data Structure)             상위 원소에서 하위 원소로 내려가면서 확장되는 트리 모양의 구조                                              이진트리                이진트리의 정의                        트리의 모든 노드의 차수를 2 이하로 제한하여 전체 트리의 차수가 2 이하가 되도록 정의             이진트리의 모든 노드는 왼쪽 자식 노드와 오른쪽 자식 노드만 가짐             부모 노드와 자식 노드 수와의 관계 -&gt; 1:2             공백 노드도 자식 노드로 취급             0&lt;= 노드의 차수 &lt;= 2                             이진트리의 종류                        포화 이진트리 Full Binary Tree                                모든 레벨에 노드가 포화상태로 차 있는 이진트리                                         완전 이진트리 Complete Binary Tree                                높이가 h이고 노드 수가 n개일 때 (단, n &lt; 2h+1-1), 노드 위치가 포화 이진트리에서의 노드 1번부터 n번까지의 위치와 완전히 일치하는 이진트리                                         편향 이진트리 Skewed Binary Tree                                높이가 h일 때 h+1개의 노드를 가지면서 모든 노드가 왼쪽이나 오른쪽 중 한 방향으로만 서브 트리를 가지고 있는 트리                                                                          그래프                그래프의 정의                        연결되어 있는 원소 사이의 다:다 관계를 표현하는 자료구조                             그래프 G                        객체를 나타내는 정점(vertex)과 객체를 연결하는 간선(edge)의 집합             G = (V,E)             V 는 그래프에 있는 정점들의 집합             E는 정점을 연결하는 간선들의 집합                             그래프의 종류                        무방향 그래프(undirected graph)                                두 정점을 연결하는 간선에 방향이 없는 그래프                                         방향 그래프(directed graph), 다이그래프(digraph)                                간선에 방향이 있는 그래프                                         완전 그래프(complete graph)                                각 정점에서 다른 모든 정점을 연결하여 최대로 많은 간선 수를 가진 그래프                                         부분 그래프(subgraph)                                원래의 그래프에서 정점이나 간선을 일부만 제외하여 만든 그래프                                         가중 그래프(weight graph), 네트워크(network)                                정점을 연결하는 간선에 가중치(weight)를 할당한 그래프                                                                          알고리즘                알고리즘의 정의                        문제해결 방법을 추상화 하여 단계적 절차를 논리적으로 기술해 놓은 명세서                             알고리즘의 조건                        입력 : 알고리즘 수행에 필요한 자료가 외부에서 입력으로 제공             출력 : 알고리즘 수행 후 하나 이상의 결과를 출력             명확성 : 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어들은 명확하게 정의되어야 함             유한성 : 알고리즘은 수행 뒤에 반드시 종료             효과성 : 알고리즘의 모든 명령어들은 기본적이며 실행이 가능해야 함                             알고리즘 표현방법                        자연어를 이용한 서술적 표현 방법             순서도(Flow chart)를 이용한 도식화 표현 방법             프로그래밍 언어를 이용한 구체화 방법             가상코드(Pseudo-code)를 이용한 추상화 방법                             알고리즘 성능기준                        정확성 : 올바른 자료 입력 시 유한한 시간 내에 올바른 결과 출력 여부             명확성 : 알고리즘이 얼마나 이해하기 쉽고 명확하게 작성되었는가             수행량 : 일반적인 연산 제외, 알고리즘 특성 나타내는 중요 연산 모두 분석             메모리 사용량 : 알고리즘 연산시 메모리의 사용량             최적성 : 가장 중요한 요소로 최적화 된 성능을 가져야 함                                     정렬                정렬의 정의                        순서 없이 배열된 자료를 작은 것부터 큰 것 순서인 오름차순(Ascending)이나 큰 것부터 작은 것 순서인 내림차순(Descending)으로 재배열하는 것             키(Key) - 자료를 정렬하는데 사용하는 기준이 되는 특정 값                             정렬의 종류                        선택 정렬(selection sort)                                전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식으로 정렬                                         버블 정렬(bubble sort)                                인접한 두 개의 원소를 비교하여 자리를 교환하는 방식                                         퀵 정렬(quick sort)                                정렬할 전체 원소에 대해서 정렬을 수행하지 않고, 기준 값을 중심으로 왼쪽 부분 집합과 오른쪽 부분 집합으로 분할하여 정렬하는 방법                                         삽입 정렬(insert sort)                                정렬되어있는 부분집합에 정렬할 새로운 원소의 위치를 찾아 삽입하는 방법                                                                 검색(search)                검색의 정의                        컴퓨터에 저장한 자료 중에서 원하는 항목을 찾는 작업             탐색 키를 가진 항목을 찾는 것                             탐색 키(search key)                        자료를 구별하여 인식할 수 있는 키                             삽입/삭제 작업에서의 검색                        원소를 삽입하거나 삭제할 위치를 찾기 위해서 검색 연산 수행                             수행 위치에 따른 분류                        내부 검색 : 메모리 내의 자료에 대해서 검색 수행             외부 검색 : 보조 기억 장치에 있는 자료에 대해서 검색 수행                             검색 방식에 따른 분류                        비교 검색 방식 : 검색 대상의 키를 비교하여 검색, 순차검색, 이진검색, 트리검색             계산 검색 방식 : 계수적인 성질을 이용한 계산으로 검색, 해싱                             순차 검색(sequential search), 선형 검색(linear search)                        일렬로 된 자료를 처음부터 마지막까지 순서대로 검색하는 방법                             색인 순차 검색(index sequential search)                        정렬되어 있는 자료에 대한 인덱스 테이블(index)을 추가로 사용하여 탐색 효율을 높인 검색 방법                             이진 검색, 이분 검색, 보간 검색                        자료의 가운데에 있는 항목을 키 값과 비교하여 다음 검색 위치를 결정하여 검색을 계속하는 방법                             이진트리 검색                        이진 탐색 트리를 사용한 검색 방법                             해싱                        산술적인 연산을 이용하여 키가 있는 위치를 계산하여 바로 찾아가는 계산 검색 방식             검색 방법                                키 값에 대해서 해시 함수를 계산하여 주소를 구하고, 구한 주소에 해당하는 해시 테이블로 바로 이동                                                                  2. 데이터베이스           데이터의 분류                정형 데이터                        구조화된 데이터, 즉 미리 정해진 구조에 따라 저장된 데이터   예) 엑셀의 스프레드시트, 데이터베이스의 테이블                             반정형 데이터                        구조에 따라 저장된 데이터이지만 데이터 내용 안에 구조에 대한 설명이 함께 존재             구조를 파악하는 파싱(parsing) 과정이 필요   예) HTML, XML, JSON 문서나 웹 로그, 센서 데이터                             비정형 데이터                        정해진 구조가 없이 저장된 데이터   예) 소셜 데이터의 텍스트, 영상, 이미지, 워드나 PDF 문서와 같은 멀티미디어 데이터                                              데이터베이스 관리시스템의 정의                1세대                        네트워크 DBMS(그래프 형태), 계층 DBMS(트리 형태)                             2세대 (관계 DBMS)                        데이터베이스를 테이블 형태로 구성                                오라클, MS SQL 서버, MySQL                                                         3세대 (객체지향 DBMS, 객체관계 DBMS)                        객체지향 DBMS : 객체를 이용해 데이터베이스를 구성                                오투(O2), 온투스(ONTOS), 젬스톤(GemStone)                                         객체관계 DBMS : 객체 DBMS + 관계 DBMS                             4세대 (NoSQL/NewSQL DBMS)                        NoSQL DBMS : 비정형 데이터를 처리하는데 적합하고 확장성이 뛰어남                                몽고디비(MongoDB), 카산드라(Cassandra)                                         NewSQL DBMS : 관계 DBMS의 장점 + NoSQL의 확장성 및 유연성                                구글 스패너(Spanner), 볼트DB(VoltDB), 누오DB(NuoDB)                                                                          데이터베이스 용어                스키마(schema) == 테이블(Table)                        데이터베이스에 저장되는 데이터 구조와 제약조건을 정의한 것                             인스턴스(instance)                        스키마에 따라 데이터베이스에 실제로 저장된 값                             데이터 독립성(data independency)                        하위 스키마를 변경하더라도 상위 스키마가 영향을 받지 않는 특성             논리적 데이터 독립성                                개념 스키마가 변경되어도 외부 스키마는 영향을 받지 않음                                         물리적 데이터 독립성                                내부 스키마가 변경되어도 개념 스키마는 영향을 받지 않음                                                                          데이터베이스 언어                데이터 정의어(DDL; Data Definition Language)                        스키마를 정의하거나, 수정 또는 삭제하기 위해 사용             CREATE, ALTER, DROP, RENAME, TRUNCATE                             데이터 조작어(DML; Data Manipulation Language)                        데이터의 삽입, 삭제, 수정, 검색 등의 처리를 요구하기 위해 사용             절차적 데이터 조작어와 비절차적 데이터 조작어로 구분             SELECT, INSERT, UPDATE, DELETE                             데이터 제어어(DCL; Data Control Language)                        내부적으로 필요한 규칙이나 기법을 정의하기 위해 사용             GRANT, REVOKE                                              View의 정의                관계 데이터베이스의 데이터베이스 언어 SQL에서 하나 이상의 테이블(또는 다른 뷰)에서 원하는 모든 데이터를 선택하여, 그들을 사용자 정의하여 나타낸 것         데이터를 실제로 저장하지 않고 논리적으로만 존재하는 테이블이지만, 일반 테이블과 동일한 방법으로 사용함                          데이터베이스 인덱스                인덱스의 정의                        데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조             인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성             고속의 검색 동작 뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공                                              관계 데이터 모델 키(Key)                릴레이션에서 투플들을 유일하게 구별하는 속성 또는 속성들의 집합                 키의 특성                유일성(uniqueness) : 하나의 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야 함         최소성(minimality) : 꼭 필요한 최소한의 속성들로만 키를 구성함                 키의 종류                슈퍼키(super key) : 유일성을 만족하는 속성 또는 속성들의 집합, 고객아이디, (고객아이디, 고객이름)         후보키(candidate key) : 유일성과 최소성을 만족하는 속성 또는 속성들의 집합, 고객아이디, (고객이름, 주소) 등         기본키(primary key) : 후보키 중에서 기본적으로 사용하기 위해 선택한 키, 고객아이디         대체키(alternate key) : 기본키로 선택되지 못한 후보키         외래키(foreign key) : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합                          제약조건                무결성 제약조건(integrity constraint)                        데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙             무결성 : 데이터를 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것                             개체 무결성 제약조건(entity integrity constraint)                        기본키를 구성하는 모든 속성은 널 값을 가질 수 없는 규칙                             참조 무결성 제약조건(referential integrity constraint)                        외래키는 참조할 수 없는 값을 가질 수 없는 규칙                                      데이터베이스 기출문제           View에 대해 설명하시오.      답변 Point : View 사용 경험을 예를 들어서 설명하자  예시 : 관광정보 정보서비스 제공 프로젝트를 개발할 때 제공되는 정보에는 관광정보에 관광 후기 / 사진정보 등의 여러 정보를 제공해야 했는데, 하나의 쿼리로 데이터를 불러오는 것이 쉽지 않아서 관광정보의 목록을 보여주는 View와 관광지의 정보를 보여주는 View를 만들어서 사용하였습니다.           인덱스에 대해 설명하시오.      답변 Point : 인덱스 사용 경험을 예를 들어서 설명하자. 인덱스를 사용할 때와 사용하지 않을 때의 결과를 비교해서 설명하자.  예시 : 관광정보를 제공하는 서비스를 개발하면서 관광정보에 대한 사용자 후기 정보를 크롤링해서 수집했습니다. 관광정보의 후기 정보의 수집건수가 만 건 이상이 수집되면서 조회속도와 검색 속도가 많이 늦어졌습니다. 이 부분을 해결하기 위해서 검색의 대상이 되는 필드에 대해서 인덱스를 설정하여 속도를 향상하였습니다.    3. 컴퓨터구조           폰노이만 구조                개요                        CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조             폰노이만 구조의 가장 큰 특징은 저장장치에서 바로 실행할 수 없고 메모리로 가지고 올라와야 실행이 가능함                                메모리 관리가 중요한 이슈                                                                          컴퓨터 시스템 구성요소                프로세서(Processor)                        운영체제와 가장 밀접한 하드웨어로 각 부분의 동작 제어 및 연산 수행                             버스(Bus)                        프로세서를 포함한 각 장치 간 또는 서브시스템을 서로 연결하여 정보(데이터)를 주고받을 수 있게 해주는 통로                             레지스터(Register)                        프로세서에 위치한 고속 메모리로 프로세서가 바로 사용할 수 있는 데이터 저장                             메모리(Memory)                        메모리 계층 구조는 1950년 ~ 1960년대 메인 메모리의 높은 가격으로 인해 제안된 방법으로, 다양한 레벨의 메모리를 연결하여 비용, 속도, 용량, 접근 시간 등을 상호 보완                             주변장치                        컴퓨터의 기능을 향상시키기 위한 추가 장비                                              운영체제 아키텍쳐                모놀리식 커널                        모든 컴포넌트 커널에 포함             호출 기능만으로 다른 구성 요소와 통신 가능             컴퓨터 시스템에 제한 없이 접근             높은 성능             오류나 악성 코드에 취약                             마이크로커널                        소수의 서비스만 제공             커널 규모 감소, 규모 확장성 향상             구성 요소를 낮은 수준의 권한으로 커널 외부에서 실행             확장성, 이식성, 규모 확장성 향상             모듈 간의 통신이 많아 성능 감소                                              커널                프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모아 놓은 것         단일형 구조 커널                        모듈 간의 통신 비용이 줄어들어 효율적인 운영이 가능                             계층형 구조 커널                        비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들고 계층 간의 통신을 통해 운영체제를 구현하는 방식                             마이크로 구조 커널                        프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공             커널의 각 모듈은 세분화되어 존재하고 모듈 간의 정보교환은 프로세스 간 통신을 이용하여 이루어짐                                              가상머신                가상머신의 정의                        운영체제와 응용 프로그램 사이에서 작동하는 프로그램             가상머신을 설치하면 응용 프로그램이 모두 동일한 환경에서 작동하는 것처럼 보임             자바는 유닉스와 윈도우에서 작동하는 다양한 가상머신을 만들어 배포하는데 이를 자바 가상머신 JavaVirtual Machine, JVM 이라고 함                                              시스템의 주요개념                캐시                        고속 메모리             캐시 적중(cache hit) - 참조하는 정보가 캐시 메모리에 있는 경우             캐시 실패(cache miss) - 참조하는 정보가 메모리에 없는 경우             메모리 참조의 상당수가 캐시 적중되어야 성능 향상 가능             캐시의 예 - L1과 L2 프로세서 캐시             메인 메모리의 일정 부분을 할당해 2차 저장소의 데이터를 캐시하는데 활용                             버퍼                        장치들 사이 혹은 다른 속도로 동작하는 프로세스들 사이에서 데이터를 전송할 때 일시적으로 데이터를 보관하는 저장영역             소프트웨어와 하드웨어 장치들이 데이터를 비동기적으로 전송하게 함으로써 시스템 성능 향상                             스풀링                        한 프로세스와 저속 또는 버퍼가 제한된 입출력 장치 사이에 디스크와 같은 중간 매개체를 두는 기술                             폴링                        CPU가 직접 입출력장치에서 데이터를 가져오거나 내보내는 방식             CPU가 입출력장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 데이터를 처리             CPU가 명령어 해석과 실행이라는 본래 역할 외에 모든 입출력까지 관여해야 하므로 작업 효율이 떨어짐                             인터럽트                        입출력 관리자가 대신 입출력을 해주는 방식             CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영함으로써 시스템의 효율을 높임             데이터의 입출력이 이루어지는 동안 CPU가 다른 작업을 할 수 있음                             인터럽트의 종류                        외부 인터럽트 : 입출력장치로부터 오는 인터럽트뿐 아니라 전원 이상이나 기계적인 오류 때문에 발생하는 인터럽트를 포함             내부 인터럽트 : 프로세스의 잘못이나 예상치 못한 문제 때문에 발생하는 인터럽트             시그널 : 사용자가 직접 발생시키는 인터럽트                                              리눅스 커널                리눅스 커널의 역할                        기본적으로 인터럽트 또는 시스템 콜에 의해 수행됨             모든 작업에 우선하여 동작하는 프로그램             CPU, 메모리, 하드디스크 등의 하드웨어 자원을 제어하여 운영체제의 기본적인 기능을 사용자에게 제공                                프로세스 스케줄링                 기억장치 관리                 파일 시스템 관리                 네트워크 관리                 시스템 콜 인터페이스                 오퍼레이터 콘솔 및 인터페이스 기능                 멀티 프로그래밍 지원                 파일시스템 서비스                 입출력 서비스 등                                         명령 인터프리터(interpreter) 부분은 커널에 내장되어 있지 않으며, 다른 사용자 프로그램과 똑같이 애플리케이션(application) 프로그램으로 독립되어 있음                                      4. 네트워크           TCP/IP                TCP/IP의 시작                        네트워크는 서로 다른 기종의 컴퓨터로 구성되어 있어 각 네트워크 간에 공통으로 사용할 수 있는 프로토콜이 필요             인터넷에서 컴퓨터 간의 통신이 가능하도록 표준화하여 채택한 국제표준통신규약             네트워크와 네트워크를 연결하는 데 사용하는 프로토콜인 TCP/IP는 ‘전송 제어 프로토콜(TCP;Transmission Control Protocol)’과 ‘인터넷 프로토콜(IP; Internet Protocol)’을 의미             인터넷에서 사용하는 응용 프로그램은 대부분 이 TCP/IP 프로토콜을 이용하여 데이터를 교환                             TCP/IP의 구조                        응용 계층 - FTP, 텔넷, SMTP, DNS, DHCP             전송 계층 - TCP, TDP -&gt; 포트 주소             네트워크 계층 - IP, ARP, ICMP -&gt; IP 주소             네트워크 접속 계층 - PPP, SLIP -&gt; 물리 주소             물리주소                                물리 주소(MAC 주소)는 링크 주소 또는 통신망에서 정의된 노드의 주소, 이더넷 네트워크 인터페이스 카드(NIC) 6바이트(48비트) 주소 등을 말한다.                                         인터넷 주소                                인터넷에서는 기존 물리 주소와는 별도로 각 호스트를 식별할 수 있는 유일한 주소를 지정해야 한다.                                         포트주소                                수신지 컴퓨터까지 전송하려면 IP 주소와 물리 주소가 필요하다.                 인터넷 통신의 최종 목적은 한 프로세스가 다른 프로세스와 통신할 수 있도록 하는 것이다.                                                         TCP/IP의 이해                        프로토콜의 필요성                                네트워크는 서로 다른 기종의 컴퓨터로 구성되어 있어 각 네트워크 간에 공통으로 사용할 수 있는 프로토콜의 필요성이 대두                                         프로토콜의 정의                                컴퓨터 간의 통신이 가능하도록 표준화 하여 채택한 통신규약                                         TCP/IP의 정의                                네트워크와 네트워크를 연결하는 데 사용하는 프로토콜인 TCP/IP는 ‘전송 제어 프로토콜(TCP;Transmission Control Protocol)’과 ‘인터넷 프로토콜(IP; Internet Protocol)’을 의미                 인터넷에서 사용하는 응용 프로그램은 대부분 이 TCP/IP 프로토콜을 이용하여 데이터를 교환                                         TCP/IP vs OSI 7                                                     유사점       차이점                       1. 계층 모델이다       1. TCP/IP 모델의 응용 프로그램 계층은   OSI 계층 모델의 표현 계층과 세션 계층은 포함한다.                 2. 응용 프로그램 계층       2. TCP/IP 모델의 네트워크 액세스 계층은 OSI 계층 모델의 데이터 링크 계층과 물리 계층을 포함한다.                 3. 트랜스 포트 계층/ 네트워크 계층과 호환되는 계층       3. TCP/IP 프로토콜은 인터넷 표준                 4. 패킷 스위칭 기술 기반                           TCP/IP 주소                IP Address                        인터넷에 연결된 모든 컴퓨터에는 고유의 주소가 부여             현재 사용하는 IP 주소 체계는 IP ver.4이다.             일반 우편 주소를 시, 동, 번지 등으로 구분하는 것처럼 IP 주소도 네트워크 주소(Net ID)와 호스트 주소(Host ID)로 구분             IP 주소를 효율적으로 배정하려고 클래스라는 개념 도입             클래스에는 A,B,C,D,E 다섯 종류                                Class A : NET ID (1 Byte) + HOST ID (3 Byte)                 Class B : NET ID (2 Byte) + HOST ID (2 Byte)                 Class C : NET ID (3 Byte) + HOST ID (1 Byte)                 Class D : MULTICAST ADDRESS (4 Byte)                 Class E : RESERVED (4 Byte)                                                                 IPv4 vs IPv6                     구분       IPv4       IPv6                       주소 길이       32비트       128비트                 표시 방법       8비스씩 4부분 10진수 표시   ex) 203.252.53.55       16비트 8부분 16진수로 표시   ex) 2002:0221:ABCD:DCBA:0000:FFFF:4002                 주소 개수       약 43억개       2^128개 (약 43억x43억x43억x43억)                 주소할당 방식       A,B,C,D 등의 클래스 단위 비순차 할당       네트워크 규모, 단말기수에 따라 순차할당                 브로드캐스트 주소       있음       없음(대신, 로컬범위 내에서 모든 노드에 대한 멀티캐스트 주소 사용                 헤더 크기       가변       고정                 QoS 제공       미흡       제공                 보안       IPSec 프로토콜 별도 설치       IPSec 자체 지원                 서비스 품질       제한적 품질 보장 (Type of Service에 의한 서비스 품질 일부 지원)       확장된 품질 보장 (트래픽 클래스, 플로우 레이블에 의한 서비스 품질 지원)                 Plug &amp; Play       불가(DHCP 이용 시 가능)       가능                   Routing                패킷의 전송 경로를 지정         전송 경로 결정시 고려 사항                        공평 원칙 : 다른 패킷의 우선 처리를 위해 다른 패킷이 손해를 보면 안됨             효율 원칙 : 전체 네트워크의 효율성에 대해 고려해야 함                             Routing algorithm                        간결성과 시스템 및 네트워크 자원의 최소 사용             라우팅 정보의 안정성과 견고성             라우터간의 라우팅 테이블의 빠른 갱신             네트워크 환경 변화에 따른 갱신                             Static Routing vs Dynamic Routing                        정적 라우팅(Static Routing)                                패킷 전송이 이루어지기 전에 경로 정보를 라우터가 미리 저장하여 중개                 단점 : 경로 정보의 갱신이 어려우므로, 네트워크 변화/ 네트워크 혼잡도 대처 부족                                         동적 라우팅(Dynamic Routing)                                라우터의 경로 정보가 네트워크 상황에 따라 적절히 조절됨                 단점 : 경로 정보의 수집과 관리로 인한 성능 저하                                                         Router                        라우터(Router)는 서로 구조가 다른 망을 연결할 수 있어 근거리 통신망(LAN)과 대도시 통신말(MAN), 광대역 통신망(WAN)을 연결하는 데 사용                                              HTTP 프로토콜                정의                        HTTP(Hypertext Transfer Protocol)는 웹의 기본 통신 프로토콜이다.                                프로토콜이란 상호 간에 정의한 규칙을 의미하며 특정 기기 간에 데이터를 주고받기 위해 정의되었다.                                         웹에서 브라우저와 서버 간에 데이터를 주고받기 위한 방식                             특징                        HTTP 프로토콜은 상태가 없는(stateless) 프로토콜이다.             여기서 상태가 없다 라는 말은 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 뜻             좀 더 쉽게 말해서 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다는 뜻             이러한 특징으로 서버는 세션과 같은 별도의 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있는 성능 상의 이점이 생김             HTTP 프로토콜은 일반적으로 TCP/IP 통신 위에서 동작하며 기본 포트는 80번이다.                             HTTP Request &amp; HTTP Response                        요청과 응답을 이해하기 위해서는 클라이언트(Client)와 서버(Server)를 이해해야 한다.             클라이언트란 요청을 보내는 쪽을 의미하며 일반적으로 웹 관점에서는 브라우저를 의미             서버란 요청을 받는 쪽을 의미하며 일반적으로 데이터를 보내주는 원격지의 컴퓨터를 의미                                              URL                URL의 정의                        서버에 자원을 요청하기 위해 입력하는 영문 주소             숫자로 되어 있는 IP 주소보다는 기억하기 쉽기 때문에 사용                             URL 구조                        http://www.domain.com:1234/path/to/resource?a=b&amp;x=y                                http : protocol                 www.domain.com : host                 1234 : port                 path/to/resource : resource path                 ?a=b&amp;x=y : query                                                                          HTTP 요청메소드                요청한 URL을 이용하여 서버에 특정 데이터를 요청         요청하는 데이터에 특정 동작을 수행하고 싶으면 HTTP 요청 메서드(Http Request Methods)를 이용         HTTP 요청 메소드                        GET : 존재하는 자원에 대한 요청             POST : 새로운 자원을 생성             PUT : 존재하는 자원에 대한 변경             DELETE : 존재하는 자원에 대한 삭제                             이와 같이 데이터에 대한 조회, 생성, 변경, 삭제 동작을 HTTP 요청 메서드로 정의         기타 요청 메서드                        HEAD : 서버 헤더 정보를 획듯. GET과 비슷하나 Response Body를 반환하지 않음             OPTIONS : 서버 옵션들을 확인하기 위한 요청. CORS에서 사용                                              HTTP 상태코드                HTTP 상태코드(HTTP Status Code)                        서버에서 설정해주는 응답(Response) 정보                             2xx - 성공                        200번 대의 사애 코드는 대부분 성공을 의미한다.             200 : GET 요청에 대한 성공             204 : No Content. 성공했으나 응답 본문에 데이터가 없음             205 : Reset Content. 성공했으나 클라이언트의 화면을 새로고침 하도록 권고             206 : Partial Content. 성공했으나 일부 범위의 데이터만 반환                             3xx - 리다이렉션                        300번 대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우이다.             301 : Moved Permanently, 요청한 자원이 새 URL에 존재             303 : See Other, 요청한 자원이 임시 주소에 존재             304 : Not Modified, 요청한 자원이 변경되지 않았으므로 클라이언트에서 캐싱된 자원을 사용하도록 권고. ETag와 같은 정보를 활용하여 변경 여부를 확인                             4xx - 클라이언트 에러                        400번 대의 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우로 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생.             400 : Bad Request, 잘못된 요청             401 : Unauthorized, 권한 없이 요청. Authorization 헤더가 잘못된 경우             403 : Foribidden, 서버에서 해당 자원에 대한 접근 금지             405 : Method Not Allowed, 허용되지 않은 요청 메서드             409 : Conflict, 최신 자원이 아닌데 업데이트 하는 경우. ex) 파일 업로드 시 버전 충돌                             5xx - 서버에러                        500번 대의 상태 코드는 서버 쪽에서 오류가 난 경우이다.             501 : Not Implemented, 요청한 동작에 대해 서버가 수행할 수 없는 경우             503 : Service Unavailable, 서버가 과부하 또는 유지 보수로 내려간 경우                                      네트워크 기출문제           https://www.test.com 이라면 어떻게 동작하는지 설명하시오.      답변 Point : 네트워크 관점에서 동작을 설명하자. 예시 : 이용자가 웹 브라우저에서 www.test.com을 주소창에 입력하면, 웹 브라우저에서는 www.test.com 도메인에 대한 실제 IP ADDRESS를 .RP 프로토콜을 이용해서 DNS에 조회하게 됩니다. 그 이후에 실제 IP ADDRESS를 이용해서 서버의 80 포트를 통해서 서비스를 제공하는 웹 서버에 해당 도메인에 대한 웹 컨텐츠를 요청합니다. 웹 서버는 웹 브라우저를 위한 별도의 포트에 소켓을 개설하고, 그 소켓은 웹 브라우저와 연결됩니다. 웹 서버는 요청 받은 컨텐츠를 웹 브라우저로 보내게 됩니다.           IPv4와 IPv6에 대해서 비교 설명하시오.      답변 Point : IPv4와 IPv6에 대해서 비교 설명하자. 예시 : IPv4가 확장성과 용량 면에서 그 한계가 드러나면서 인터넷 요구 사항의 폭증을 수용하기 위해서 IPv6가 개발되었습니다. IPv6는 IPv4에 비해 다음과 같은 개선점이 있습니다.  1. 패킷을 단편화하지 않고 효율적인 라우팅을 제공함 2. 시간 지연에 민감한 패킷을 구분하는 기본적인 QoS(Quality of Service)를 제공 3. NAT를 없앰으로써 주소 공간을 32비트에서 128비트로 확장 4. 네트워크 레이어 보안을 내장하고 있음 (IPsec) 5. 손쉬운 네트워크 관리를 위한 스테이트리스 주소 자동 구성하고 처리 오버헤드가 줄어든 개선된 헤더 구조를 가지고 있습니다.  ","categories": ["CS"],
        "tags": ["CS"],
        "url": "http://localhost:4000/cs/CS_Basic_2/",
        "teaser": null
      },{
        "title": "[CS 03. 기본이론]",
        "excerpt":"    1. 보안           서비스 거부 공격(DoS)                취약점 공격형                        Boink, Bonk, TearDrop 공격             프로토콜의 오류 제어 로직을 악용해 시스템 자원을 고갈시키는 방식                             랜드 공격                        패킷을 전송할 때 출발지 IP 주소와 목적지 IP 주소의 값을 똑같이 만들어서 공격 대상에게 보내는 것                             자원 고갈 공격형                        죽음의 핑 공격 - 시스템을 파괴하는 데 가장 흔히 쓰인 초기의 DoS 공격             네트워크에서 패킷을 전송하기 적당한 크기로 잘라서 보내는 특성을 이용한 공격                             SYN 플러딩 공격                        네트워크에서 서비스를 제공하는 시스템에 걸려있는 사용자 수 제한을 이용한 공격             존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 제공받지 못하게 함.                             HTTP GET 플러딩 공격                        공격 대상 시스템에 TCP 3-웨이 핸드셰이킹 과정으로 정상 접속한 뒤             HTTP의 GET 메소드로 특정 페이지를 무한대로 실행하는 공격                             스머프 공격                        ICMP 패킷과 네트워크에 존재하는 임의의 시스템으로 패킷을 확장해             서비스 거부 공격을 수행하는 것으로, 네트워크 공격에 많이 사용힘.                             메일 폭탄 공격                        메일이 폭주하여 디스크 공간을 가득 채우면 받아야 할 메일을 받을 수 없음             스팸 메일을 서비스 거부 공격으로 분류                                              분산 서비스 거부 공격(DDoS)                분산 서비스 거부 공격의 기본 구성                        공격자(attacker) : 공격을 주도하는 해커 컴퓨터             마스터(master) : 공격자에게 직접 명령을 받는 시스템으로 여러 대의 에이전트를 관리             핸들러(handler) 프로그램 : 마스터 시스템의 역할을 수행하는 프로그램             에이전트(agent) : 직접 공격을 가하는 시스템             데몬(daemon) 프로그램 : 에이전트 시스템의 역할을 수행하는 프로그램                                              스니핑                스니핑 공격                        데이터 속에서 정보를 찾는 것으로 공격 시 아무것도 하지 않고 조용히 있는 것만으로도 충분하여 수동적 공격이라 함.             스니핑 공격자는 가지지 말아야 할 정보까지 모두 볼 수 있어야 하므로 랜 카드의 프러미스큐어스(promiscuous) 모드를 이용해 데이터 링크 계층과 네트워크 계층의 정보를 이용한 필터링을 해제함                             스니핑 공격의 종류                        스위치 재밍 공격                                스위치가 MAC 주소 테이블을 기반으로 포트에 패킷을 스위칭할 때 정상적인 스위칭 기능을 마비시키는 공격                 고가의 스위치는 MAC 테이블의 캐시와 연산자가 쓰는 캐시가 독립적으로 나뉘어 있어 스위치 재밍 공격이 통하지 않음                                         SPAN 포트 태밍 공격                                스위치 포트 미러링(port mirroring) 기능을 이용한 공격                                         포트 미러링                                각 포트에 전송되는 데이터를 미러링 하는 포트에도 똑같이 보내는 것으로 침입 탐지 시스템이나                 네트워크 모니터링 또는 로그 시스템을 설치할 때 많이 사용                                                                 스푸핑                스푸핑 공격의 종류                        ARP 스푸핑 공격                                ARP 스푸핑은 MAC 주소를 속이는 것                 로컬에서 통신하는 서버와 클라이언트의 IP 주소에 대한 데이터 링크 계층의 MAC 주소를 공격자의 MAC 주소로 속여 클라이언트에서 서버로 가는 패킷이나 서버에서 클라이언트로 가는 패킷이 공격자에게 향하게 하여 랜의 통신 흐름을 왜곡하는 공격                                         IP 스푸핑 공격                                트러스트 관계(신뢰 관계)를 맺고 있는 서버와 클라이언트를 확인한 후 클라이언트에 서비스 거부 공격을 하여 연결을 끊은 뒤 클라이언트의 IP 주소를 확보한 공격자는 실제 클라이언트처럼 패스워드 없이 서버에 접근하는 기법                                         ICMP 리다이렉트 공격                                네트워크 계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라고 알려 패킷의 흐름을 바꾸는 공격                                         DNS 스푸핑 공격                                실제 DNS 서버보다 빨리 DNS response 패킷을 보내어 공격 대상이 잘못된 IP 주소로 웹 접속을 하도록 유도하는 공격                                                                 세션하이재킹                세션하이재킹의 정의                        세션 가로채기라는 뜻             세션은 사용자와 컴퓨터 또는 두 컴퓨터 간의 활성화된 상태             세션 하이재킹은 두 시스템 간의 연결이 활성화된 상태, 즉 로그인된 상태를 가로채는 것                                     보안 프로토콜                SSL                        SSL은 방대한 인터넷 상거래의 안전을 위해 사용되는 프로토콜                             SSL 세션 vs 접속                        SSL은 HTTP 1.0과 함께 사용되도록 설계             HTTP 1.0은 보통 다수 접속을 병렬로 유지             SSL 세션 설정은 비용이 소요             공개키 연산이 필요             SSL 세션이 이미 존재할 때 효율적으로 새로운 SSL 접속을 구현하는 프로토콜 포함                             IPSec                        IPSec은 네트워크 계층에 존재             IPSec은 응용프로그램으로부터 자유             IPSec은 복잡한 프로토콜                                “너무 과도하게 기술적”                 별로 필요하지 않은 기능이 과도하게 많음.                                         결함 보유                                몇 가지 심각한 보안상 결함을 보유                                         상호운용성에 심각한 도전                                표준을 갖고 있는 목적에 부합하지 않음!                                         복잡성(반복적으로 강조)                             SSL vs IPSec 비교                        IPSec                                네트워크 계층에 존재(OS의 일부)                 암호화, 무결성, 인증 등을 포함하고 있음.                 과도하게 복잡(심각한 결말 포함)                                         SSL(IEEE 표준 TLS)                                소켓 계층(Session/Presentation/Application)(사용자 영역의 일부)                 암호화, 무결성, 인증 등을 포함하고 있음.                 간단한 규격                                                                  2. 4차 산업혁명 관련 기술           4차 산업혁명                4차 산업혁명이란 무엇인가                        파괴적 기술과 역사적 산업혁명의 전개             AI 기술을 핵심동인으로 상품,서비스의 생산,유통,소비 전 과정에서 모든것이 연결되고 지능화                                              4차 산업혁명의 주요기술                기술 맵                        6대 디지털화 기술                                IoT 사물인터넷 : 사물들의 초연결                 LBS : 공간정보의 디지털화                 클라우드 : 빅데이터의 공간                 빅데이터 : 가치 있는 거대한 데이터                 IoB(웨어러블) : 인간과 스마트기기의 융합                 플랫폼 : 인간의 융합 촉진 연결망                                         6대 아날로그화 기술                                서비스 디자인 : 인간을 위한 서비스 제공                                                                                                         3D 프린터                         로봇 : 가상의 정보를 물질화                                                                                                 증강 가상 현실 : 가상정보를 현실 경험화                 블록체인 핀테크 : 분산화된 신뢰와 거래                 게임화 : O2O의 동기부여                 플랫폼 : 반복되는 공통역량의 공유                                                                          IoT-Bigdata-AI                기술 맵                        개념                                                                                                                        IoT                         Mobile : 모든 기계,인간으로부터 데이터 수집                                                                                                 Cloud &amp; Big Data : 정보처리능력 고도화로 데이터 축적,분석 강화                                                                                                         A.I.                         새로운 가치 : 기계가 데이터로 빠르게 학습하여 새로운 지능정보 가치 창출                                                                                                                         특징 -만물의 데이터화                                실시간 반응                 자율 진화                                                         적용 사례 : 아마존                        데이터 수집(IoT) : 고객의 구매정보 데이터 수집             저장 &amp; 분석(CLOUD/ BIG DATA) : 구매 패턴 빅 데이터화             가치창출(A.I) : 인공지능으로 예상 구매 물품 예상                                                                                     최적화(기술융합) : 발주전 배송 서비스                     유통과 물류 비용 감소                                                                                                              IoT(Internet of Thing)                센서 기반 디바이스로부터 데이터/정보추출         확장성있는 유무선 네트워크를 통해 안정적 전송         효과적 분석을 통한 자동화, 지능형 서비스 구현                                 Sensor       Device       Network Security       Standards       Service                       고성능화   소형화   다기능화   저전력화       OPEN H/W   OPEN S/W       저전력화   장거리 통신   낮은 비용   안정성/보안       공유   안정적   표준화       OPEN API   Cloud Service   Application                   빅데이터                빅데이터의 특성                        속도 : 데이터가 생성되고, 저장되며, 가공되어 표시되는 속도가 빠름도             크기 : 데이터의 물리적인 크기가 매우 큼             다양성 : 데이터의 형태 유무와, 연산가능 여부에 따라 나누어지는 데이터들이 매우 다양             빅데이터의 공통적 속성 3V = 속도(Velocity), 크기(Volume), 다양성(Variety) 최근에는 정확성(Veracity)과 가변성(variability), 가치(Value), 시각화(Visualization)등의 속성이 추가                                                     구분       전통적 데이터       빅데이터                       데이터 원천       전통적 정보 서비스       일상화된 정보 서비스                 목적       업무와 효율성       사회적 소통, 자기표현, 사회 기반 서비스                 생성 주체       정부 및 기업 등 조직       개인 및 시스템                 데이터 유형       정형 데이터   조직 내부 데이터(고객 정보, 거래 정보, 등)   주로 비공개 데이터       비정형 데이터   (비디오 스트림, 이미지 오디오, 소셜 네트워크 등 사용자 데이터, 센서 데이터, 응용프로그램 데이터 등)                 데이터 특징       데이터 증가량 관리 가능   신뢰성 높은 핵심 데이터       기하급수로 양적 증가   쓰레기 데이터 비중 높음   문맥 정보 등 다양한 데이터                 데이터 보유       정부, 기업 등 대부분 조직       인터넷 서비스 기업(구글, 아마존 등)   포털(네이터, 다음 등)   이동 통신사(SKT,KT 등)   디바이스 생산회사(삼성, 애플 등)                 데이터 플랫폼       정형 데이터를 생산, 저장, 분석, 처리 할 수 있는 전통적 플랫폼       비정형 대량 데이터를 생산, 저장, 분석, 처리할 수 있는 새로운 플랫폼                   빅데이터 장단점                장점                        의사결정의 정확도를 높일 수 있다.             가까운 미래를 예측하고 새로운 기회를 창출 할 수 있다.             고객에 관한 통찰력을 향상 시킬 수 있다.                             단점                        프라이버시             예측이 완벽하지 않다.                                     빅데이터 관점                소스로서 빅데이터는 대용량 자료나 문제해결 및 분석을 위한 원천자료를 의미         분석으로서 빅데이터는 자료의 분석과 해석에서 어떠한 의미를 도출하는 과정         시각화로서 빅데이터는 데이터의 시각화나 시각화 이전 현상을 구조화하거나 패턴화하는 것         문화로서 빅데이터는 문화를 발견하고 이해하고 예측하는 도구를 의미                 빅데이터 분석과정                빅데이터 분석과정에서 가장 우선되어야 하는 것은?                        where : 데이터를 어디로부터 가져오는가             why : 데이터 분석 결과가 왜 필요한가             who : 누구를 위해 사용할 것인가                                     빅데이터 처리과정                데이터소스 -&gt; 수집 -&gt; 저장 -&gt; 처리 -&gt; 분석 -&gt; 표현                          AI                인공지능의 중요성                        최근 들어 인공지능이 중요한 화두로 떠오른 데에는 빅데이터로 대변되는 데이터양의 폭발적인 증가가 한몫 함             기존에 보유하고 있던 데이터는 물론, 사물인터넷으로 수집된 데이터까지 분석하여 비즈니스에 활용하고자 하는 요구가 많아 짐             범용성 : 하나의 기술을 여러 용도로 다양한 산업에 사용할 수 있음을 의미함             최근에는 인공지능의 범용성이 높아짐             기존에는 IT 산업에만 인공지능 기술이 적용되었다면, 최근에는 제조, 금융, 의료 등 전 산업에 적용되고 있는 추세                             인공지능 서비스 개발 과정                        데이터 수집 : 사용자 문의, 다른 회사와의 협업             데이터 저장 및 처리 : 저장 및처리 장치 이용, 클라우드 서비스 이용             프로그램 제작 : AI 알고리즘 활용, 패턴 분석 및 제작             서비스 배포 : 클라우드 서비스 활용                             AI 서비스 개발을 위한 기술                        데이터 수집에 필요한 사물인터넷 기술             데이터를 전송하기 위한 5G 기술             데이터를 저장하고 처리하기 위한 클라우드 기술             패턴 분석을 위한 인공지능 기술                                              블록체인                블록체인은 제 3자 도움 없이 타인과의 거래를 가능하게 하고, 그 거래를 기록한 장부 시스템을 유지하는 기술개념         블록체인에 관한 다양한 정의                        TCP/IP와 같은 기술 프로토콜 계층             거래 데이터베이스, 모든 거래들의 탈중앙화된 공공장부             거래 목록으로 이루어진 블록들의 체인으로, 거래들의 순차적 장부이다.             새로운 형태의 정보기술로, 지구적 스케일의 조직 시스템이자 인프라로서 자기점검능력과 통제력을 가지는 탈중앙화된 시스템             자기결정과 책임을 가지는 디지털 노마드를 성장시키는 기반환경                             주요기능                        거래 승인과 함께 거래 정보가 공유되는 플랫폼             암호화 기술을 통해 구현된 안전한 데이터 저장소             서로 신뢰가 없는 주체들을 연결시켜주는 통로                             주요 매커니즘                        거래의 유효성 검증             거래내역이 분산 및 공유             암호화되어 저장                             How it work                        거래요청 -&gt; 거래정보가 네트워크 참여자들로 전파 -&gt; 거래 유효성 검증 -&gt; 거래정보 담긴 블록 생성 -&gt; 블록체인에 블록 연결 -&gt; 거래승인 완료                             블록체인 확장분야 8C                        Currency : 비트코인과 같이 다양한 목적의 파생 및 지능형 화폐들이 등장할 수 있다.             Contract : 일정 조건을 만족시키면 자동으로 거래가 실행되도록 하는 것으로 소유권 이전이나 상속,증여 등에 사용될 수 있다.             Cross border : 국제 송금 서비스 등의 국제 금융거래를 획기적으로 개선할 수 있으며 효율적으로 거래를 가능하도록 한다.             Community : OPA를 활용하여 기존 상품권, 로열티 포인트 등을 블록체인에 기입하고 관리할 수 있다.             Common Record : 블록체인은 공공기록을 관리하기에 적합하고 효율적인 기술로 활용될 것으로 전망된다.             Consensus : 발행된 토큰을 유권자에게 나눠주고 정책이나 후보에게 토큰을 다시 보내는 방식으로 투표가 가능하다.             Contents : 디지털아트, 웹툰 등의 저작권을 증명하는것이 가능하여 새로운 콘텐츠 시장의 등장도 가능하다. (NFT)             Co-Ownership : 집, 자동차 등의 소유권 등록 후 이용시간과 범위 등 세부적인 수준으로 공유할 수 있다.                                              클라우드                클라우드로 인한 변화                        클라우드 컴퓨팅은 이제 단순히 기술 트렌드가 아니라 이미 우리 생활 속에 깊숙이 들어온 것             네이버 N드라이브나 드롭박스 등의 퍼스널 클라우드는 동기화 기술의 발전과 더불어 언제 어느 곳에서나 문서를 편집하고 공유                             엣지 컴퓨팅                        센서와 디바이스에서 쏟아지는 데이터를 네트워크 엣지에서 먼저 선별한 후, 중요한 데이터만을 서버로 내보내는 기술             특징                                엣지 컴퓨팅은 클라우드 컴퓨팅의 단점인 안전성, 즉시성, 효율성을 극복할 수 있는 대안                 자율주행 자동차(네트워크 지연이나 데이터 전송 오류로 인한 사고 예방)                 항공엔진 및 드론(산업기계 자체가 중앙 서버와 원거리에 있는 연결의 문제 해결)                 스마트 팩토리(대규모의 센서 데이터에 대한 효율적 처리가 필요) 등에 적용                                                         클라우드 컴퓨팅 vs 엣지 컴퓨팅                        클라우드 컴퓨팅은 ‘클라우드 데이터 센터’에 아웃소싱 준 형태라면, 엣지 컴퓨팅은 클라우드에 위임했던 작업을 ‘엣지’에서 한 차례 추린 후 데이터 센터로 전달하는 방식                             클라우드의 구분                        하이브리드 클라우드                                퍼블릭 클라우드와 프라이빗 클라우드의 결합 모델                 퍼블릭 프라이빗 클라우드의 장접을 모아 클라우드가 줄 수 있는 혜택을 최대한 제공하는 유형                                         오픈스택(OpenStack)                                클라우드 환경에서 컴퓨팅 자원과 스토리지 인프라를 셋업하고 구동하기 위해 사용하는 오픈소스 소프트웨어 프로젝트의 집합                                                                          5G                이동통신의 환경변화                        초고속                                2020년까지 개인당 매월 생성하는 데이터 양이 15년 대비 6.6배 증가 예상                 이 중 비디오 사용량이 전체 모바일 데이터 트래픽의 75% 차지                                         저지연                                자율 주행 차량이 매일 동안 4,000GB 데이터 생성 운전자와 차량을 안전하게 유지하기 위해 밀리 초 단위 의사 결정 필수                                         초연결                                2020년까지 모바일 사용자수는 15년 48억에서 55억으로 증가 예상                 모바일 기기 및 연결은 기기 85억개와 M2M 연결 31억개를 포함해 2020년까지 79억개(15년)에서 116억개로 증가 전망                                                         공식명칭                        5G 이동통신은 3GPP*에서 기술 표준화에 대한 논의가 시작되었으며 ITU**에서는 IMT-2020이라는 공식 명칭                             5G 네트워크의 기술적 특징                        최대 전송속도 향상             다수 기기 연결             초저지연 실시간 서비스                             5G 서비스 영역                        초고속                                4K/8K UHD                 홀로그램                 VR,AR                                         저지연                                실시간 통신 및 촉감 인터넷                 로봇 실시간 원격 조종                 커넥티드 카 (V2X)                                         초연결                                시설, 환경 원격 감시 및 제어                 스마트 빌딩/도시                 사물인터넷                                                                  4차 산업혁명 관련 기출문제           빅테이터 활용 방안에 대해서 설명하시오.      답변 Point : 지원한 회사의 서비스 (가능하다면 차세대 전력 서비스)에 적용하여 설명하자. 지원한 회사에 대한 정확한 분석이 필요  예시 : ex.카카오 모빌리티 카카오 모빌리티는 오랜 기간 동안 카카오택시 등의 서비스로 다양한 종류의 빅데이터를 수집했습니다. 그리고 빅데이터를 기반으로 하는 다양한 서비스를 제공하고 있습니다. 제가 그 서비스에 하나를 더한다면, 카카오택시를 운행하는 기사님들의 이동경로 빅데이터를 활용해서 기사식당과 같은 로컬 맛집을 제공하고 싶습니다.           인공지능 기술은 회사의 사업에 적용해서 설명하시오.      답변 Point : 회사의 사업분야 중에서 인공지능이 필요로 하는 영역이나 반복적인 연산과 판단이 필요한 분야를 제안하자.  예시 : ex. 우아한 형제들 우아한 형제들이 제공하는 배달의 민족 어플에서 사용자의 주문내역과 날씨 등의 환경을 분석해서 사용자에게 음식을 추천하는 서비스를 제공합니다. 가령, 고객이 치킨을 지속적으로 주문을 했다면 치킨의 종류를 분석하여 고객이 한 종류의 치킨을 주로 시킨다면 다른 브랜드의 유사한 치킨이 나왔을 때 추천해주거나, 고객이 새로운 유형의 치킨을 시킨다면 새로운 유형의 치킨이 나올 때 추천하는 등의 배달메뉴 추천 서비스를 인공지능 기술을 활용하여 제공할 수 있습니다.           실생활에서 볼 수 있는 사물인터넷 기술에 대해서 설명하시오.      답변 Point : 거창한 기술이 아닌, 주변에서 기술요소들을 찾자. 사물인터넷은 교통분야, 방제분야, 상하수 처리분야 등에서 활용되고 있다. 구체적으로 답변하는 것이 필요하다.  예시 : 사물인터넷은 모든 사물에 인터넷을 연결하여 정보를 수집하고 수집된 정보를 기반으로 다양한 서비스를 제공하는 것으로 이해하고 있습니다. 주변 환경에서도 가깝게 찾는다면, 면접 보러 가는 길에 적용된 IoT 기술의 두 가지 사례를 얘기해보겠습니다.  집 근처에의 하천 길에는 하천의 수위를 측정하는 센서와 하천의 수위를 모니터링 하는 CCTV가 있습니다. 이렇게 수집된 정보는 재난방지 시스템에 연동되는 것으로 알고 있습니다.  두 번째로는 버스는 타고 면접장까지 이동할 때, 정류장에는 버스의 이동을 탐지하는 센서와 카메라가 있어 버스 안에서도 버스의 위치를 파악하고, 버스 내부를 모니터링 하는 CCTV가 이러한 정보들도 수집되는 것으로 알고 있습니다.           4차 산업혁명의 핵심 기술들을 은행에서 어떻게 활용해야 하는가?      답변 Point : 4차 산업혁명의 대표적인 기술은 IoT - 빅데이터 - AI가 큰 줄기를 가지고 있다. 이 줄기 기반으로 확장해서 설명할 수 있다. 은행에서 (또는 기업에서) 활용할 수 있는 방법을 제시하자.  예시 : 은행은 신규상품을 개발하기 위해서 자사 및 계열사의 고객정보나 SNS 등을 통해 수집된 데이터, 기후,재난과 같은 사회,자연 현상과 관련된 데이터 등 다양하고 광대한 정보를 활용할 수 있습니다. 특히 신규 개발상품의 적절한 가격을 책정하는 데(예: 보험 상품의 효율 책정)에 사용할 수 있습니다.   Final. 기본 이론 5가지 WRAP - UP           소프트웨어 공학                소프트웨어 개발 주기         프로세스                        정의             모델(5가지)                             아키텍쳐                        정의             모델(4가지)                                              프로그래밍                프로그래밍 언어종류         객체지향                        개요 및 특징             객체지향 언어(Java)                             데이터 분석 주요언어         인공지능 주요언어         IoT 사물인터넷         형상관리         디자인 패턴         리팩토리                          웹/모바일 서비스                웹서비스         웹서버                        웹페이지             클라이언트 서버             웹서버 종류 (6가지)             웹서버 구성             웹기술                             모바일 서비스                        모바일 앱             모바일 웹             하이브리드 앱                                              데이터베이스                데이터 분류         DB관리시스템         DB 용어         DB 언어         View 정의         Index 정의         데이터 모델링                        개념, 절차, 구성             관계데이터 모델             논리적데이터 모델                             정규화                          네트워크                OSI7 layer         TCP/IP         Routing                 ","categories": ["CS"],
        "tags": ["CS"],
        "url": "http://localhost:4000/cs/CS_Basic_3/",
        "teaser": null
      },{
        "title": "[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (연관관계 매핑 기초, 다양한 연관관계 매핑)]",
        "excerpt":"    ##  ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-2/",
        "teaser": null
      },{
        "title": "[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (고급매핑, 프록시와 연관관계 관리)]",
        "excerpt":"    고급매핑   1. 상속관계 매핑           관계형 데이터베이스는 상속 관계 X (객체는 상속관계가 있음)     슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사     상속관계 매핑 : 객체의 상속 구조와 DB의 슈퍼타입, 서브타입 관계를 매핑              슈퍼타입 논리 모델을 실제 물리 모델로 구현하는 방법                각각 테이블로 변환 -&gt; 조인 전략                         앨범 데이터를 추가하면 ITEM과 ALBUM에 insert가 된다. (즉, insert 2번)             ITEM 테이블의 DTYPE를 통해 어느 테이블과 조인할지 구분 가능                             통합 테이블로 변환 -&gt; 단일 테이블 전략                         DTYPE을 통해 Album, Movie, Book중 무엇인지 구분 가능                             서브타입 테이블로 변환 -&gt; 구현 클래스마다 테이블 전략                          주요 어노테이션                @Inheritance(strategy = InheritanceType.XXX)                        JOINED : 조인전략             SINGLE_TABLE : 단일 테이블 전략             TABLE_PER_CLASS : 구현 클래스마다 테이블 전략                             @DiscriminatorColumn(name=“DTYPE”)         @DiscriminatorValue(“XXX”)                  @Entity @Inheritance(strategy = InheritanceType.JOINED) //JOINED를 SINGLE_TABLE로 바꾸면 단일 테이블 전략 @DiscriminatorColumn  // (name = \"DIS_TYPE)을 적으면 컬럼명 바꾸기 가능 //단일 테이블 전략은 @DiscriminatorColumn 안써도 자동으로 DTYPE 생성됨(한 테이블에 들어가있기때문에 DTYPE이 없으면 뭔지 알수없다.) public abstract class Item {      @Id @GeneratedValue     private Long id;      private String name;     private int price; }           JPA의 장점 : 조인 테이블 전략으로 개발하다가 단일 테이블 전략으로 바꿔야 할 경우 @Inheritance 어노테이션만 수정하면 된다      @Entity @DiscriminatorValue(\"A\") public class Album extends Item{      private String artist; }   public class JpaMain {      public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");          EntityManager em = emf.createEntityManager();          EntityTransaction tx = em.getTransaction();         tx.begin();          try {             Movie movie = new Movie();             movie.setDirector(\"aaaa\");             movie.setActor(\"bbbb\");             movie.setName(\"바람\");             movie.setPrice(10000);              em.persist(movie);//(조인 전략 사용시 insert 두번, 단일테이블 전략 사용시 insert 한번)              em.flush();             em.clear(); //영속성 컨텍스트 제거, 1차 캐시 비움              Movie findMovie = em.find(Movie.class, movie.getId()); //실행시 콘솔에 쿼리가 나온다. (조인 전략은 조인 사용)             System.out.println(\"findMovie = \" + findMovie);              tx.commit();         }catch (Exception e){             tx.rollback();         }finally {             em.close();         }         emf.close();     } }   조인 전략 실행결과      ITEM 테이블과 MOVIE 테이블의 ID는 똑같다. (ITEM의 ID는 PK, MOVIE의 ID는 PK,FK)   DTYPE의 M은 Movie (@DiscriminatorValue을 사용)             장점                테이블 정규화         외래 키 참조 무결성 제약조건 활용가능 (ITEM_ID 사용, 설계가 깔끔해짐)         저장공간 효율화 (정규화가 되어있기 때문에)                 단점                조회시 조인을 많이 사용, 성능 저하 (조인을 잘 하면 성능저하 크게 발생 안함, 저장공간이 효율화 되어있기 때문에 오히려 성능이 잘 나올수도 있다)         조회 쿼리가 복잡함         데이터 저장시 INSERT SQL 2번 호출                          조인전략이 정석이라고 생각하면 된다.     객체와도 잘 맞고 정규화도 되고 깔끔하게 설계 가능     단일 테이블에 비해서는 복잡하다      단일 테이블 전략 실행결과                장점                조인이 필요 없으므로 일반적으로 조회 성능이 빠름         조회 쿼리가 단순함                 단점                자식 엔티티가 매핑한 컬럼은 모두 null 허용 (데이터 무결성 입장애서는 애매한게 있다)         단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다. (웬만해서는 임계점을 넘을 경우가 거의 없다.)                  구현 클래스마다 테이블 전략 결과      ITEM 테이블은 안만들어진다.   구분할 필요가 없기 때문에 DTYPE도 안만들어진다.   쿼리도 심플하게 들어가서 좋은것 같지만 데이터를 찾을때 큰 문제 발생.   ex) ITEM_ID만 알 경우, 모든 테이블에서 찾아서(select시 union 사용) 매우 비효율적이다.            이 전략은 DB 설계자와 ORM 전문가 둘 다 추천 X     장점                서브 타입을 명확하게 구분해서 처리할 때 효과적         not null 제약조건 사용 가능                 단점                여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)         자식 테이블을 통합해서 쿼리하기 어려움                          테이블이 묶이는게 없기 때문에 전부 다 조회해야함     새로운 타입을 추가할때 변경할게 굉장히 많아진다.     이 전략을 사용할 경우 먼 미래에 언젠가는 큰 후회를 한다.      언제 뭘 사용할까?           보통 조인 전략을 선택, 엄청 단순하고 확장할 일도 없을 경우 단일테이블 전략 선택      2. Mapped Superclass - 매핑 정보 상속           공통 매핑 정보가 필요할 때 사용(id, name)      ex) 객체 입장에서 id, name 필드가 계속 나올 때, 클래스 만들때 마다 id, name 필드를 생성하기 귀찮으니까 부모 클래스에 두고 속성만 상속해서 사용하고 싶은경우   DB는 완전히 다른데, 객체 입장에서 속성만 상속받아서 쓰고싶은 경우   즉, 귀찮아서 귀찮음을 줄일 때 사용      ex) 모든 테이블에서 누가, 언제 등록, 수정했는지에 대한 정보가 항상 있어야 할 경우   /* private String createdBy; private LocalDateTime createdDate; private String lastModifiedBy; private LocalDateTime lastModifiedDate; MappedSuperclass를 사용하지 않으면 이 코드를 모든 테이블에 작성해야한다.*/ //MappedSuperclass를 사용하면 상속받아서 사용할 수 있다. @MappedSuperclass //매핑 정보만 받는 부모 클래스 public abstract class BaseEntity {      //@Column(name = \"INSERT_MEMBER\") 컬럼 이름 변경시 사용     private String createdBy;     private LocalDateTime createdDate;     private String lastModifiedBy;     private LocalDateTime lastModifiedDate;      //getter setter 생략 }   @Entity public class Member extends BaseEntity{      @Id @GeneratedValue     @Column(name = \"MEMEBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username; }   //JpaMain의 try 내부 코드 try {              Member member = new Member();             member.setUsername(\"user1\");             member.setCreatedBy(\"kim\");             member.setCreatedDate(LocalDateTime.now());              em.persist(member);              tx.commit();      }            상속관계 매핑 X     엔티티 X, 테이블과 매핑 X(속성만 내려주는애)     부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공     조회, 검색 불가 (em.find(BaseEntity.class) 불가능)     직접 생성해서 사용할 일이 없으므로 추상 클래스 권장              테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할     주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용     참고 : @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능 (JPA에서 extends를 사용할때)              실무에서 BaseEntity를 만들어서 활용하면 편리하다.      프록시와 연관관계 관리   1. 프록시           프록시 사용 이유?                Memeber 테이블과 Team 테이블이 연관관계를 가질 때, 프록시를 사용하지 않아서 지연로딩을 사용할 수 없다면 Member를 JPA를 통해 조회할 때 연관관계인 Team까지 함께 조회된다.   여기서 문제가 되는 이유는 Member만 필요한데 연관관계인 Team까지 다 불러와서 메모리에 올라와있기 때문에 리소스 낭비가 생긴다.   만약 프록시를 사용하여 지연로딩이 가능해지면 Team을 지연로딩으로 처리하고(Team은 불러오지 않게 됨) Member만 불러올 수 있게된다.   이 과정에서 Team을 불러오지 않기 때문에 리소스의 낭비를 조금이라도 줄일 수 있다. 이러한 지연로딩이라는 기술을 가능케 하는게 프록시이다.                          프록시의 기초                em.find() vs em.getReference();                        em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회 (쿼리가 나감)             em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회 (쿼리가 안나감)                                                 프록시 특징 1                실제 클래스를 상속 받아서 만들어짐         실제 클래스와 겉 모양이 같다.         사용하는 입장에서는 진짜 객체인지 프롤시 객체인지 구분하지 않고 사용하면 됨 (이론상)         프록시 객체는 실제 객체의 참조(target)를 보관         프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출                              프록시 객체의 초기화         try{     // Member findMember = em.find(Member.class, member.getId()); //쿼리 나감     Member findMember = em.getReference(Member.class, member.getId()); //getReference를 호출하는 시점에는 쿼리 안나감     System.out.println(\"findMember = \" + findMember.getClass()); // 출력결과 : hellojpa.Member$HibernateProxy$odcVHpjy  (Hibernate가 강제로 만든 가짜 클래스(프록시))     System.out.println(\"findMember.id = \" + findMember.getId()); // 아직 쿼리 안나감, Reference를 찾을때 getId를 넣었기 때문에 즉, 이미 값이 있기 때문에 쿼리가 안나감     System.out.println(\"findMember.username = \" + findMember.getUsername()); // 쿼리 나감, findMember에 값을 채워야 하기 때문에 쿼리가 나간다.     System.out.println(\"findMember.username = \" + findMember.getUsername()); // 한번 더 호출 시, 바로 위에서 이미 초기화 되어있기 때문에 값만 출력됨 }           프록시 특징 2                프록시 객체는 처음 사용할 때 한 번만 초기화         프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능         프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함(==비교 실패, 대신 instance of 사용)         영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환         영속성 컨텍스트의 도움을 받을 수 없는 준 영속 상태일 때, 프록시를 초기화하면 문제 발생 (Hibernate는 org.hibernate.LazyInitializationException 예외를 터트림)                  Member findMember = em.getReference(Member.class, member.getId()); System.out.println(\"before findMember = \" + findMember.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$odcVHpjy System.out.println(\"findMember.username = \" + findMember.getUsername()); System.out.println(\"after findMember = \" + findMember.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$odcVHpjy // 교체되는것이 아니라 프록시는 유지가 되고 내부의 타겟에만 값이 채워지는것이다. //========================================================================================================================== Member member1 = new Member(); member1.setUsername(\"member1\"); em.persist(member1); Member member2 = new Member(); member1.setUsername(\"member2\"); em.persist(member2);  Member m1 = em.find(Member.class, member1.getId()); Member m2 = em.getReference(Member.class, member2.getId());  System.out.println(\"m1 == m2: \" + (m1.getClass() == m2.getClass())); //false가 나온다. logic(m1,m2); //비즈니스 로직에서는 메소드로 파라미터만 넘어오기 때문에 프록시가 넘어오는지 실제로 넘어오는지 모르기 때문에 == 비교를 하면 안된다. //ex private static void logic(Member m1, Member m2){     //System.out.println(\"m1 == m2: \" + (m1.getClass() == m2.getClass()));     System.out.println(\"m1 == m2: \" + (m1 instanceof Member)); //true     System.out.println(\"m1 == m2: \" + (m2 instanceof Member)); //true } //========================================================================================================================== Member m1 = em.find(Member.class, member1.getId()); System.out.println(\"m1 = \" + m1.getClass()); //출력결과 : hellojpa.Member  Member reference = em.getReference(Member.class, member1.getId()); System.out.println(\"reference = \" + reference.getClass()); //출력결과 : hellojpa.Member /* Reference를 했는데 프록시로 안나오는 이유 1. member를 이미 영속성 컨텍스트에 올려놨는데 굳이 프록시로 가져와봐야 이점이 없다. 2. JPA에서는 동일한 트랜잭션 내에서 엔티티의 동일성을 보장하기 때문에 타입 비교를 하면 true로 나온다. */ //========================================================================================================================== Member m1 = em.getReference(Member.class, member1.getId()); System.out.println(\"m1 = \" + m1.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB  Member reference = em.getReference(Member.class, member1.getId()); System.out.println(\"reference = \" + reference.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB  System.out.println(\"m1 == reference: \" + (m1 == reference)); // true /* 같은 프록시가 반환된 이유? 동일한 트랜잭션 내에서 엔티티의 동일성 보장 */ //========================================================================================================================== Member refMember = em.getReference(Member.class, member1.getId()); System.out.println(\"refMember = \" + refMember.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB  Member findMember = em.find(Member.class, member1.getId()); //실제 조회를 하기 때문에 쿼리 나감 System.out.println(\"findMember = \" + findMember.getClass()); //출력결과 : hellojpa.Member$HibernateProxy$mnqWhnB  System.out.println(\"refMember == findMember: \" + (refMember == findMember)); // true /* find에서도 프록시가 반환된 이유? 동일한 트랜잭션 내에서 엔티티의 동일성 보장 */ //=========================================================================================================================== Member refMember = em.getReference(Member.class, member1.getId()); System.out.println(\"refMember = \" + refMember.getClass()); //프록시  //em.close //영속성 컨텍스트 종료 em.detach(refMember); //영속성 컨텍스트 관리 안함 //em.clear //영속성 컨텍스트가 초기화 되므로 똑같이 에러가 발생  refMember.getUsername(); //위의 3가지 모두 org.hibernate.LazyInitializationException 에러 발생 System.out.println(\"refMember = \" + refMember.getUsername());           프록시든 아니든 개발에 문제가 없게 개발해야 된다.     실무에서 org.hibernate.LazyInitializationException이 많이 발생하므로 주의하자.              프록시 확인                프록시 인스턴스의 초기화 여부 확인                        PersistenceUnitUtil.isLoaded(Object entity)                             프록시 클래스 확인 방법                        entity.getClass().getName() 출력(..javasist.. or HibernateProxy…)                             프록시 강제 초기화                        org.hibernate.Hibernate.initialize(entity);                             참고 : JPA 표준은 강제 초기화 없음   강제 호출 : member.getName();                  Member refMember = em.getReference(Member.class, member1.getId()); System.out.println(\"refMember = \" + refMember.getClass()); //프록시  System.out.println(\"isLoaded = \" + emf.getPersistenceUnitUtil().isLoaded(refMember)); //출력 결과 : false  refMember.getUsername(); //강제 초기화 System.out.println(\"isLoaded = \" + emf.getPersistenceUnitUtil().isLoaded(refMember)); //출력 결과 : true  Hibernate.initialize(refMember); //강제 초기화   2. 즉시 로딩과 지연 로딩           지연로딩 LAZY를 사용해서 프록시로 조회          @Entity public class Member {      @Id @GeneratedValue     @Column(name = \"MEMEBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username;      @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name = \"TEAM_ID\")     private Team team; }  JpaMain의 try 내부 try{     Member m = em.find(Member.class, member1.getId());//Member만 가져옴     System.out.println(\"m = \" + m.getTeam().getClass()); // 프록시로 나옴     m.getTeam().getName(); //이때 TEAM에 대한 쿼리가 나옴, 초기화 }           Member와 Team을 자주 함께 사용한다면?                LAZY를 사용하면 Member 따로 Team 따로 쿼리가 각각 나가서 성능상 손해를 본다.         즉시 로딩 EAGER를 사용해서 함께 조회                      @Entity public class Member {      @Id @GeneratedValue     @Column(name = \"MEMEBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username;      @ManyToOne(fetch = FetchType.EAGER)     @JoinColumn(name = \"TEAM_ID\")     private Team team; }  JpaMain의 try 내부 try{     Member m = em.find(Member.class, member1.getId()); //조회를 할대 join을 사용해서 한방에 쿼리를 날림     System.out.println(\"m = \" + m.getTeam().getClass()); // 프록시가 아닌 hellojpa.Team가 나옴     System.out.println(\"teamName = \" + m.getTeam().getName()); //teamA }           프록시와 즉시로딩 주의                가급적 지연 로딩만 사용(실무에서는 즉시 로딩 사용하면 안됨)         즉시 로딩을 적용하면 예상하지 못한 SQL이 발생                        테이블이 여러개면 join도 여러개 나와서 성능이 저하되고 쿼리도 엄청 길게 나온다.                             즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.                        JPQL로 Member 조회할 경우, Member에 Team이 EAGER로 설정되어 있으면 Team도 같이 가져온다             최초 쿼리가 1개 나가고 추가로 N개의 쿼리가 나간다                             @ManyToOne, @OneToOne은 기본이 즉시 로딩 -&gt; LAZY로 설정하자         @OneToMany, @ManyToMany는 기본이 지연 로딩                          실무에서는?                모든 연관관계에 지연 로딩으로 설정         실무에서 즉시 로딩 사용하지 말것!         JPQL fetch join 사용 (데이터가 채워지기 때문에 루프를 돌려서 값을 출력해서 추가적인 쿼리가 안나간다.)         엔티티 그래프 기능 사용 (추후에 배울 내용)         배치사이즈 활용 (추후에 배울 내용)                  3. 영속성 전이(CASCADE)와 고아 객체           영속성 전이 : CASCADE                특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때         예 : 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장                          주의                영속성 전이는 연관관계 매핑하는 것과 아무 관련이 없다.         엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐이다.                          CASCADE의 종류                ALL : 모두 적용 (라이프사이클 전부 맞출 때)         PERSIST : 영속 (저장할때만 라이프사이클 맞출 때)         REMOVE : 삭제         MERGE : 병합         REFRESH : REFRESH         DETACH : DETACH                          쓰면 안되는 경우                소유자가 둘 이상일 때         완전히 종속적이지 않을 때         라이프사이클이 다를 때                  @Entity public class Parent {      @Id     @GeneratedValue     private Long id;      private String name;      @OneToMany(mappedBy = \"parent\", cascade = CascadeType.ALL, orphanRemoval = true)     private List&lt;Child&gt; childList = new ArrayList&lt;&gt;();      public void addChild(Child child){         childList.add(child);         child.setParent(this);     } }  @Entity public class Child {      @Id     @GeneratedValue     private Long id;      private String name;      @ManyToOne     @JoinColumn(name = \"parent_id\")     private Parent parent; }  JpaMain의 try 내부 try{     Child child1 = new Child();     Child child2 = new Child();      Parent parent = new Parent();     parent.addChild(child1);     parent.addChild(child2);      em.persist(parent); //Parent의 CascadeType.All 때문에 child도 같이 persist된다. }           고아객체                고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제         orphanRemoval = true (조심히 사용할것)         Parent parent1 = em.find(Parent.class, id);   parent1.getChildren().remove(0);   자식 엔티티를 컬렉션에서 제거         DELETE FROM CHILD WHERE ID=? 쿼리가 나간다                          주의                참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능         참조하는 곳이 하나일 때 사용해야함         특정 엔티티가 개인 소유할 때 사용         @OneToOne, @OneToMany만 가능         참고 : 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께 제거된다. 이것은 CascadeType.REMOVE처럼 동작한다.                          영속성 전이 + 고아객체, 생명주기                CascadeType.All + orphanRemoval=true         스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거         두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음         도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용                  etc. 에러   Cannot drop \"ITEM\" because \"FKF1UERPNMN49VL1SPBBPLGXAUN, FKABGE9EQALSPCEJIJ53RAT7PJH\" depends on it; SQL statement: drop table item [90107-200] 테이블을 드랍할 때 이런 오류가 발생 할 경우 pom.xml에서 hibernate 버전을 5.4.13.Final로 바꾸기 H2 데이터베이스 버전을 1.4.200로 바꾸기(재설치)   Quiz   문제 1. 조인 전략, 단일 테이블 전략보다 구현 클래스마다 테이블 전략을 사용하는게 더 편하고 좋다?    정답 확인             X        구현 클래스마다 테이블 전략은 DB 설계자와 ORM 전문가 둘 다 추천하지 않는 방법이다. 여러 테이블을 함께 조회할 경우 UNION을 사용하기 때문에 성능이 느리다.            문제 2. @MappedSuperclass 사용한 BaseEntity는 DB테이블로 만들어진다?    정답 확인             X        부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공해주는 역할만 하기 때문에 테이블이 만들어지지 않는다.            문제 3. 아래 코드의 출력결과는?   1. em.find(Member.class, m.getId())   em.flush(); em.clear();   2. em.getReference(Member.class, m.getId())   System.out.println(“1==2 : “ + 1==2);    정답 확인             false        em.find() 이후 member 객체는 영속성 컨텍스트로 관리된다. 그리고 한 트랙잭션안에서 이 객체의 동일함을 보장한다.   그러나 clear는 영속성으로 관리하던 모든 객체를 다 삭제하게 된다.   그리고 난 뒤 다시 DB의 정보를 기반으로 member 를 생성하게 되면 이전에 관리하던 member와는 관계 없는 객체가 된다.           ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-3/",
        "teaser": null
      },{
        "title": "[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (값 타입)]",
        "excerpt":"    값 타입   1. 기본값 타입           JPA의 데이터 타입 분류                엔티티 타입                        @Entity로 정의하는 객체             데이터가 변해도 식별자로 지속해서 추적 가능             예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능                             값 타입                        int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체             식별자가 없고 값만 있으므로 변경시 추적 불가             예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체                                              값 타입 분류                기본값 타입                        자바 기본 타입(int, double)             래퍼 클래스(Integer, Long)             String                             임베디드 타입(embedded type, 복합 값 타입)         컬렉션 값 타입(collection value type)                          기본값 타입                예 : String name, int age         생명 주기를 엔티티에 의존                        예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제                             값 타입은 공유하면 안됨                        예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨                                     참고 : 자바의 기본 타입은 절대 공유되지 않는다.                int, double 같은 기본 타입(primitive type)은 절대 공유되지 않음         기본 타입은 항상 값을 복사함         Integer 같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경 자체가 불가능                  public static void main(String[] args){     int a = 10;     int b = a;      b = 20;     //기본 타입 공유 테스트     System.out.println(\"a = \" + a); // a = 10     System.out.println(\"b = \" + b); // b = 20 }   2. 임베디드 타입           임베디드 타입(복합 값 타입)                새로운 값 타입을 직접 정의할 수 있음         JPA는 임베디드 타입(embedded type)이라 함         주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함         int, String과 같은 값 타입 (엔티티 아님)                          예제                회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다. =&gt; 너무 번잡하다.            회원 엔티티는 이름, 근무 기간, 집 주소를 가진다. =&gt; 이런식으로 묶어낼 수 있는게 임베디드 타입이다.             쉽게 말해서 Period, Address 클래스를 새로 만들었다고 생각하면 된다.                          임베디드 타입 사용법                @Embeddable : 값 타입을 정의하는 곳에 표시         @Embedded : 값 타입을 사용하는 곳에 표시 (둘 중 하나만 넣고 생략 가능)         기본 생성자 필수                          임베디드 타입의 장점                재사용         높은 응집도         Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음         임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함                          임베디드 타입과 테이블 매핑                DB 입장에서는 값타입을 쓰든 안 쓰든, 임베디드 타입을 쓰든 안 쓰든 회원 테이블은 똑같다. 매핑만 해주면 된다.            임베디드 타입은 엔티티의 값일 뿐이다.         임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.         객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능         잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음                  @Embeddable public class Period {      private LocalDateTime startDate;     private LocalDateTime endDate; }  @Embeddable public class Address {      private String city;     private String street;     private String zipcode;      public Address() {     }      public Address(String city, String street, String zipcode) {         this.city = city;         this.street = street;         this.zipcode = zipcode;     } }  @Entity public class Member {     @Id     @GeneratedValue     @Column(name = \"MEMBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username;      //기간 Period     @Embedded     private Period workPeriod;      //주소     @Embedded     private Address homeAddress }  JpaMain의 try 내부 try{     Member member = new Member();     member.setUsername(\"hello\");     member.setHomeAddress(new Address(\"city\",\"street\",\"10000\"));     member.setWorkPeriod(new Period());      em.persist(member); }           임베디드 타입과 연관관계         @Embeddable public class Address {      private String city;     private String street;     @Column(name = \"ZIPCODE\") //이름 설정도 가능     private String zipcode;      private Member member; //임베디드 안에 엔티티도 들어올 수 있다.      public Address() {     }      public Address(String city, String street, String zipcode) {         this.city = city;         this.street = street;         this.zipcode = zipcode;     } }           @AttributeOverride : 속성 재정의                한 엔티티에서 같은 값 타입을 사용하면?         컬럼 명이 중복됨         @AttributeOverrides, @AttributeOverride 를 사용해서 컬럼 명 속성을 재정의                  @Entity public class Member {     @Id     @GeneratedValue     @Column(name = \"MEMBER_ID\")     private Long id;      @Column(name = \"USERNAME\")     private String username;      //기간 Period     @Embedded     private Period workPeriod;      //주소     @Embedded     private Address homeAddress;      //주소  //   @Embedded  //   private Address homeAddress; // 중복 때문에 에러가 난다.      @Embedded     @AttributeOverrides({             @AttributeOverride(name=\"city\",                     column=@Column(name = \"WORK_CITY\")),             @AttributeOverride(name=\"street\",                     column=@Column(name = \"WORK_STREET\")),             @AttributeOverride(name=\"zipcode\",                     column=@Column(name = \"WORK_ZIPCODE\"))     })     private Address workaddress; }           임베디드 타입과 null                임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null                  @MappedSuperclass vs @Embeddable           @MappedSuperclass                Entity로 정의하는 것이고 여러 Entity에 공통적으로 적용해야 할 때 사용할 수 있다.         상속이다.         상속은 다중상속도 안되고 객체지향 설계상 유연성이 떨어진다.                 @Embeddable + @Embedded                Value 타입으로 정의하는 것이고 비슷한 속성을 가지는 애트리뷰트를 하나의 값으로 만들어 재사용성을 높일수 있는 방법이다.         위임이다.         JPQL을 사용할 때에는 엔티티에서 embedded type까지 쿼리하기 위해서 type을 명시해야 하는 불편함이 존재한다.                        예) 위임 사용: select u from User u where u.timestamped.createdDate &gt; ?             예) 상속 사용 : select u from User u where u.createdDate &gt; ?                                     대부분의 상황에서는 embedded type을 사용하는 것이 좋겠지만 단순한 데이터를 다룰 때에는 단순한 방식(@MappedSuperclass)을 선택하여 처리하는 것이 더 나은 경우도 있다.     @MappedSuperclass를 사용하는 경우                수정시간, 등록시간, 수정자, 등록자 처럼 대부분의 엔티티들이 공통으로 사용하는 속성들을 다룰때 사용한다.                  참고1   참고2   3. 값 타입과 불변 객체           값 타입은 복잡한 객체 세상은 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.              값 타입 공유 참조                임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함         부작용(side effect) 발생                             회원 1과 회원 2가 같은 주소를 볼 경우, city를 NewCity로 바꾸면 회원1과 회원2도 같이 NewCity로 바뀐다     의도적으로 쓰려면 값 타입을 쓰면 안되고 엔티티를 써야한다.      try{       Address address = new Address(\"city\", \"street\", \"10000\");        Member member = new Member();       member.setUsername(\"member1\");       member.setAddress(address);       em.persist(member);        Member member2 = new Member();       member2.setUsername(\"member2\");       member2.setAddress(address);       em.persist(member2);        member.getAddress().setCity(\"newCity\"); //member만 바뀌는게 아니라 member2까지 같이 바뀐다. (이런 버그는 잡아내기 어렵다.) }           값 타입 복사                값 타입의 실제 인스턴스인 값을 공유하는 것은 위험         대신 값(인스턴스)를 복사해서 사용                     try {              Address address = new Address(\"city\", \"street\", \"10000\");              Member member = new Member();             member.setUsername(\"member1\");             member.setAddress(address);             em.persist(member);              Address copyAddress = new Address(address.getCity(), address.getStreet(), address.getZipcode()); //copy             Member member2 = new Member();             member2.setUsername(\"member2\");             member2.setAddress(copyAddress);             em.persist(member2);              member.getAddress().setCity(\"newCity\"); //member2는 copyAddress로 저장했기 때문에 member2는 안바뀌고 member만 바뀐다. }           객체 타입의 한계                항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.         문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다.         자바 기본 타입에 값을 대입하면 값을 복사한다.         객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.                        누군가 실수로 복사하지 않고 직접 대입하는 경우는 컴파일러 레벨에서 막을 방법이 없다.                             객체의 공유 참조는 피할 수 없다.                  기본타입(primitive type) int a = 10; int b = a; //기본 타입은 값을 복사 b = 4; //a 값은 10으로 유지  객체 타입 Address a = new Address(\"Old\"); Address b = a; //객체 타입은 참조를 전달 b.setCity(\"New\"); //a와 b는 같은 인스턴스를 가르킨다. 따라서 a, b 둘 다 바뀐다.           불변 객체                객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단         값 타입은 불변 객체(immutable object)로 설계해야함         불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체         생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨 (setter를 private로 만들어도 됨)         참고 : Integer, String은 자바가 제공하는 대표적인 불변 객체                          불변이라는 작은 제약으로 큰 재앙을 막을 수 있다.              값을 바꾸고 싶다면?      Address newAddress = new Address(\"NewCity\", address.getStreet(), address.getZipcode()); member.setAddress(newAddress); //위 코드처럼 완전히 새로 만들어서 바꿔야한다.           값 타입은 side effect를 대비해서 불변으로 만드는걸 추천한다.      4. 값 타입의 비교           값 타입 : 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야함     동일성(identity) 비교 : 인스턴스의 참조 값을 비교, == 사용     동등성(equivalence) 비교 : 인스턴스의 값을 비교, equals() 사용     값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야함     값 타입의 equals() 메소드를 적절하게 재정의(주로 모든 필드 사용)      int a = 10; int b = 10; //a == b true Address address1 = new Address(\"city\", \"street\", \"10000\"); Address address2 = new Address(\"city\", \"street\", \"10000\"); //address1 == address2 false //address1.equals(address2) false (equals 오버라이드 전) //address1.equals(address2) true (equals 오버라이드 후) //Java에서는 ==비교시 참조값을 비교하기 때문에 false가 나온다.   5. 값 타입 컬렉션              값 타입을 하나 이상 저장할 때 사용     @ElementCollection, @CollectionTable 사용     데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.     컬렉션을 저장하기 위한 별도의 테이블이 필요함              값 타입 컬렉션 사용                값 타입 저장         값 타입 조회                        값 타입 컬렉션도 지연 로딩 전략 사용                             값 타입 수정         참고 : 값 타입 컬렉션은 영속성 전이(Cascade) + 고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.                        값 타입 컬렉션도 값 타입이기 때문에 라이프사이클이 member에 의존한다                                      Member      @ElementCollection     @CollectionTable(name = \"FAVORITE_FOOD\", joinColumns =     @JoinColumn(name = \"MEMBER_ID\"))     @Column(name = \"FOOD_NAME\")     private Set&lt;String&gt; favoriteFoods = new HashSet&lt;&gt;();      @ElementCollection     @CollectionTable(name = \"ADDRESS\", joinColumns =     @JoinColumn(name = \"MEMBER_ID\"))     private List&lt;Address&gt; addressHistory = new ArrayList&lt;&gt;();  JpaMain의 try 내부  try {              // 저장 예제             Member member = new Member();             member.setUsername(\"member1\");             member.setHomeAddress(new Address(\"homeCity\", \"street\", \"10000\"));              member.getFavoriteFoods().add(\"치킨\");             member.getFavoriteFoods().add(\"족발\");             member.getFavoriteFoods().add(\"피자\");              member.getAddressHistory().add(new Address(\"old1\", \"street\", \"10000\"));             member.getAddressHistory().add(new Address(\"old2\", \"street\", \"10000\"));              em.persist(member);              // 조회 예제             em.flush();             em.clear(); //깔끔한 상태에서 조회하기 위해 clear 해준다              Member findMember = em.find(Member.class, member.getId()); //쿼리를 보면 Member만 가져온다. 즉, 컬렉션은 지연로딩 사용              List&lt;Address&gt; addressHistory = findMember.getAddressHistory();             for (Address address : addressHistory) {                 System.out.println(\"address = \" + address.getCity()); //지연로딩이기 때문에 이때 쿼리가 나감             }              //수정 예제             //homeCity -&gt; newCity //            findMember.getHomeAddress().setCity(\"newCity\"); //immutable 해야하기 때문에 이런식으로 변경하면 절대 안된다.              Address a = findMember.getHomeAddress();             findMember.setHomeAddress(new Address(\"newCity\", a.getStreet(), a.getZipcode())); //이런식으로 완전히 교체를 해줘야한다.              //치킨 -&gt; 한식             //단순 String이기 때문에 remove로 지우고 add로 추가해야한다.             //String은 업데이트가 없다.             findMember.getFavoriteFoods().remove(\"치킨\");             findMember.getFavoriteFoods().add(\"한식\");              //old1 -&gt; newCity1             findMember.getAddressHistory().remove(new Address(\"old1\", \"street\", \"10000\"));             //remove의 기본 동작은 equals로 대상을 찾는다. 즉, equals, hashcode를 안넣으면 지워지지 않고 값이 계속 들어가게 된다.             findMember.getAddressHistory().add(new Address(\"newCity1\", \"street\", \"10000\"));             // 출력 결과 : MEMBER_ID를 기준으로 ADDRESS 테이블의 모든 컬럼이 delete가 되고 기존의 테이터인 old2와 새로운 데이터인 newCity1이 insert가 된다.             // 결론 : 쓰면안됨 }           값 타입 컬렉션의 제약사항                값 타입은 엔티티와 다르게 식별자 개념이 없다.         값은 변경하면 추적이 어렵다.         값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. (실무에서는 사용하면 안된다.)         값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야함 : null 입력 X, 중복 저장 X                          값 타입 컬렉션 대안                실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려 (실무에서 많이 쓰임)         일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용         영속성 전이(Cascade) + 고아 객체 제거를 사용해서 값 타입 컬렉션 처럼 사용         EX) AddressEntity                          값타입 컬렉션은 언제쓰이나?                엄청 단순할때 사용 (업데이트 필요 없을 때, 추적할 필요 없을 때)                  AddressEntity      @Id @GeneratedValue     private Long id;      public AddressEntity() {     }      public AddressEntity(Address address) {         this.address = address;     }      private Address address;      public AddressEntity(String city, String street, String zipcode) {         this.address = new Address(city, street, zipcode);     }  Member      @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)     @JoinColumn(name = \"MEMBER_ID\")     private List&lt;AddressEntity&gt; addressHistory = new ArrayList&lt;&gt;();            정리                엔티티 타입의 특징                        식별자 O             생명 주기 관리             공유                             값 타입 특징                        식별자 X             생명 주기를 엔티티에 의존             공유하지 않는 것이 안전(복사해서 사용)             불변 객체로 만드는 것이 안전                                              값 타입은 정말 값 타입이라 판단 될 때만 사용     엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨     식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것은 값 타입이 아닌 엔티티      Quiz   문제 1. 다음 코드의 상황별 출력 결과를 쓰시오.   Address address1 = new Address(\"city\", \"street\", \"10000\"); Address address2 = new Address(\"city\", \"street\", \"10000\");  상황 1. == 비교 System.out.println(address1 == address2)  상황 2. equals 비교, Address에 equals() 메소드 오버라이드 안함 System.out.println(address1.equals(address2))  상황 3. equals 비교, Address에 equals() 메소드 오버라이드 함 System.out.println(address1.equals(address2))    정답 확인             1. false             2. false             3. true                    == 비교는 참조값을 비교하기 때문에 false가 나온다.         equals()의 기본은 == 비교이기 때문에 false가 나온다.         equals() 메소드를 재정의할 경우 내부 값이 같은지 판별하기 때문에 true가 나온다.                        문제 2. 비슷한 기능을 가진 @MappedSuperclass와 @Embeddable의 차이점을 생각해보자.    정답 확인              @MappedSuperclass는 상속   @Embeddable은 위임         자세한 설명            ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-4/",
        "teaser": null
      },{
        "title": "[JPA 01. 자바 ORM 표준 JPA 프로그래밍 (객체지향 쿼리 언어 - 기본 문법)]",
        "excerpt":"    객체지향 쿼리 언어 - 기본 문법   0. 객체지향 쿼리 언어 소개           JPA는 다양한 쿼리 방법을 지원한다.                JPQL : 실무에서는 대부분 JPQL로 해결 가능         JPA Criteria         QueryDSL         네이티브 SQL         JDBC API 직접 사용, MyBatis, SpringJdbcTemplate                          JPQL 소개                가장 단순한 조회 방법                        EntityManager.find()             객체 그래프 탐색(a.getB().getC())                             ex) 나이가 18살 이상인 회원을 모두 검색하고 싶다면?                        단순히 하나를 찍어서 가져올수 있는것이 아니다.                                              JPQL                JPA를 사용하면 엔티티 객체를 중심으로 개발         문제는 검색 쿼리         검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색         모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능         애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요         위에 언급된 문제들을 해결하기 위해 JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공         SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원         JPQL은 엔티티 객체를 대상으로 쿼리         SQL은 데이터베이스 테이블을 대상으로 쿼리         테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리         SQL을 추상화해서 특정 데이터베이스 SQL에 의존X         JPQL을 한마디로 정의하면 객체지향 SQL         JPQL은 단순 문자이기 때문에 동적 쿼리를 만들기 매우 어렵다.                  //간단한 JPQL의 예 List&lt;Member&gt; result = em.createQuery(                     \"select m From Member m where m.age &gt; 18\",                     Member.class ).getResultList();  //실행된 SQL select     m.id as id,     m.age as age,     m.USERNAME as USERNAME,     m.TEAM_ID as TEAM_ID from     Member m where     m.age&gt;18           Criteria 소개                문자가 아닌 자바코드로 JPQL을 작성할 수 있음         쿼리문에서 오타를 내도 컴파일 시점에서 잡아준다         JPQL 빌더 역할         JPA 공식 기능         단점 : 너무 복잡하고 실용성이 없다.                        유지보수가 어려움             sql 같지가 않음             디버깅을 못함                             Criteria 대신에 QueryDSL 사용 권장                  //Criteria 사용 준비 CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class); //루트 클래스 (조회를 시작할 클래스) Root&lt;Member&gt; m = query.from(Member.class); //쿼리 생성 CriteriaQuery&lt;Member&gt; cq = query.select(m).where(cb.equal(m.get(\"username\"), \"kim\")); List&lt;Member&gt; resultList = em.createQuery(cq).getResultList();           QueryDSL 소개                문자가 아닌 자바코드로 JPQL을 작성할 수 있음         JPQL 빌더 역할         컴파일 시점에 문법 오류를 찾을 수 있음         동적쿼리 작성 편리함         단순하고 쉬움         실무 사용 권장                  //JPQL //select m from Member m where m.age &gt; 18 JPAFactoryQuery query = new JPAQueryFactory(em); QMember m = QMember.member; List&lt;Member&gt; list =         query.selectFrom(m)                 .where(m.age.gt(18))                 .orderBy(m.name.desc())                 .fetch();           네이티브 SQL 소개                JPA가 제공하는 SQL을 직접 사용하는 기능         JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능         예) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트                  em.createNativeQuery(\"select MEMBER_ID, city, street, zipcode, USERNAME from MEMBER\").getResultList();           JDBC 직접 사용, SpringJdbcTemplate 등                JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, MyBatis 등을 함께 사용 가능         단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요         예) JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시                  Quiz   문제 1. 다음 예제들의 성공 여부를 쓰시오.   예제 1. select o.member.team         from Order o -&gt; 성공  예제 2. select t.members from Team -&gt; 성공  예제 3. select t.members.username from Team t -&gt; 실패  예제 4. select m.username from Team t join t.members m -&gt; 성공    정답 확인             1. 성공             2. 성공             3. 실패             3. 성공                     컬렉션에서는 더 들어가면 안된다. 명시적 조인을 통해 별칭을 얻어야한다.                       ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "http://localhost:4000/jpa/JPA_Basic-5/",
        "teaser": null
      }]
